<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>The Shifting House</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', Courier, monospace;
            height: 100%;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas */
        }
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            color: #ccc;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            cursor: pointer;
            transition: opacity 0.5s;
            pointer-events: auto;
            z-index: 150;
        }
        #main-menu h1 {
            font-size: 3em;
            color: #a00;
            text-shadow: 2px 2px 4px #000;
        }
        #main-menu p {
            font-size: 1.2em;
            margin: 10px 20px;
        }
        #main-menu .controls {
            margin-top: 20px;
            font-size: 1em;
            color: #888;
        }
        #menu-extras {
            margin-top: 16px;
            display: flex;
            gap: 10px;
            align-items: center;
            pointer-events: auto;
        }
        #seed-input {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.2);
            color: #ddd;
            padding: 6px 8px;
            border-radius: 4px;
        }
        .menu-button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.25);
            color: #eee;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        /* --- Leaderboard --- */
        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 10px 12px;
            text-align: left;
            z-index: 50;
        }
        #leaderboard h3 {
            margin: 0 0 8px 0;
            font-size: 16px;
            color: #eee;
        }
        #leaderboard ul {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 200px;
            overflow: auto;
        }
        #leaderboard li {
            font-size: 12px;
            color: #bbb;
            padding: 4px 0;
            border-bottom: 1px dashed rgba(255,255,255,0.08);
        }
        #leaderboard li:last-child { border-bottom: none; }
        
        /* --- HUD & Popup --- */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        /* Top Left - Floor Debug Info */
        #hud-debug {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ddd;
            background: rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 12px;
            max-width: 200px;
            word-wrap: break-word;
        }
        
        /* Top Right - Flashlight Status */
        #hud-flashlight {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ddd;
            background: rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 14px;
            text-align: right;
            min-width: 120px;
        }
        
        /* Center Left - Main Game Info */
        #hud-main {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            color: #ddd;
            background: rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 14px;
            max-width: 200px;
            word-wrap: break-word;
        }
        
        /* Bottom Left - Health and Sanity */
        #hud-health {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #ddd;
            background: rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 14px;
            max-width: 200px;
            word-wrap: break-word;
        }
        
        #hud .bar {
            width: 160px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            margin-top: 6px;
            border-radius: 4px;
            overflow: hidden;
        }
        #hud .bar > div { height: 100%; background: #2ecc71; width: 100%; }
        #hud .affix { margin-top: 6px; color: #bbb; }
        
        /* Ensure HUD text doesn't get cut off */
        #hud div {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 16px 22px;
            color: #fff;
            background: rgba(160, 0, 0, 0.85);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            font-size: 28px;
            text-shadow: 2px 2px 6px #000;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            z-index: 300;
        }

        /* --- Settings & Pause --- */
        #pause-menu, #settings-panel, #summary-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10,10,10,0.9);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #ddd;
            padding: 16px 18px;
            min-width: 320px;
            display: none;
            pointer-events: auto;
            z-index: 200;
        }
        .row { display: flex; align-items: center; justify-content: space-between; margin: 6px 0; }
        .row input[type=range] { width: 180px; }
        .menu-actions { display: flex; gap: 8px; justify-content: center; margin-top: 12px; }
        .menu-button { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.25); color: #eee; padding: 6px 10px; border-radius: 4px; cursor: pointer; }
        
        /* --- Mobile Controls --- */
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 35%; /* Reduced to give more play area */
            display: none; /* Hidden by default */
            pointer-events: auto;
            z-index: 75;
        }
        #joystick-zone {
            position: absolute;
            left: 0;
            bottom: 0;
            width: 50%;
            height: 100%;
        }
        #joystick-base {
            position: absolute;
            bottom: 50px; /* Slightly reduced for better positioning */
            left: 50%;
            transform: translateX(-50%);
            width: 120px; /* Optimized size for better mobile playability */
            height: 120px; /* Optimized size for better mobile playability */
            background: rgba(128, 128, 128, 0.5); /* More visible */
            border: 3px solid rgba(255,255,255,0.7); /* Thicker border for better visibility */
            border-radius: 50%;
        }
        #joystick-thumb {
            position: absolute;
            width: 60px; /* Optimized size for better mobile playability */
            height: 60px; /* Optimized size for better mobile playability */
            background: rgba(200, 200, 200, 0.8); /* More visible */
            border: 3px solid rgba(255,255,255,0.9); /* Thicker border for better visibility */
            border-radius: 50%;
            top: 50%; /* Center vertically */
            left: 50%; /* Center horizontally */
            transform: translate(-50%, -50%); /* Perfect centering */
            transition: transform 0.1s;
        }
        #action-buttons {
            position: absolute;
            right: 5%; /* Optimized positioning */
            bottom: 50px; /* Optimized positioning */
            display: flex;
            flex-direction: column;
            gap: 12px; /* Optimized gap between buttons */
        }
        .action-button {
            width: 80px; /* Optimized size for better mobile playability */
            height: 80px; /* Optimized size for better mobile playability */
            background: rgba(200, 200, 200, 0.7); /* More visible */
            border: 3px solid rgba(255,255,255,0.8); /* Thicker border for better visibility */
            border-radius: 50%;
            color: #fff;
            font-size: 18px; /* Optimized font size */
            font-weight: bold; /* Added weight */
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            text-shadow: 1px 1px 2px #000; /* Added text shadow */
            box-shadow: 0 4px 8px rgba(0,0,0,0.4); /* Enhanced shadow for better visibility */
        }
        
        /* Mobile-specific HUD adjustments */
        @media (max-width: 768px) {
            #hud-debug {
                font-size: 12px; /* Smaller font for mobile */
                top: 5px;
                left: 5px;
            }
            
            #hud-flashlight {
                font-size: 12px; /* Smaller font for mobile */
                top: 5px;
                right: 5px;
            }
            
            #hud-main {
                font-size: 12px; /* Smaller font for mobile */
                top: 45%; /* Adjusted position to avoid mobile controls */
                left: 5px;
            }
            
            #hud-health {
                bottom: 40%; /* Moved up to avoid mobile controls */
                left: 5px;
                font-size: 12px; /* Smaller font for mobile */
            }
            
            #hud .bar {
                width: 120px; /* Smaller bars for mobile */
                height: 6px; /* Thinner bars for mobile */
            }
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="main-menu">
            <h1>The Shifting House</h1>
            <p>It hunts. It changes. It remembers.</p>
            <p style="font-size: 1.5em; color: #fff; margin-top: 30px;">[ CLICK TO BEGIN ]</p>
            <div class="controls">
                <p><strong>Desktop:</strong> WASD to Move | MOUSE to Look | E to Hide</p>
                <p><strong>Mobile:</strong> Use On-Screen Controls</p>
            </div>
            <div id="menu-extras">
                <input id="seed-input" placeholder="Custom seed (optional)" />
                <button id="daily-btn" class="menu-button">Daily Challenge</button>
            </div>
            <div id="leaderboard">
                <h3>Recent Runs</h3>
                <ul id="leaderboard-list"></ul>
            </div>
        </div>
         <div id="mobile-controls">
            <div id="joystick-zone">
                <div id="joystick-base">
                    <div id="joystick-thumb"></div>
                </div>
            </div>
            <div id="action-buttons">
                <div class="action-button" id="hide-button">Hide</div>
                <div class="action-button" id="interact-button">Interact</div>
                <div class="action-button" id="door-button">Door</div>
                <div class="action-button" id="flashlight-button">Light</div>
                <div class="action-button" id="crouch-button">Crouch</div>
            </div>
        </div>
        <div id="hud" style="display:none">
            <!-- Top Left - Floor Debug Info -->
            <div id="hud-debug">
                <div>Floor: <span id="hud-floor">1</span></div>
                <div>F: Flashlight <span id="hud-flash">Off</span></div>
                <div>Vits: <span id="hud-vits">0</span> | Picks: <span id="hud-picks">0</span></div>
                <div>Q: Smoke <span id="hud-smoke">0</span> | Z: Noise <span id="hud-noise">0</span></div>
                <div id="dpi-info" style="margin-top:6px;color:#aaa;font-size:12px;display:none;">Mouse: Detecting DPI...</div>
            </div>
            
            <!-- Top Right - Flashlight Status -->
            <div id="hud-flashlight">
                <div>🔦 Flashlight</div>
                <div id="flashlight-status">Not Found</div>
            </div>
            
            <!-- Center Left - Main Game Info -->
            <div id="hud-main">
                <div>Stage: <span id="hud-stage">1</span></div>
                <div>Time: <span id="hud-time">0:00.000</span></div>
                <div>Bronze: <span id="hud-bronze">0</span> | Gold: <span id="hud-gold">No</span></div>
                <div class="affix">Affix: <span id="hud-affix">None</span></div>
                <div id="exit-compass" style="margin-top:6px;color:#aaa;">Exit: ?</div>
                <div id="shift-timer" style="margin-top:6px;color:#ffaa00;font-size:12px;">Next shift: --</div>
                <div id="pause-indicator" style="margin-top:6px;color:#ffaa00;font-size:14px;font-weight:bold;display:none;">⏸️ PAUSED</div>
                <div id="enemy-spawn-indicator" style="margin-top:6px;color:#ffaa00;font-size:12px;display:none;">⚠️ Enemy spawning...</div>
                <div id="rush-warning" style="margin-top:6px;color:#ff4444;font-size:14px;font-weight:bold;display:none;">⚠️ RUSH! HIDE NOW!</div>
                <div id="panic-button-indicator" style="margin-top:6px;color:#ff0000;font-size:14px;font-weight:bold;display:none;">🚨 PRESS P FOR PANIC MODE!</div>
            </div>
            
            <!-- Bottom Left - Health and Sanity -->
            <div id="hud-health">
                <div class="bar"><div id="stamina-fill" style="width:100%"></div></div>
                <div class="bar" style="margin-top:4px;"><div id="sanity-fill" style="width:100%;background:#8B0000;"></div></div>
                <div id="hidden-indicator" style="margin-top:6px;color:#00ff00;font-size:14px;font-weight:bold;display:none;">🕳️ HIDDEN - Press H to exit</div>
                <div id="crouch-indicator" style="margin-top:6px;color:#478d8d;font-size:14px;font-weight:bold;display:none;">🦆 CROUCHING - Your footsteps are quieter</div>
                <div id="grace-period-indicator" style="margin-top:6px;color:#00ff00;font-size:14px;font-weight:bold;display:none;">- Enemies can't hear you</div>
            </div>
        </div>
        </div>
        <div id="popup"></div>
        <div id="pause-menu">
            <h3 style="margin:0 0 8px 0;">Paused</h3>
            <div class="menu-actions">
                <button id="btn-resume" class="menu-button">Resume</button>
                <button id="btn-restart" class="menu-button">Restart</button>
                <button id="btn-settings" class="menu-button">Settings</button>
            </div>
        </div>
        <div id="settings-panel">
            <h3 style="margin:0 0 8px 0;">Settings</h3>
            <div class="row"><label>Sensitivity</label><input id="opt-sens" type="range" min="0.5" max="3" step="0.1" value="1"></div>
            <div class="row"><label>Brightness</label><input id="opt-bright" type="range" min="0" max="0.8" step="0.05" value="0"></div>
            <div class="row"><label>Audio Volume</label><input id="opt-vol" type="range" min="0" max="1" step="0.05" value="0.5"></div>
            <div class="row"><label>Proximity Audio</label><input id="opt-audio-cues" type="checkbox" checked></div>
            <div class="row"><label>Resolution Scale</label><input id="opt-scale" type="range" min="0.5" max="1" step="0.05" value="1"></div>
            <div class="row"><label>Mouse DPI</label><button id="btn-detect-dpi" class="menu-button" style="width:100%;margin-top:4px;">Detect Mouse DPI</button></div>
            <div class="row" style="font-size:11px;color:#888;margin-top:2px;">Automatically adjusts rotation sensitivity for your mouse</div>
            <div class="menu-actions">
                <button id="btn-close-settings" class="menu-button">Close</button>
            </div>
        </div>
        <div id="summary-panel">
            <h3 style="margin:0 0 8px 0;">Run Summary</h3>
            <div id="summary-text" style="font-size:12px; color:#bbb;"></div>
            <div class="menu-actions"><button id="btn-summary-close" class="menu-button">Close</button></div>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
// =============================================================================
// --- GAME SETUP AND INITIALIZATION ---
// =============================================================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiLayer = document.getElementById('ui-layer');
const mainMenu = document.getElementById('main-menu');
const mobileControls = document.getElementById('mobile-controls');
const hud = document.getElementById('hud');
const hudStageEl = document.getElementById('hud-stage');
const hudFloorEl = document.getElementById('hud-floor');
const hudTimeEl = document.getElementById('hud-time');
const hudBronzeEl = document.getElementById('hud-bronze');
const hudGoldEl = document.getElementById('hud-gold');
const hudAffixEl = document.getElementById('hud-affix');
const staminaFill = document.getElementById('stamina-fill');
const sanityFill = document.getElementById('sanity-fill');
const popupEl = document.getElementById('popup');
const leaderboardList = document.getElementById('leaderboard-list');
const seedInput = document.getElementById('seed-input');
const dailyBtn = document.getElementById('daily-btn');
const exitCompass = document.getElementById('exit-compass');
const pauseMenu = document.getElementById('pause-menu');
const settingsPanel = document.getElementById('settings-panel');
const summaryPanel = document.getElementById('summary-panel');
const btnResume = document.getElementById('btn-resume');
const btnRestart = document.getElementById('btn-restart');
const btnSettings = document.getElementById('btn-settings');
const btnCloseSettings = document.getElementById('btn-close-settings');
const btnSummaryClose = document.getElementById('btn-summary-close');
const optSens = document.getElementById('opt-sens');
const optBright = document.getElementById('opt-bright');
const optVol = document.getElementById('opt-vol');
const optScale = document.getElementById('opt-scale');
const optAudioCues = document.getElementById('opt-audio-cues');
const btnDetectDpi = document.getElementById('btn-detect-dpi');
const summaryText = document.getElementById('summary-text');
const hudFlash = document.getElementById('hud-flash');
const hudVits = document.getElementById('hud-vits');
const hudPicks = document.getElementById('hud-picks');
const hudSmoke = document.getElementById('hud-smoke');
const hudNoise = document.getElementById('hud-noise');
const hudSanity = document.getElementById('hud-sanity');
const flashlightStatus = document.getElementById('flashlight-status');
const rushWarning = document.getElementById('rush-warning');
const panicButtonIndicator = document.getElementById('panic-button-indicator');
const hiddenIndicator = document.getElementById('hidden-indicator');
const crouchIndicator = document.getElementById('crouch-indicator');
const gracePeriodIndicator = document.getElementById('grace-period-indicator');
const enemySpawnIndicator = document.getElementById('enemy-spawn-indicator');
const pauseIndicator = document.getElementById('pause-indicator');
const shiftTimer = document.getElementById('shift-timer');
const dpiInfo = document.getElementById('dpi-info');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- GAME STATE ---
const GAME_STATE = { MENU: 'MENU', PLAYING: 'PLAYING', HIDDEN: 'HIDDEN', PAUSED: 'PAUSED', GAMEOVER: 'GAMEOVER', WON: 'WON' };
let currentGameState = GAME_STATE.MENU;

// --- CONSTANTS & SETTINGS ---
const MAP_SIZE = 21;
const MOVE_SPEED = 0.028; // Balanced player speed for better gameplay
const ROTATION_SPEED = 0.0015; // Reduced rotation sensitivity for smoother feel
const BASE_ENEMY_SPEED = 0.016; // Balanced enemy speed for fair challenge

// DPI detection and adjustment
let mouseDPI = 800; // Default DPI assumption
let dpiAdjustmentFactor = 1.0; // Will be calculated based on detected DPI
let lastMouseMovement = 0;
let dpiDetectionSamples = [];
const DPI_DETECTION_SAMPLES = 50; // Number of samples to collect for DPI detection
const SHIFT_INTERVAL = 75000;
const ENEMY_PATH_UPDATE_INTERVAL = 1000;
const FOV = Math.PI / 3;
const COLLISION_PADDING = 0.18; // How far to stay from walls
const MAX_RAY_STEPS = MAP_SIZE * MAP_SIZE;

// --- STAGES & RUN ---
const STAGES = ["Second stage", "Third stage", "Bloody stage", "Fourth stage", "Mansion stage"]; // After clearing stage 1
let stageIndex = 0; // 0 => first stage
let runStartTime = 0;
let stageStartTime = 0;
let totalElapsedMs = 0;
let currentAffix = "None";
let currentShiftInterval = SHIFT_INTERVAL;
let currentEnemySpeed = BASE_ENEMY_SPEED;
let currentPathUpdateInterval = ENEMY_PATH_UPDATE_INTERVAL;
let prng = Math.random;

// Polyfill for Math.imul if not available
if (!Math.imul) {
    Math.imul = function(a, b) {
        const ah = (a >>> 16) & 0xffff;
        const al = a & 0xffff;
        const bh = (b >>> 16) & 0xffff;
        const bl = b & 0xffff;
        return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
    };
}

// Initialize with a default seed to ensure prng works from the start
function initializePRNG() {
    const defaultSeed = hashStringToSeed('default');
    prng = mulberry32(defaultSeed);
}

// Initialize PRNG immediately to avoid undefined function errors
initializePRNG();

// DPI settings will be loaded after DOM elements are created

// DPI detection and adjustment functions
function detectMouseDPI() {
    // Reset detection
    dpiDetectionSamples = [];
    lastMouseMovement = 0;
    dpiAdjustmentFactor = 1.0;
    
    console.log("Starting DPI detection... Move your mouse slowly to calibrate sensitivity");
}

function calculateDPIAdjustment(movementX) {
    // Only collect samples during the detection phase
    if (dpiDetectionSamples.length < DPI_DETECTION_SAMPLES) {
        // Filter out very small movements (likely noise) and very large movements (likely intentional)
        if (Math.abs(movementX) > 2 && Math.abs(movementX) < 100) {
            dpiDetectionSamples.push(Math.abs(movementX));
            console.log(`DPI sample ${dpiDetectionSamples.length}/${DPI_DETECTION_SAMPLES}: movementX=${movementX}`);
        }
        
        // If we have enough samples, calculate the adjustment
        if (dpiDetectionSamples.length >= DPI_DETECTION_SAMPLES) {
            const avgMovement = dpiDetectionSamples.reduce((a, b) => a + b, 0) / dpiDetectionSamples.length;
            
            // Calculate DPI adjustment factor
            // Higher average movement = higher DPI = need more adjustment
            if (avgMovement > 20) {
                // High DPI mouse (gaming mouse)
                dpiAdjustmentFactor = 0.3 + (20 / avgMovement);
                mouseDPI = Math.round(avgMovement * 40); // Rough DPI estimation
                console.log(`High DPI detected: ~${mouseDPI} DPI, adjustment factor: ${dpiAdjustmentFactor.toFixed(3)}`);
            } else if (avgMovement > 10) {
                // Medium DPI mouse
                dpiAdjustmentFactor = 0.5 + (10 / avgMovement);
                mouseDPI = Math.round(avgMovement * 40);
                console.log(`Medium DPI detected: ~${mouseDPI} DPI, adjustment factor: ${dpiAdjustmentFactor.toFixed(3)}`);
            } else {
                // Low DPI mouse (office mouse)
                dpiAdjustmentFactor = 1.0;
                mouseDPI = Math.round(avgMovement * 40);
                console.log(`Low DPI detected: ~${mouseDPI} DPI, adjustment factor: ${dpiAdjustmentFactor.toFixed(3)}`);
            }
            
            // Save DPI settings to localStorage
            localStorage.setItem('mouseDPI', mouseDPI.toString());
            localStorage.setItem('dpiAdjustmentFactor', dpiAdjustmentFactor.toString());
            
            // Show DPI info in HUD
            if (dpiInfo) {
                dpiInfo.textContent = `Mouse: ~${mouseDPI} DPI (${dpiAdjustmentFactor.toFixed(2)}x)`;
                dpiInfo.style.display = 'block';
            }
        }
    }
    
    return dpiAdjustmentFactor;
}

function loadDPISettings() {
    const savedDPI = localStorage.getItem('mouseDPI');
    const savedAdjustment = localStorage.getItem('dpiAdjustmentFactor');
    
    if (savedDPI && savedAdjustment) {
        mouseDPI = parseInt(savedDPI);
        dpiAdjustmentFactor = parseFloat(savedAdjustment);
        console.log(`Loaded saved DPI settings: ${mouseDPI} DPI, adjustment: ${dpiAdjustmentFactor.toFixed(3)}`);
        
        if (dpiInfo) {
            dpiInfo.textContent = `Mouse: ~${mouseDPI} DPI (${dpiAdjustmentFactor.toFixed(2)}x)`;
            dpiInfo.style.display = 'block';
        }
        
        return true;
    }
    
    return false;
}

// --- MULTI-FLOOR SYSTEM ---
let currentFloor = 0;
let floors = []; // Array of floor maps
let floorConnections = []; // Staircase connections between floors
let maxFloors = 3; // Maximum number of floors per stage

// --- ASSETS ---
let assets = {
    wallTexture: null,
    doorTexture: null,
    closetTexture: null,
    enemySprite: null,
    bronzeKeySprite: null,
    goldKeySprite: null,
    containerClosed: null,
    containerOpen: null,
    containerCrate: null,
    containerCabinet: null,
    containerDrawer: null,
    bronzeDoorTexture: null,
    flashlightSprite: null,
    vitaminsSprite: null,
    lockpickSprite: null,
    stairsUpTexture: null,
    stairsDownTexture: null,
    torchTexture: null,
    bonesTexture: null,
    cobwebTexture: null,
    bloodStainTexture: null,
    altarTexture: null,
    cageTexture: null,
    smokeBombSprite: null,
    noiseMakerSprite: null,
    trapSprite: null,
    movingWallSprite: null,
    mansionWallTexture: null,
    // New item sprites
    adrenalineShotSprite: null,
    stealthCloakSprite: null,
    nightVisionGogglesSprite: null,
    motionDetectorSprite: null,
    emergencyFlareSprite: null,
    tranquilizerDartSprite: null
};

function generateAssets() {
    const TILE_SIZE = 64;
    const genCanvas = document.createElement('canvas');
    genCanvas.width = TILE_SIZE; genCanvas.height = TILE_SIZE;
    const gCtx = genCanvas.getContext('2d');

    // Enhanced Wall Texture - More detailed and atmospheric
    gCtx.fillStyle = '#2d2d2d'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    
    // Add realistic stone texture with multiple layers
    for (let x = 0; x < TILE_SIZE; x += 1) {
        for (let y = 0; y < TILE_SIZE; y += 1) {
            const noise1 = Math.random() * 0.15;
            const noise2 = Math.random() * 0.08;
            const noise3 = Math.random() * 0.05;
            gCtx.fillStyle = `rgba(45, 45, 45, ${noise1})`;
            gCtx.fillRect(x, y, 1, 1);
            gCtx.fillStyle = `rgba(60, 60, 60, ${noise2})`;
            gCtx.fillRect(x, y, 1, 1);
            gCtx.fillStyle = `rgba(35, 35, 35, ${noise3})`;
            gCtx.fillRect(x, y, 1, 1);
        }
    }
    
    // Enhanced brick pattern with mortar lines
    gCtx.strokeStyle = '#1a1a1a'; gCtx.lineWidth = 1.5;
    for (let i = 0; i < TILE_SIZE; i += 12) {
        gCtx.beginPath(); gCtx.moveTo(0, i); gCtx.lineTo(TILE_SIZE, i); gCtx.stroke();
    }
    for (let j = 0; j < TILE_SIZE; j += 24) {
        let offset = (Math.floor(j / 12) % 2 === 0) ? 0 : 12;
        gCtx.beginPath(); gCtx.moveTo(j + offset, 0); gCtx.lineTo(j + offset, TILE_SIZE); gCtx.stroke();
    }
    
    // Add realistic mortar texture
    gCtx.fillStyle = '#1a1a1a';
    for (let i = 0; i < TILE_SIZE; i += 12) {
        gCtx.fillRect(0, i, TILE_SIZE, 1);
    }
    for (let j = 0; j < TILE_SIZE; j += 24) {
        let offset = (Math.floor(j / 12) % 2 === 0) ? 0 : 12;
        gCtx.fillRect(j + offset, 0, 1, TILE_SIZE);
    }
    
    // Add subtle highlights and shadows for depth
    gCtx.strokeStyle = '#4a4a4a'; gCtx.lineWidth = 0.5;
    for (let i = 0; i < TILE_SIZE; i += 12) {
        gCtx.beginPath(); gCtx.moveTo(0, i + 1); gCtx.lineTo(TILE_SIZE, i + 1); gCtx.stroke();
    }
    
    // Add weathering effects
    gCtx.fillStyle = 'rgba(100, 100, 100, 0.1)';
    for (let i = 0; i < 8; i++) {
        const x = Math.random() * TILE_SIZE;
        const y = Math.random() * TILE_SIZE;
        const size = Math.random() * 3 + 1;
        gCtx.fillRect(x, y, size, size);
    }
    
    assets.wallTexture = new Image(); assets.wallTexture.src = genCanvas.toDataURL();

    // Enhanced Mansion Wall Texture (for stages 5+) - Rich wood paneling
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#6B4E3D'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    
    // Add rich wood grain texture with multiple layers
    for (let x = 0; x < TILE_SIZE; x += 1) {
        for (let y = 0; y < TILE_SIZE; y += 1) {
            const grain1 = Math.sin(x * 0.2) * Math.cos(y * 0.08) * 0.08;
            const grain2 = Math.sin(x * 0.5) * Math.cos(y * 0.15) * 0.04;
            const grain3 = Math.sin(x * 0.8) * Math.cos(y * 0.25) * 0.02;
            gCtx.fillStyle = `rgba(107, 78, 61, ${0.15 + grain1})`;
            gCtx.fillRect(x, y, 1, 1);
            gCtx.fillStyle = `rgba(139, 115, 85, ${0.1 + grain2})`;
            gCtx.fillRect(x, y, 1, 1);
            gCtx.fillStyle = `rgba(160, 82, 45, ${0.05 + grain3})`;
            gCtx.fillRect(x, y, 1, 1);
        }
    }
    
    // Elegant paneling with beveled edges
    gCtx.strokeStyle = '#4A2C17'; gCtx.lineWidth = 2;
    for (let i = 0; i < TILE_SIZE; i += 16) {
        gCtx.beginPath(); gCtx.moveTo(0, i); gCtx.lineTo(TILE_SIZE, i); gCtx.stroke();
    }
    for (let j = 0; j < TILE_SIZE; j += 16) {
        gCtx.beginPath(); gCtx.moveTo(j, 0); gCtx.lineTo(j, TILE_SIZE); gCtx.stroke();
    }
    
    // Add beveled panel effect
    gCtx.strokeStyle = '#8B4513'; gCtx.lineWidth = 1;
    for (let i = 0; i < TILE_SIZE; i += 16) {
        gCtx.beginPath(); gCtx.moveTo(0, i + 1); gCtx.lineTo(TILE_SIZE, i + 1); gCtx.stroke();
    }
    for (let j = 0; j < TILE_SIZE; j += 16) {
        gCtx.beginPath(); gCtx.moveTo(j + 1, 0); gCtx.lineTo(j + 1, TILE_SIZE); gCtx.stroke();
    }
    
    // Add shadow lines for depth
    gCtx.strokeStyle = '#2F1B14'; gCtx.lineWidth = 0.5;
    for (let i = 0; i < TILE_SIZE; i += 16) {
        gCtx.beginPath(); gCtx.moveTo(0, i + 2); gCtx.lineTo(TILE_SIZE, i + 2); gCtx.stroke();
    }
    for (let j = 0; j < TILE_SIZE; j += 16) {
        gCtx.beginPath(); gCtx.moveTo(j + 2, 0); gCtx.lineTo(j + 2, TILE_SIZE); gCtx.stroke();
    }
    
    // Add ornate decorative corners
    gCtx.fillStyle = '#4A2C17';
    gCtx.fillRect(0, 0, 8, 8);
    gCtx.fillRect(TILE_SIZE-8, 0, 8, 8);
    gCtx.fillRect(0, TILE_SIZE-8, 8, 8);
    gCtx.fillRect(TILE_SIZE-8, TILE_SIZE-8, 8, 8);
    
    // Add center decorative rosette
    gCtx.fillStyle = '#8B4513';
    gCtx.beginPath();
    gCtx.arc(TILE_SIZE/2, TILE_SIZE/2, 6, 0, Math.PI * 2);
    gCtx.fill();
    gCtx.fillStyle = '#A0522D';
    gCtx.beginPath();
    gCtx.arc(TILE_SIZE/2, TILE_SIZE/2, 4, 0, Math.PI * 2);
    gCtx.fill();
    
    // Add subtle aging and wear
    gCtx.fillStyle = 'rgba(139, 69, 19, 0.1)';
    for (let i = 0; i < 6; i++) {
        const x = Math.random() * TILE_SIZE;
        const y = Math.random() * TILE_SIZE;
        const size = Math.random() * 2 + 1;
        gCtx.fillRect(x, y, size, size);
    }
    
    assets.mansionWallTexture = new Image(); assets.mansionWallTexture.src = genCanvas.toDataURL();

    // Bronze Key Sprite - Redesigned to look like a proper key, not a spoon
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#b87333'; 
    // Key head (ring)
    gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.25, TILE_SIZE*0.12, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#000'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.25, TILE_SIZE*0.08, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#b87333';
    // Key shaft
    gCtx.fillRect(TILE_SIZE*0.48, TILE_SIZE*0.35, TILE_SIZE*0.04, TILE_SIZE*0.4);
    // Key teeth (notches)
    gCtx.fillRect(TILE_SIZE*0.52, TILE_SIZE*0.45, TILE_SIZE*0.06, TILE_SIZE*0.03);
    gCtx.fillRect(TILE_SIZE*0.52, TILE_SIZE*0.55, TILE_SIZE*0.06, TILE_SIZE*0.03);
    assets.bronzeKeySprite = new Image(); assets.bronzeKeySprite.src = genCanvas.toDataURL();

    // Gold Key Sprite - Redesigned to look like a proper key, not a spoon
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#FFD700'; 
    // Key head (ring)
    gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.25, TILE_SIZE*0.12, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#000'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.25, TILE_SIZE*0.08, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#FFD700';
    // Key shaft
    gCtx.fillRect(TILE_SIZE*0.48, TILE_SIZE*0.35, TILE_SIZE*0.04, TILE_SIZE*0.4);
    // Key teeth (notches)
    gCtx.fillRect(TILE_SIZE*0.52, TILE_SIZE*0.45, TILE_SIZE*0.06, TILE_SIZE*0.03);
    gCtx.fillRect(TILE_SIZE*0.52, TILE_SIZE*0.55, TILE_SIZE*0.06, TILE_SIZE*0.03);
    gCtx.fillRect(TILE_SIZE*0.52, TILE_SIZE*0.65, TILE_SIZE*0.06, TILE_SIZE*0.03);
    assets.goldKeySprite = new Image(); assets.goldKeySprite.src = genCanvas.toDataURL();
    
    // Door Texture (with symbol)
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#654321'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.fillStyle = '#4a2e1a'; for(let i = 0; i < 4; i++) { gCtx.fillRect(0, i * 16 + 4, TILE_SIZE, 8); }
    gCtx.fillStyle = '#333'; gCtx.fillRect(TILE_SIZE*0.75, TILE_SIZE*0.45, TILE_SIZE*0.1, TILE_SIZE*0.1);
    // Gold symbol
    gCtx.strokeStyle = '#FFD700'; gCtx.lineWidth = 3;
    gCtx.beginPath();
    gCtx.arc(TILE_SIZE*0.25, TILE_SIZE*0.5, TILE_SIZE*0.12, 0, Math.PI*2);
    gCtx.moveTo(TILE_SIZE*0.25, TILE_SIZE*0.38);
    gCtx.lineTo(TILE_SIZE*0.25, TILE_SIZE*0.62);
    gCtx.stroke();
    assets.doorTexture = new Image(); assets.doorTexture.src = genCanvas.toDataURL();

    // Bronze Door Texture
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#5a3b1f'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.fillStyle = '#3d2816'; for(let i = 0; i < 4; i++) { gCtx.fillRect(0, i * 16 + 5, TILE_SIZE, 7); }
    gCtx.fillStyle = '#333'; gCtx.fillRect(TILE_SIZE*0.75, TILE_SIZE*0.45, TILE_SIZE*0.1, TILE_SIZE*0.1);
    gCtx.strokeStyle = '#b87333'; gCtx.lineWidth = 2;
    gCtx.beginPath(); gCtx.moveTo(TILE_SIZE*0.18, TILE_SIZE*0.35); gCtx.lineTo(TILE_SIZE*0.32, TILE_SIZE*0.65); gCtx.stroke();
    assets.bronzeDoorTexture = new Image(); assets.bronzeDoorTexture.src = genCanvas.toDataURL();
    
    // Closet Texture
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#3a2d1d'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.strokeStyle = '#2c2216'; gCtx.lineWidth = 4;
    gCtx.beginPath(); gCtx.moveTo(TILE_SIZE/2, 0); gCtx.lineTo(TILE_SIZE/2, TILE_SIZE); gCtx.stroke();
    gCtx.fillStyle = '#111'; gCtx.fillRect(TILE_SIZE/2 - 8, TILE_SIZE * 0.1, 4, TILE_SIZE * 0.8);
    assets.closetTexture = new Image(); assets.closetTexture.src = genCanvas.toDataURL();
    
    // Enhanced Enemy Sprite - More menacing and detailed
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    
    // Create a more complex shadow/aura effect
    const outerGrd = gCtx.createRadialGradient(TILE_SIZE/2, TILE_SIZE/2, 8, TILE_SIZE/2, TILE_SIZE/2, 35);
    outerGrd.addColorStop(0, 'rgba(40,0,0,0.8)'); 
    outerGrd.addColorStop(0.3, 'rgba(20,0,0,0.6)'); 
    outerGrd.addColorStop(0.7, 'rgba(10,0,0,0.3)'); 
    outerGrd.addColorStop(1, 'rgba(0,0,0,0)');
    gCtx.fillStyle = outerGrd; gCtx.fillRect(0,0,TILE_SIZE,TILE_SIZE);
    
    // Add inner shadow for depth
    const innerGrd = gCtx.createRadialGradient(TILE_SIZE/2, TILE_SIZE/2, 3, TILE_SIZE/2, TILE_SIZE/2, 15);
    innerGrd.addColorStop(0, 'rgba(60,0,0,0.9)'); 
    innerGrd.addColorStop(1, 'rgba(0,0,0,0)');
    gCtx.fillStyle = innerGrd; gCtx.fillRect(0,0,TILE_SIZE,TILE_SIZE);
    
    // Enhanced glowing eyes with multiple layers
    gCtx.fillStyle = '#ff4444'; 
    gCtx.beginPath(); gCtx.arc(TILE_SIZE * 0.4, TILE_SIZE * 0.4, 5, 0, Math.PI * 2); gCtx.fill();
    gCtx.beginPath(); gCtx.arc(TILE_SIZE * 0.6, TILE_SIZE * 0.4, 5, 0, Math.PI * 2); gCtx.fill();
    
    // Add inner eye glow
    gCtx.fillStyle = '#ff8888'; 
    gCtx.beginPath(); gCtx.arc(TILE_SIZE * 0.4, TILE_SIZE * 0.4, 3, 0, Math.PI * 2); gCtx.fill();
    gCtx.beginPath(); gCtx.arc(TILE_SIZE * 0.6, TILE_SIZE * 0.4, 3, 0, Math.PI * 2); gCtx.fill();
    
    // Add pupil
    gCtx.fillStyle = '#000000'; 
    gCtx.beginPath(); gCtx.arc(TILE_SIZE * 0.4, TILE_SIZE * 0.4, 1.5, 0, Math.PI * 2); gCtx.fill();
    gCtx.beginPath(); gCtx.arc(TILE_SIZE * 0.6, TILE_SIZE * 0.4, 1.5, 0, Math.PI * 2); gCtx.fill();
    
    // Add menacing mouth/teeth
    gCtx.fillStyle = '#ff0000';
    gCtx.fillRect(TILE_SIZE * 0.45, TILE_SIZE * 0.6, TILE_SIZE * 0.1, 3);
    gCtx.fillRect(TILE_SIZE * 0.35, TILE_SIZE * 0.65, 2, 2);
    gCtx.fillRect(TILE_SIZE * 0.63, TILE_SIZE * 0.65, 2, 2);
    
    // Add subtle body outline
    gCtx.strokeStyle = '#330000';
    gCtx.lineWidth = 1;
    gCtx.beginPath();
    gCtx.arc(TILE_SIZE/2, TILE_SIZE/2, 12, 0, Math.PI * 2);
    gCtx.stroke();
    
    assets.enemySprite = new Image(); assets.enemySprite.src = genCanvas.toDataURL();

    // Container Closed - Made shorter
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#5b4636'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.fillStyle = '#3d2f24'; gCtx.fillRect(6, 15, TILE_SIZE-12, TILE_SIZE-30); // Reduced height
    gCtx.fillStyle = '#222'; gCtx.fillRect(TILE_SIZE/2 - 6, TILE_SIZE/2 - 2, 12, 4); // Smaller lock
    assets.containerClosed = new Image(); assets.containerClosed.src = genCanvas.toDataURL();

    // Container Open - Made shorter
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#5b4636'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.fillStyle = '#3d2f24'; gCtx.fillRect(6, 15, TILE_SIZE-12, TILE_SIZE-30); // Reduced height
    gCtx.fillStyle = '#3d2f24'; gCtx.fillRect(6, 10, TILE_SIZE-12, 6); // Smaller top
    gCtx.fillStyle = '#222'; gCtx.fillRect(TILE_SIZE/2 - 6, TILE_SIZE/2 - 1, 12, 3); // Smaller lock
    assets.containerOpen = new Image(); assets.containerOpen.src = genCanvas.toDataURL();
    
    // Container Crate - Wooden crate style
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.strokeStyle = '#654321'; gCtx.lineWidth = 1;
    // Draw crate slats
    for (let i = 0; i < TILE_SIZE; i += 8) {
        gCtx.beginPath(); gCtx.moveTo(i, 0); gCtx.lineTo(i, TILE_SIZE); gCtx.stroke();
    }
    for (let i = 0; i < TILE_SIZE; i += 8) {
        gCtx.beginPath(); gCtx.moveTo(0, i); gCtx.lineTo(TILE_SIZE, i); gCtx.stroke();
    }
    assets.containerCrate = new Image(); assets.containerCrate.src = genCanvas.toDataURL();
    
    // Container Cabinet - Tall wooden cabinet
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.strokeStyle = '#654321'; gCtx.lineWidth = 2;
    gCtx.strokeRect(2, 2, TILE_SIZE-4, TILE_SIZE-4);
    // Draw cabinet door lines
    gCtx.beginPath(); gCtx.moveTo(TILE_SIZE/2, 2); gCtx.lineTo(TILE_SIZE/2, TILE_SIZE-2); gCtx.stroke();
    // Draw handle
    gCtx.fillStyle = '#FFD700'; gCtx.fillRect(TILE_SIZE/2 + 4, TILE_SIZE/2 - 2, 3, 4);
    assets.containerCabinet = new Image(); assets.containerCabinet.src = genCanvas.toDataURL();
    
    // Container Drawer - Small drawer unit
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.strokeStyle = '#654321'; gCtx.lineWidth = 1;
    gCtx.strokeRect(2, 2, TILE_SIZE-4, TILE_SIZE-4);
    // Draw drawer lines
    for (let i = 0; i < 3; i++) {
        const y = 4 + (i * (TILE_SIZE-8)/3);
        gCtx.beginPath(); gCtx.moveTo(2, y); gCtx.lineTo(TILE_SIZE-2, y); gCtx.stroke();
    }
    // Draw drawer handles
    for (let i = 0; i < 3; i++) {
        const y = 6 + (i * (TILE_SIZE-8)/3);
        gCtx.fillStyle = '#FFD700'; gCtx.fillRect(TILE_SIZE/2 - 2, y, 4, 2);
    }
    assets.containerDrawer = new Image(); assets.containerDrawer.src = genCanvas.toDataURL();

    // Flashlight Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#333'; gCtx.fillRect(TILE_SIZE*0.35, TILE_SIZE*0.55, TILE_SIZE*0.3, TILE_SIZE*0.15);
    gCtx.fillStyle = '#666'; gCtx.fillRect(TILE_SIZE*0.25, TILE_SIZE*0.5, TILE_SIZE*0.2, TILE_SIZE*0.25);
    gCtx.fillStyle = '#FFD700'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.6, TILE_SIZE*0.12, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#FFF'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.6, TILE_SIZE*0.08, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#FFD700'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.6, TILE_SIZE*0.04, 0, Math.PI*2); gCtx.fill();
    assets.flashlightSprite = new Image(); assets.flashlightSprite.src = genCanvas.toDataURL();

    // Vitamins Sprite (pill bottle)
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#f39c12'; gCtx.fillRect(TILE_SIZE*0.4, TILE_SIZE*0.35, TILE_SIZE*0.2, TILE_SIZE*0.35);
    gCtx.fillStyle = '#fff'; gCtx.fillRect(TILE_SIZE*0.38, TILE_SIZE*0.25, TILE_SIZE*0.24, TILE_SIZE*0.12);
    gCtx.fillStyle = '#c0392b'; gCtx.fillRect(TILE_SIZE*0.42, TILE_SIZE*0.45, TILE_SIZE*0.16, TILE_SIZE*0.05);
    assets.vitaminsSprite = new Image(); assets.vitaminsSprite.src = genCanvas.toDataURL();

    // Lockpick Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.strokeStyle = '#b87333'; gCtx.lineWidth = 3; gCtx.beginPath(); gCtx.moveTo(TILE_SIZE*0.3, TILE_SIZE*0.7); gCtx.lineTo(TILE_SIZE*0.7, TILE_SIZE*0.3); gCtx.stroke();
    gCtx.lineWidth = 2; gCtx.beginPath(); gCtx.moveTo(TILE_SIZE*0.6, TILE_SIZE*0.4); gCtx.lineTo(TILE_SIZE*0.8, TILE_SIZE*0.45); gCtx.stroke();
    assets.lockpickSprite = new Image(); assets.lockpickSprite.src = genCanvas.toDataURL();
    
    // Stairs Up Sprite - More subtle and less obstructive
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.globalAlpha = 0.7; // Make stairs semi-transparent
    gCtx.fillStyle = '#654321'; gCtx.fillRect(TILE_SIZE*0.3, TILE_SIZE*0.7, TILE_SIZE*0.4, TILE_SIZE*0.2);
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(TILE_SIZE*0.35, TILE_SIZE*0.6, TILE_SIZE*0.3, TILE_SIZE*0.08);
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(TILE_SIZE*0.4, TILE_SIZE*0.5, TILE_SIZE*0.2, TILE_SIZE*0.08);
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(TILE_SIZE*0.45, TILE_SIZE*0.4, TILE_SIZE*0.1, TILE_SIZE*0.08);
    gCtx.fillStyle = '#FFD700'; gCtx.fillRect(TILE_SIZE*0.47, TILE_SIZE*0.35, TILE_SIZE*0.06, TILE_SIZE*0.06);
    gCtx.globalAlpha = 1.0; // Reset transparency
    assets.stairsUpTexture = new Image(); assets.stairsUpTexture.src = genCanvas.toDataURL();
    
    // Stairs Down Sprite - More subtle and less obstructive
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.globalAlpha = 0.7; // Make stairs semi-transparent
    gCtx.fillStyle = '#8B7355'; gCtx.fillRect(TILE_SIZE*0.3, TILE_SIZE*0.1, TILE_SIZE*0.4, TILE_SIZE*0.2);
    gCtx.fillStyle = '#A0522D'; gCtx.fillRect(TILE_SIZE*0.35, TILE_SIZE*0.2, TILE_SIZE*0.3, TILE_SIZE*0.08);
    gCtx.fillStyle = '#A0522D'; gCtx.fillRect(TILE_SIZE*0.4, TILE_SIZE*0.3, TILE_SIZE*0.2, TILE_SIZE*0.08);
    gCtx.fillStyle = '#A0522D'; gCtx.fillRect(TILE_SIZE*0.45, TILE_SIZE*0.4, TILE_SIZE*0.1, TILE_SIZE*0.08);
    gCtx.fillStyle = '#FFD700'; gCtx.fillRect(TILE_SIZE*0.47, TILE_SIZE*0.5, TILE_SIZE*0.06, TILE_SIZE*0.06);
    gCtx.globalAlpha = 1.0; // Reset transparency
    assets.stairsDownTexture = new Image(); assets.stairsDownTexture.src = genCanvas.toDataURL();
    
    // Torch Sprite - Fixed with proper glow effect and wall mounting
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    // Wall bracket
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(TILE_SIZE*0.45, TILE_SIZE*0.6, TILE_SIZE*0.1, TILE_SIZE*0.3);
    // Torch handle
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(TILE_SIZE*0.47, TILE_SIZE*0.5, TILE_SIZE*0.06, TILE_SIZE*0.15);
    
    // Glow effect (outer glow)
    const glowGradient = gCtx.createRadialGradient(TILE_SIZE*0.5, TILE_SIZE*0.45, 0, TILE_SIZE*0.5, TILE_SIZE*0.45, TILE_SIZE*0.25);
    glowGradient.addColorStop(0, 'rgba(255, 69, 0, 0.8)');
    glowGradient.addColorStop(0.5, 'rgba(255, 69, 0, 0.4)');
    glowGradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
    gCtx.fillStyle = glowGradient; gCtx.fillRect(TILE_SIZE*0.25, TILE_SIZE*0.2, TILE_SIZE*0.5, TILE_SIZE*0.5);
    
    // Flame base
    gCtx.fillStyle = '#FF4500'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.45, TILE_SIZE*0.12, 0, Math.PI*2); gCtx.fill();
    // Inner flame
    gCtx.fillStyle = '#FFD700'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.45, TILE_SIZE*0.08, 0, Math.PI*2); gCtx.fill();
    // Flame tip
    gCtx.fillStyle = '#FF6347'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.42, TILE_SIZE*0.06, 0, Math.PI*2); gCtx.fill();
    // Small sparkles
    gCtx.fillStyle = '#FFFFFF'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.38, TILE_SIZE*0.03, 0, Math.PI*2); gCtx.fill();
    assets.torchTexture = new Image(); assets.torchTexture.src = genCanvas.toDataURL();
    
    // Bones Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#F5F5DC'; gCtx.fillRect(TILE_SIZE*0.4, TILE_SIZE*0.3, TILE_SIZE*0.2, TILE_SIZE*0.4);
    gCtx.fillStyle = '#F5F5DC'; gCtx.fillRect(TILE_SIZE*0.35, TILE_SIZE*0.45, TILE_SIZE*0.3, TILE_SIZE*0.1);
    gCtx.fillStyle = '#F5F5DC'; gCtx.fillRect(TILE_SIZE*0.3, TILE_SIZE*0.5, TILE_SIZE*0.4, TILE_SIZE*0.1);
    assets.bonesTexture = new Image(); assets.bonesTexture.src = genCanvas.toDataURL();
    
    // Cobweb Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.strokeStyle = '#F5F5DC'; gCtx.lineWidth = 1;
    gCtx.beginPath(); gCtx.moveTo(TILE_SIZE*0.2, TILE_SIZE*0.2); gCtx.lineTo(TILE_SIZE*0.8, TILE_SIZE*0.3);
    gCtx.moveTo(TILE_SIZE*0.3, TILE_SIZE*0.4); gCtx.lineTo(TILE_SIZE*0.7, TILE_SIZE*0.5);
    gCtx.moveTo(TILE_SIZE*0.4, TILE_SIZE*0.6); gCtx.lineTo(TILE_SIZE*0.6, TILE_SIZE*0.7);
    gCtx.stroke();
    assets.cobwebTexture = new Image(); assets.cobwebTexture.src = genCanvas.toDataURL();
    
    // Blood Stain Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#8B0000'; gCtx.beginPath(); gCtx.ellipse(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.25, TILE_SIZE*0.15, 0, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#DC143C'; gCtx.beginPath(); gCtx.ellipse(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.15, TILE_SIZE*0.08, 0, 0, Math.PI*2); gCtx.fill();
    assets.bloodStainTexture = new Image(); assets.bloodStainTexture.src = genCanvas.toDataURL();
    
    // Altar Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#2F4F4F'; gCtx.fillRect(TILE_SIZE*0.2, TILE_SIZE*0.5, TILE_SIZE*0.6, TILE_SIZE*0.4);
    gCtx.fillStyle = '#696969'; gCtx.fillRect(TILE_SIZE*0.15, TILE_SIZE*0.4, TILE_SIZE*0.7, TILE_SIZE*0.1);
    gCtx.fillStyle = '#FFD700'; gCtx.fillRect(TILE_SIZE*0.4, TILE_SIZE*0.35, TILE_SIZE*0.2, TILE_SIZE*0.1);
    gCtx.fillStyle = '#FF0000'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.3, TILE_SIZE*0.08, 0, Math.PI*2); gCtx.fill();
    assets.altarTexture = new Image(); assets.altarTexture.src = genCanvas.toDataURL();
    
    // Cage Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.strokeStyle = '#696969'; gCtx.lineWidth = 2;
    gCtx.strokeRect(TILE_SIZE*0.2, TILE_SIZE*0.2, TILE_SIZE*0.6, TILE_SIZE*0.6);
    gCtx.beginPath(); gCtx.moveTo(TILE_SIZE*0.2, TILE_SIZE*0.35); gCtx.lineTo(TILE_SIZE*0.8, TILE_SIZE*0.35);
    gCtx.moveTo(TILE_SIZE*0.2, TILE_SIZE*0.5); gCtx.lineTo(TILE_SIZE*0.8, TILE_SIZE*0.5);
    gCtx.moveTo(TILE_SIZE*0.35, TILE_SIZE*0.2); gCtx.lineTo(TILE_SIZE*0.35, TILE_SIZE*0.8);
    gCtx.moveTo(TILE_SIZE*0.5, TILE_SIZE*0.2); gCtx.lineTo(TILE_SIZE*0.5, TILE_SIZE*0.8);
    gCtx.stroke();
    assets.cageTexture = new Image(); assets.cageTexture.src = genCanvas.toDataURL();
    
    // Smoke Bomb Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#333'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.15, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#666'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.12, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#999'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.08, 0, Math.PI*2); gCtx.fill();
    assets.smokeBombSprite = new Image(); assets.smokeBombSprite.src = genCanvas.toDataURL();
    
    // Noise Maker Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(TILE_SIZE*0.4, TILE_SIZE*0.4, TILE_SIZE*0.2, TILE_SIZE*0.2);
    gCtx.fillStyle = '#FFD700'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.08, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#FF4500'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.04, 0, Math.PI*2); gCtx.fill();
    assets.noiseMakerSprite = new Image(); assets.noiseMakerSprite.src = genCanvas.toDataURL();
    
    // Trap Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#8B0000'; gCtx.fillRect(TILE_SIZE*0.3, TILE_SIZE*0.3, TILE_SIZE*0.4, TILE_SIZE*0.4);
    gCtx.fillStyle = '#FF0000'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.1, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#000'; gCtx.fillRect(TILE_SIZE*0.45, TILE_SIZE*0.45, TILE_SIZE*0.1, TILE_SIZE*0.1);
    assets.trapSprite = new Image(); assets.trapSprite.src = genCanvas.toDataURL();
    
    // Moving Wall Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#2F4F4F'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.strokeStyle = '#FFD700'; gCtx.lineWidth = 2;
    gCtx.beginPath(); gCtx.moveTo(TILE_SIZE*0.2, TILE_SIZE*0.2); gCtx.lineTo(TILE_SIZE*0.8, TILE_SIZE*0.8);
    gCtx.moveTo(TILE_SIZE*0.8, TILE_SIZE*0.2); gCtx.lineTo(TILE_SIZE*0.2, TILE_SIZE*0.8);
    gCtx.stroke();
    assets.movingWallSprite = new Image(); assets.movingWallSprite.src = genCanvas.toDataURL();
}

// --- GAME & PLAYER STATE ---
let player = {}, enemies = [], map = [], sprites = [];

// Add debugging to track player angle changes
let lastPlayerAngle = 0;
Object.defineProperty(player, 'angle', {
    get: function() { return this._angle || 0; },
    set: function(value) {
        const oldValue = this._angle || 0;
        this._angle = value;
        
        // Log significant angle changes that aren't from mouse movement
        if (Math.abs(value - oldValue) > 0.001 && Math.abs(value - lastPlayerAngle) > 0.001) {
            console.log(`Player angle changed: ${oldValue.toFixed(6)} -> ${value.toFixed(6)} (diff: ${(value - oldValue).toFixed(6)})`);
            console.trace('Angle change stack trace:');
        }
        lastPlayerAngle = value;
    }
});
let closetInteriors = [];
// sprites: {x,y,type,texture,opened?,contains?}
let keys = {}, touchState = {};
let message = { text: "Find the key. Don't get caught. Use SPACE on stairs to change floors.", life: 300 };

// Camera smoothing variables
let cameraSmoothing = {
    gamepad: { targetAngle: 0, currentAngle: 0, smoothing: 0.15 },
    mobile: { targetAngle: 0, currentAngle: 0, smoothing: 0.2 }
};
let lastShiftTime = 0, lastEnemyPathUpdateTime = 0;
let popupLife = 0;
let audioCues = { enabled: true, lastPlayed: 0, cooldown: 2000 };
let settings = { sens: 1, bright: 0, vol: 0.5, scale: 1, audioCues: true };
try { const stored = JSON.parse(localStorage.getItem('mh_settings')||'{}'); Object.assign(settings, stored); } catch(e) {}
audioCues.enabled = settings.audioCues;
let inventory = { 
    flashlight: false, 
    vitamins: 0, 
    lockpick: 0, 
    vitActiveUntil: 0, 
    smokeBomb: 0, 
    noiseMaker: 0,
    // New items
    adrenalineShot: 0,
    stealthCloak: 0,
    nightVisionGoggles: false,
    motionDetector: 0,
    emergencyFlare: 0,
    tranquilizerDart: 0
};
let rushEvent = { active: false, startTime: 0, duration: 8000, cooldown: 30000, lastTrigger: 0 };
let stalkerEnemy = null;

// Monster system - different monsters every 5 stages
function getMonsterTypesForStage(stage) {
    const monsterSets = [
        // Stages 1-5: Basic monsters
        ['hunter', 'ambusher', 'patrol'],
        // Stages 6-10: Add stalker
        ['hunter', 'ambusher', 'patrol', 'stalker'],
        // Stages 11-15: Add shadow
        ['hunter', 'ambusher', 'patrol', 'stalker', 'shadow'],
        // Stages 16-20: Add phantom
        ['hunter', 'ambusher', 'patrol', 'stalker', 'shadow', 'phantom'],
        // Stages 21-25: Add wraith
        ['hunter', 'ambusher', 'patrol', 'stalker', 'shadow', 'phantom', 'wraith'],
        // Stages 26-30: Add nightmare
        ['hunter', 'ambusher', 'patrol', 'stalker', 'shadow', 'phantom', 'wraith', 'nightmare'],
        // Stages 31+: Add ancient horror
        ['hunter', 'ambusher', 'patrol', 'stalker', 'shadow', 'phantom', 'wraith', 'nightmare', 'ancientHorror']
    ];
    
    const setIndex = Math.min(Math.floor(stage / 5), monsterSets.length - 1);
    return monsterSets[setIndex];
}

function getMonsterStats(monsterType, stage) {
    const baseStats = {
        hunter: {
            speed: currentEnemySpeed * 0.9,
            hearingRange: 8,
            memory: 10000,
            stealth: 0.7,
            scale: 1.0
        },
        ambusher: {
            speed: currentEnemySpeed,
            hearingRange: 6,
            memory: 8000,
            stealth: 1.0,
            scale: 0.9
        },
        patrol: {
            speed: currentEnemySpeed,
            hearingRange: 4,
            memory: 5000,
            stealth: 1.0,
            scale: 0.8
        },
        stalker: {
            speed: currentEnemySpeed * 1.1,
            hearingRange: 10,
            memory: 15000,
            stealth: 0.5,
            scale: 1.1
        },
        shadow: {
            speed: currentEnemySpeed * 0.8,
            hearingRange: 12,
            memory: 20000,
            stealth: 0.3,
            scale: 1.2
        },
        phantom: {
            speed: currentEnemySpeed * 1.2,
            hearingRange: 6,
            memory: 12000,
            stealth: 0.6,
            scale: 1.0
        },
        nightmare: {
            speed: currentEnemySpeed * 1.3,
            hearingRange: 15,
            memory: 25000,
            stealth: 0.2,
            scale: 1.3
        },
        wraith: {
            speed: currentEnemySpeed * 0.7,
            hearingRange: 18,
            memory: 30000,
            stealth: 0.1,
            scale: 1.4,
            canPhase: true // Can move through walls
        },
        ancientHorror: {
            speed: currentEnemySpeed * 1.5,
            hearingRange: 20,
            memory: 40000,
            stealth: 0.05,
            scale: 1.6,
            canSummon: true, // Can summon other enemies
            teleport: true // Can teleport short distances
        }
    };
    
    const stats = baseStats[monsterType] || baseStats.patrol;
    
    // Scale stats based on stage
    const stageMultiplier = 1 + (stage * 0.05);
    return {
        speed: stats.speed * stageMultiplier,
        hearingRange: stats.hearingRange * (1 + stage * 0.02),
        memory: stats.memory * stageMultiplier,
        stealth: Math.max(0.1, stats.stealth - stage * 0.01),
        scale: stats.scale
    };
}

// Sanity system
let sanitySystem = {
    currentSanity: 100,
    maxSanity: 100,
    sanityDecayRate: 0.5, // Sanity lost per second
    sanityRecoveryRate: 0.2, // Sanity recovered per second when safe
    lowSanityThreshold: 30,
    criticalSanityThreshold: 15,
    
    // Events that affect sanity
    events: {
        enemyNearby: -2, // Sanity lost per second when enemies are close
        houseShift: -5, // Sanity lost when house shifts
        rushEvent: -8, // Sanity lost during rush events
        stalkerChase: -10, // Sanity lost when stalker is chasing
        hidden: 1, // Sanity recovered when hidden in closet
        vitaminBoost: 2, // Sanity recovered when using vitamins
    },
    
    update: function(deltaTime) {
        let sanityChange = 0;
        
        // Base sanity decay
        sanityChange -= this.sanityDecayRate * deltaTime;
        
        // Check for enemies nearby
        const enemiesNearby = enemies.some(e => {
            if (e.currentFloor !== currentFloor) return false;
            const dist = Math.hypot(e.x - player.x, e.y - player.y);
            return dist < 6;
        });
        
        if (enemiesNearby) {
            sanityChange += this.events.enemyNearby * deltaTime;
        }
        
        // Check for stalker
        if (stalkerEnemy && stalkerEnemy.currentFloor === currentFloor) {
            const stalkerDist = Math.hypot(stalkerEnemy.x - player.x, stalkerEnemy.y - player.y);
            if (stalkerDist < 8) {
                sanityChange += this.events.stalkerChase * deltaTime;
            }
        }
        
        // Rush event effect
        if (rushEvent.active) {
            sanityChange += this.events.rushEvent * deltaTime;
        }
        
        // Hidden state recovery
        if (currentGameState === GAME_STATE.HIDDEN) {
            sanityChange += this.events.hidden * deltaTime;
        }
        
        // Vitamin boost effect
        if (inventory.vitActiveUntil && Date.now() < inventory.vitActiveUntil) {
            sanityChange += this.events.vitaminBoost * deltaTime;
        }
        
        // Apply sanity change
        this.currentSanity = Math.max(0, Math.min(this.maxSanity, this.currentSanity + sanityChange));
        
        // Check for sanity-based effects
        this.checkSanityEffects();
    },
    
    checkSanityEffects: function() {
        if (this.currentSanity <= this.criticalSanityThreshold) {
            // Critical sanity - visual and audio effects
            if (!this.criticalEffectsActive) {
                this.criticalEffectsActive = true;
                this.activateCriticalEffects();
            }
        } else if (this.currentSanity <= this.lowSanityThreshold) {
            // Low sanity - moderate effects
            if (!this.lowEffectsActive) {
                this.lowEffectsActive = true;
                this.activateLowSanityEffects();
            }
        } else {
            // Normal sanity - deactivate effects
            if (this.criticalEffectsActive || this.lowEffectsActive) {
                this.deactivateSanityEffects();
            }
        }
    },
    
    activateCriticalEffects: function() {
        // Add visual distortion
        this.addVisualDistortion();
        // Increase enemy spawn rate
        this.increaseEnemySpawnRate();
        // Add audio hallucinations
        this.addAudioHallucinations();
        // Play sanity loss sound
        playSound('sanityLoss', 0.6);
    },
    
    activateLowSanityEffects: function() {
        // Subtle visual effects
        this.addSubtleVisualEffects();
        // Slight enemy behavior changes
        this.modifyEnemyBehavior();
    },
    
    deactivateSanityEffects: function() {
        this.criticalEffectsActive = false;
        this.lowEffectsActive = false;
        // Remove all effects
        this.removeVisualEffects();
        this.removeAudioEffects();
        this.resetEnemyBehavior();
    },
    
    addVisualDistortion: function() {
        // Add screen shake and distortion effects
        if (!this.distortionCanvas) {
            this.createDistortionCanvas();
        }
    },
    
    addSubtleVisualEffects: function() {
        // Add subtle screen effects for low sanity
        if (!this.subtleEffectsActive) {
            this.subtleEffectsActive = true;
        }
    },
    
    createDistortionCanvas: function() {
        // Create overlay canvas for visual effects
        this.distortionCanvas = document.createElement('canvas');
        this.distortionCanvas.style.position = 'absolute';
        this.distortionCanvas.style.top = '0';
        this.distortionCanvas.style.left = '0';
        this.distortionCanvas.style.pointerEvents = 'none';
        this.distortionCanvas.style.zIndex = '1000';
        document.body.appendChild(this.distortionCanvas);
    },
    
    increaseEnemySpawnRate: function() {
        // Increase chance of enemy spawning
        if (Math.random() < 0.001) { // Very low chance per frame
            let spawnPos = findRandomEmptyCell(map);
            if (spawnPos) {
                let enemyType = 'hallucination';
                enemies.push({ 
                    x: spawnPos.x + 0.5, 
                    y: spawnPos.y + 0.5, 
                    path: [], 
                    state: 'HALLUCINATION',
                    type: enemyType,
                    lastSeenPlayer: null,
                    spawnTime: Date.now(),
                    spawnGracePeriod: 3000,
                    hearingRange: 3,
                    memory: 5000,
                    speed: currentEnemySpeed * 0.7,
                    stealth: 1.0,
                    currentFloor: currentFloor,
                    isHallucination: true,
                    life: 10000 // Hallucinations disappear after 10 seconds
                });
                message.text = "Your mind plays tricks on you..."; message.life = 150;
            }
        }
    },
    
    modifyEnemyBehavior: function() {
        // Slightly increase enemy awareness when sanity is low
        for (let enemy of enemies) {
            if (enemy.currentFloor === currentFloor && !enemy.isHallucination) {
                enemy.hearingRange *= 1.1;
            }
        }
    },
    
    resetEnemyBehavior: function() {
        // Reset enemy behavior to normal
        for (let enemy of enemies) {
            if (enemy.currentFloor === currentFloor && !enemy.isHallucination) {
                enemy.hearingRange = enemy.type === 'hunter' ? 8 : enemy.type === 'ambusher' ? 6 : 4;
            }
        }
    },
    
    removeVisualEffects: function() {
        if (this.distortionCanvas) {
            this.distortionCanvas.remove();
            this.distortionCanvas = null;
        }
        this.subtleEffectsActive = false;
    },
    
    removeAudioEffects: function() {
        // Remove audio hallucinations
        this.audioHallucinations = false;
    },
    
    addAudioHallucinations: function() {
        // Add random audio cues that don't correspond to real events
        if (!this.audioHallucinations && Math.random() < 0.0005) {
            this.audioHallucinations = true;
            // Play random scary sound
            const sounds = ['enemyGrowl', 'houseShift', 'rushEvent'];
            const randomSound = sounds[Math.floor(Math.random() * sounds.length)];
            playSound(randomSound, 0.3);
            message.text = "You hear something... or do you?"; message.life = 120;
        }
    }
};

// New game features
let playerAbilities = { 
    crouching: false, 
    stealthMode: false, 
    lastFootstep: 0,
    surfaceType: 'stone' // stone, wood, carpet
};

let environmentalHazards = [];
let dynamicEvents = { 
    powerOutage: { active: false, startTime: 0, duration: 15000 },
    movingWalls: { active: false, startTime: 0, duration: 20000 },
    lightExtinguishing: { active: false, startTime: 0, duration: 10000 }
};

// Enhanced visual effects system
let visualEffects = {
    particles: [],
    dustMotes: [],
    lightFlicker: { active: false, intensity: 1.0, flickerRate: 0.02 },
    screenShake: { active: false, intensity: 0, duration: 0 },
    bloodDrips: [],
    shadowWaves: []
};

// Particle system for atmospheric effects
function createParticle(x, y, type, life = 60) {
    return {
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 0.02,
        vy: (Math.random() - 0.5) * 0.02,
        life: life,
        maxLife: life,
        type: type,
        size: Math.random() * 2 + 1,
        alpha: 1.0
    };
}

function updateParticles() {
    // Update dust motes
    for (let i = visualEffects.dustMotes.length - 1; i >= 0; i--) {
        let mote = visualEffects.dustMotes[i];
        mote.x += mote.vx;
        mote.y += mote.vy;
        mote.life--;
        mote.alpha = mote.life / mote.maxLife;
        
        if (mote.life <= 0) {
            visualEffects.dustMotes.splice(i, 1);
        }
    }
    
    // Update blood drips
    for (let i = visualEffects.bloodDrips.length - 1; i >= 0; i--) {
        let drip = visualEffects.bloodDrips[i];
        drip.y += 0.01;
        drip.life--;
        drip.alpha = drip.life / drip.maxLife;
        
        if (drip.life <= 0) {
            visualEffects.bloodDrips.splice(i, 1);
        }
    }
    
    // Update shadow waves
    for (let i = visualEffects.shadowWaves.length - 1; i >= 0; i--) {
        let wave = visualEffects.shadowWaves[i];
        wave.radius += 0.5;
        wave.life--;
        wave.alpha = wave.life / wave.maxLife;
        
        if (wave.life <= 0) {
            visualEffects.shadowWaves.splice(i, 1);
        }
    }
    
    // Spawn new dust motes occasionally
    if (Math.random() < 0.1) {
        visualEffects.dustMotes.push(createParticle(
            Math.random() * canvas.width,
            Math.random() * canvas.height,
            'dust',
            120 + Math.random() * 60
        ));
    }
}

function renderParticles() {
    // Render dust motes
    for (let mote of visualEffects.dustMotes) {
        ctx.globalAlpha = mote.alpha * 0.3;
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.arc(mote.x, mote.y, mote.size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Render blood drips
    for (let drip of visualEffects.bloodDrips) {
        ctx.globalAlpha = drip.alpha * 0.8;
        ctx.fillStyle = '#8B0000';
        ctx.fillRect(drip.x, drip.y, 1, 3);
    }
    
    // Render shadow waves
    for (let wave of visualEffects.shadowWaves) {
        ctx.globalAlpha = wave.alpha * 0.4;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
        ctx.stroke();
    }
    
    ctx.globalAlpha = 1.0; // Reset alpha
}

let achievementSystem = {
    unlocked: new Set(),
    total: 0,
    checkAchievements: function() {
        // Check for various achievements
        if (player.hasGoldKey && !this.unlocked.has('keyfinder')) {
            this.unlocked.add('keyfinder');
            this.total++;
            showPopup('🏆 Achievement: Key Finder!');
        }
        if (enemies.length === 0 && !this.unlocked.has('pacifist')) {
            this.unlocked.add('pacifist');
            this.total++;
            showPopup('🏆 Achievement: Pacifist!');
        }
    }
};

// Gamepad support
let gamepad = null;
let gamepadState = {
    leftStick: { x: 0, y: 0 },
    rightStick: { x: 0, y: 0 },
    buttons: new Array(16).fill(false),
    lastButtons: new Array(16).fill(false)
};

// Audio system
let audioContext = null;
let audioEnabled = true;
let sounds = {
    doorOpen: null,
    doorClose: null,
    doorCreak: null,
    footsteps: null,
    heartbeat: null,
    ambient: null,
    closetOpen: null,
    closetClose: null,
    keyPickup: null,
    itemPickup: null,
    enemyGrowl: null,
    houseShift: null,
    rushEvent: null,
    // New enhanced sounds
    footstepsStone: null,
    footstepsWood: null,
    footstepsCarpet: null,
    smokeBomb: null,
    noiseMaker: null,
    trapTrigger: null,
    powerOutage: null,
    movingWall: null,
    lightExtinguish: null,
    enemyHear: null,
    enemyAlert: null
};

let audioNodes = {
    ambient: null,
    heartbeat: null,
    footsteps: null
};

function initAudio() {
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        console.log("Audio context initialized");
        
        // Create audio nodes
        audioNodes.ambient = audioContext.createGain();
        audioNodes.heartbeat = audioContext.createGain();
        audioNodes.footsteps = audioContext.createGain();
        
        // Connect to master output
        audioNodes.ambient.connect(audioContext.destination);
        audioNodes.heartbeat.connect(audioContext.destination);
        audioNodes.footsteps.connect(audioContext.destination);
        
        // Set initial volumes
        audioNodes.ambient.gain.value = 0.1; // Reduced from 0.3
        audioNodes.heartbeat.gain.value = 0.0;
        audioNodes.footsteps.gain.value = 0.0;
        
        // Generate procedural sounds
        generateSounds();
        
    } catch (error) {
        console.warn("Audio not supported:", error);
        audioEnabled = false;
    }
}

function generateSounds() {
    if (!audioEnabled || !audioContext) return;
    
    // Door creak sound
    sounds.doorCreak = generateDoorCreak();
    
    // Door open/close sounds
    sounds.doorOpen = generateDoorSound(0.3, 0.8);
    sounds.doorClose = generateDoorSound(0.1, 0.6);
    
    // Footstep sounds
    sounds.footsteps = generateFootsteps();
    
    // Heartbeat sound
    sounds.heartbeat = generateHeartbeat();
    
    // Ambient house sounds
    sounds.ambient = generateAmbientSounds();
    
    // House shift sound
    sounds.houseShift = generateHouseShift();
    
    // Rush event sound
    sounds.rushEvent = generateRushEvent();
    
    // Item pickup sounds
    sounds.keyPickup = generatePickupSound(800, 0.3);
    sounds.itemPickup = generatePickupSound(600, 0.2);
    
    // Enemy sounds
    sounds.enemyGrowl = generateEnemySound();
    
    // Closet sounds
    sounds.closetOpen = generateClosetSound(0.8);
    sounds.closetClose = generateClosetSound(0.4);
    
    // Enhanced surface-based footsteps
    sounds.footstepsStone = generateFootsteps(120, 0.25);
    sounds.footstepsWood = generateFootsteps(100, 0.2);
    sounds.footstepsCarpet = generateFootsteps(80, 0.15);
    
    // New item sounds
    sounds.smokeBomb = generateSmokeBombSound();
    sounds.noiseMaker = generateNoiseMakerSound();
    sounds.trapTrigger = generateTrapSound();
    
    // Environmental sounds
    sounds.powerOutage = generatePowerOutageSound();
    sounds.movingWall = generateMovingWallSound();
    sounds.lightExtinguish = generateLightExtinguishSound();
    
    // Enemy AI sounds
    sounds.enemyHear = generateEnemyHearSound();
    sounds.enemyAlert = generateEnemyAlertSound();
    
    // New enhanced sounds
    sounds.sanityLoss = generateSanityLossSound();
    sounds.itemPickup = generateItemPickupSound();
    sounds.closetOpen = generateClosetOpenSound();
}

function generateDoorCreak() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 1.5, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const frequency = 200 + Math.sin(t * 2) * 50;
        const amplitude = Math.exp(-t * 2) * 0.3;
        data[i] = Math.sin(t * frequency * Math.PI * 2) * amplitude * (1 + Math.sin(t * 8) * 0.3);
    }
    
    return buffer;
}

function generateDoorSound(attack, decay) {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.5, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const envelope = Math.min(t / attack, 1) * Math.exp(-t / decay);
        const frequency = 150 + Math.sin(t * 20) * 30;
        data[i] = Math.sin(t * frequency * Math.PI * 2) * envelope * 0.4;
    }
    
    return buffer;
}

function generateFootsteps() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.3, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const envelope = Math.exp(-t * 8) * 0.2;
        const frequency = 80 + Math.random() * 40;
        data[i] = Math.sin(t * frequency * Math.PI * 2) * envelope;
    }
    
    return buffer;
}

function generateHeartbeat() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 2, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const beat = Math.sin(t * 2 * Math.PI) > 0 ? 1 : 0;
        const envelope = Math.exp(-(t % 0.5) * 10) * 0.3;
        data[i] = beat * envelope;
    }
    
    return buffer;
}

function generateAmbientSounds() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 3, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const wind = Math.sin(t * 0.5 * Math.PI * 2) * 0.02; // Reduced from 0.05
        const creaks = Math.random() < 0.0001 ? Math.sin(t * 100 * Math.PI * 2) * 0.05 : 0; // Reduced frequency and volume
        const distant = Math.sin(t * 0.1 * Math.PI * 2) * 0.01; // Reduced from 0.03
        data[i] = wind + creaks + distant;
    }
    
    return buffer;
}

function generateHouseShift() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 1, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const rumble = Math.sin(t * 30 * Math.PI * 2) * 0.4;
        const shift = Math.sin(t * 5 * Math.PI * 2) * 0.3;
        const envelope = Math.sin(t * Math.PI) * 0.5;
        data[i] = (rumble + shift) * envelope;
    }
    
    return buffer;
}

function generateRushEvent() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.8, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const alarm = Math.sin(t * 400 * Math.PI * 2) * 0.3;
        const urgency = Math.sin(t * 200 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 3) * 0.6;
        data[i] = (alarm + urgency) * envelope;
    }
    
    return buffer;
}

function generatePickupSound(freq, duration) {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * duration, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const envelope = Math.exp(-t * 8) * 0.3;
        data[i] = Math.sin(t * freq * Math.PI * 2) * envelope;
    }
    
    return buffer;
}

function generateEnemySound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 1, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const growl = Math.sin(t * 120 * Math.PI * 2) * 0.3;
        const rumble = Math.sin(t * 60 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 2) * 0.4;
        data[i] = (growl + rumble) * envelope;
    }
    
    return buffer;
}

function generateClosetSound(volume) {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.4, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const creak = Math.sin(t * 300 * Math.PI * 2) * 0.2;
        const wood = Math.sin(t * 150 * Math.PI * 2) * 0.1;
        const envelope = Math.exp(-t * 4) * volume;
        data[i] = (creak + wood) * envelope;
    }
    
    return buffer;
}

// Enhanced surface-based footsteps
function generateFootsteps(freq, volume) {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.3, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const envelope = Math.exp(-t * 8) * volume;
        const frequency = freq + Math.random() * 20;
        data[i] = Math.sin(t * frequency * Math.PI * 2) * envelope;
    }
    
    return buffer;
}

// New sound effects
function generateSmokeBombSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 1.0, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const whoosh = Math.sin(t * 200 * Math.PI * 2) * 0.3;
        const smoke = Math.sin(t * 50 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 2) * 0.4;
        data[i] = (whoosh + smoke) * envelope;
    }
    
    return buffer;
}

function generateNoiseMakerSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.8, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const alarm = Math.sin(t * 800 * Math.PI * 2) * 0.3;
        const echo = Math.sin(t * 600 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 3) * 0.5;
        data[i] = (alarm + echo) * envelope;
    }
    
    return buffer;
}

function generateTrapSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.5, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const snap = Math.sin(t * 400 * Math.PI * 2) * 0.4;
        const thud = Math.sin(t * 100 * Math.PI * 2) * 0.3;
        const envelope = Math.exp(-t * 6) * 0.6;
        data[i] = (snap + thud) * envelope;
    }
    
    return buffer;
}

function generatePowerOutageSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 1.5, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const buzz = Math.sin(t * 60 * Math.PI * 2) * 0.3;
        const fade = Math.sin(t * 30 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 1.5) * 0.5;
        data[i] = (buzz + fade) * envelope;
    }
    
    return buffer;
}

function generateMovingWallSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 2.0, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const rumble = Math.sin(t * 40 * Math.PI * 2) * 0.4;
        const scrape = Math.sin(t * 200 * Math.PI * 2) * 0.3;
        const envelope = Math.sin(t * Math.PI / 2) * 0.6;
        data[i] = (rumble + scrape) * envelope;
    }
    
    return buffer;
}

function generateLightExtinguishSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.6, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const flicker = Math.sin(t * 300 * Math.PI * 2) * 0.3;
        const extinguish = Math.sin(t * 150 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 4) * 0.5;
        data[i] = (flicker + extinguish) * envelope;
    }
    
    return buffer;
}

function generateEnemyHearSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.4, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const alert = Math.sin(t * 250 * Math.PI * 2) * 0.3;
        const envelope = Math.exp(-t * 5) * 0.4;
        data[i] = alert * envelope;
    }
    
    return buffer;
}

function generateEnemyAlertSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.8, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const growl = Math.sin(t * 180 * Math.PI * 2) * 0.4;
        const roar = Math.sin(t * 90 * Math.PI * 2) * 0.3;
        const rumble = Math.sin(t * 45 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 2.5) * 0.7;
        data[i] = (growl + roar + rumble) * envelope;
    }
    
    return buffer;
}

// New enhanced sound effects
function generateSanityLossSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 1.2, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const whisper = Math.sin(t * 200 * Math.PI * 2) * 0.3;
        const distortion = Math.sin(t * 50 * Math.PI * 2) * 0.2;
        const echo = Math.sin(t * 100 * Math.PI * 2) * 0.1;
        const envelope = Math.exp(-t * 1.5) * 0.5;
        data[i] = (whisper + distortion + echo) * envelope;
    }
    
    return buffer;
}

function generateItemPickupSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.4, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const chime = Math.sin(t * 800 * Math.PI * 2) * 0.3;
        const sparkle = Math.sin(t * 1200 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 8) * 0.6;
        data[i] = (chime + sparkle) * envelope;
    }
    
    return buffer;
}

function generateClosetOpenSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.6, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const creak = Math.sin(t * 150 * Math.PI * 2) * 0.4;
        const wood = Math.sin(t * 300 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 3) * 0.5;
        data[i] = (creak + wood) * envelope;
    }
    
    return buffer;
}

function playSound(soundName, volume = 1.0, loop = false, x = null, y = null) {
    if (!audioEnabled || !audioContext || !sounds[soundName]) return;
    
    try {
        const source = audioContext.createBufferSource();
        const gainNode = audioContext.createGain();
        const pannerNode = audioContext.createPanner();
        
        source.buffer = sounds[soundName];
        source.loop = loop;
        
        // 3D audio positioning if coordinates provided
        if (x !== null && y !== null) {
            pannerNode.panningModel = 'HRTF';
            pannerNode.distanceModel = 'exponential';
            pannerNode.rolloffFactor = 2;
            pannerNode.maxDistance = 20;
            pannerNode.refDistance = 1;
            
            // Calculate relative position to player
            const relX = x - player.x;
            const relY = y - player.y;
            const distance = Math.hypot(relX, relY);
            
            // Calculate angle relative to player's facing direction
            const angle = Math.atan2(relY, relX) - player.angle;
            
            // Set 3D position
            pannerNode.positionX.value = Math.cos(angle) * distance;
            pannerNode.positionY.value = 0;
            pannerNode.positionZ.value = Math.sin(angle) * distance;
            
            // Distance-based volume attenuation
            const distanceVolume = Math.max(0.1, 1 - (distance / 15));
            gainNode.gain.value = volume * (settings.vol || 0.5) * distanceVolume;
            
            source.connect(pannerNode);
            pannerNode.connect(gainNode);
        } else {
            gainNode.gain.value = volume * (settings.vol || 0.5);
            source.connect(gainNode);
        }
        
        gainNode.connect(audioContext.destination);
        source.start();
        
        return { source, gainNode, pannerNode };
    } catch (error) {
        console.warn("Failed to play sound:", soundName, error);
    }
}

function playAmbientLoop() {
    if (!audioEnabled || !audioContext) return;
    
    const source = audioContext.createBufferSource();
    source.buffer = sounds.ambient;
    source.loop = true;
    source.connect(audioNodes.ambient);
    source.start();
    
    audioNodes.ambient.gain.setValueAtTime(0.3, audioContext.currentTime);
    audioNodes.ambient.gain.exponentialRampToValueAtTime(0.3, audioContext.currentTime + 1);
}

function updateAudio() {
    if (!audioEnabled || !audioContext) return;
    
    // Update heartbeat based on player state
    if (currentGameState === GAME_STATE.PLAYING) {
        const enemiesNearby = enemies.some(e => Math.hypot(e.x - player.x, e.y - player.y) < 5);
        const stalkerNearby = stalkerEnemy && Math.hypot(stalkerEnemy.x - player.x, stalkerEnemy.y - player.y) < 8;
        
        if (enemiesNearby || stalkerNearby) {
            audioNodes.heartbeat.gain.setValueAtTime(0.4, audioContext.currentTime);
        } else {
            audioNodes.heartbeat.gain.setValueAtTime(0.0, audioContext.currentTime);
        }
    }
    
    // Update footsteps based on movement and surface type
    const isMoving = keys['w'] || keys['s'] || keys['a'] || keys['d'] || 
                    (gamepad && (gamepadState.leftStick.x !== 0 || gamepadState.leftStick.y !== 0));
    
    if (isMoving && currentGameState === GAME_STATE.PLAYING) {
        // Determine surface type based on player position
        const playerTileX = Math.floor(player.x);
        const playerTileY = Math.floor(player.y);
        let surfaceType = 'stone'; // Default
        
        // Check for different surface types
        if (map[playerTileY] && map[playerTileY][playerTileX] === 0) {
            // Check if near wooden objects (containers, doors)
            const nearWood = sprites.some(s => {
                const dist = Math.hypot(s.x - player.x, s.y - player.y);
                return dist < 2 && (s.type === 'container' || s.type === 'door');
            });
            if (nearWood) surfaceType = 'wood';
        }
        
        // Update surface type and play appropriate footstep sound
        if (playerAbilities.surfaceType !== surfaceType) {
            playerAbilities.surfaceType = surfaceType;
            // Play surface change sound
            const footstepSound = surfaceType === 'wood' ? 'footstepsWood' : 
                                surfaceType === 'carpet' ? 'footstepsCarpet' : 'footstepsStone';
            const footstepVolume = playerAbilities.stealthMode ? 0.15 : 0.3;
            playSound(footstepSound, footstepVolume);
        }
        
        // Reduce footstep volume when crouching/stealth mode
        const footstepVolume = playerAbilities.stealthMode ? 0.1 : 0.2;
        audioNodes.footsteps.gain.setValueAtTime(footstepVolume, audioContext.currentTime);
    } else {
        audioNodes.footsteps.gain.setValueAtTime(0.0, audioContext.currentTime);
    }
}

function hashStringToSeed(str) {
    let h = 2166136261 >>> 0;
    for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
    }
    return h >>> 0;
}

function mulberry32(a) {
    return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
}

function pickAffix() {
    const affixes = ["Fleet Footed", "Calm Predator", "Labyrinthine", "Keen Eye"];
    return affixes[Math.floor(prng() * affixes.length)];
}

function applyAffix() {
    // Reset to defaults first
    currentShiftInterval = SHIFT_INTERVAL;
    currentEnemySpeed = BASE_ENEMY_SPEED + stageIndex * 0.0003; // Balanced scaling
    currentPathUpdateInterval = Math.max(400, ENEMY_PATH_UPDATE_INTERVAL - stageIndex * 100);
    player.moveSpeedMultiplier = 1;
    player.keenEye = false;
    switch(currentAffix) {
        case "Fleet Footed":
            player.moveSpeedMultiplier = 1.03; // Reduced bonus
            break;
        case "Calm Predator":
            currentEnemySpeed *= 0.9;
            break;
        case "Labyrinthine":
            currentShiftInterval = Math.max(60000, SHIFT_INTERVAL - 15000); // Only reduce by 15s max
            break;
        case "Keen Eye":
            player.keenEye = true;
            break;
        default:
            break;
    }
    if (hudAffixEl) hudAffixEl.textContent = currentAffix;
}

function enemiesForStage() {
    if (stageIndex >= 3) return 3;
    if (stageIndex >= 2) return 2;
    return 1;
}

function generateMultiFloorMaze() {
    floors = [];
    floorConnections = [];
    
    console.log("Generating multi-floor maze with", maxFloors, "floors");
    
    // Generate multiple floors
    for (let f = 0; f < maxFloors; f++) {
        const floorMap = generateMaze(MAP_SIZE, MAP_SIZE);
        floors.push(floorMap);
        console.log("Generated floor", f, "with size", floorMap.length, "x", floorMap[0].length);
        
        // Add dungeon atmosphere objects
        addDungeonObjects(floorMap, f);
    }
    
    // Create staircase connections between floors
    for (let f = 0; f < maxFloors - 1; f++) {
        // For higher stages, try multiple positions to ensure stairs are placed
        let upPos = null, downPos = null;
        let attempts = 0;
        const maxAttempts = stageIndex >= 1 ? 20 : 10; // More attempts for higher stages
        
        while (!upPos && attempts < maxAttempts) {
            upPos = findRandomEmptyCell(floors[f]);
            attempts++;
        }
        
        attempts = 0;
        while (!downPos && attempts < maxAttempts) {
            downPos = findRandomEmptyCell(floors[f + 1]);
            attempts++;
        }
        
        console.log("Floor", f, "upPos:", upPos, "Floor", f+1, "downPos:", downPos, "after", attempts, "attempts");
        
        if (upPos && downPos) {
            floors[f][upPos.y][upPos.x] = 5; // Stairs up
            floors[f + 1][downPos.y][downPos.x] = 6; // Stairs down
            
            floorConnections.push({
                floor: f,
                upX: upPos.x,
                upY: upPos.y,
                downX: downPos.x,
                downY: downPos.y
            });
            
            console.log("Connected floors", f, "and", f+1, "with stairs at", upPos.x, upPos.y, "and", downPos.x, downPos.y);
        } else {
            console.error("Failed to place stairs between floors", f, "and", f+1, "after", maxAttempts, "attempts");
        }
    }
    
    console.log("Final floor connections:", floorConnections);
    console.log("floors array length:", floors.length);
    
    // Validate stair connections for higher stages
    if (stageIndex >= 1) {
        console.log(`Stage ${stageIndex + 1}: Validating stair connections...`);
        for (let conn of floorConnections) {
            // Check if stairs are accessible (not blocked by walls)
            const upAccessible = isPositionAccessible(conn.upX, conn.upY);
            const downAccessible = isPositionAccessible(conn.downX, conn.downY);
            console.log(`Floor ${conn.floor} stairs: up(${conn.upX},${conn.upY}) accessible: ${upAccessible}, down(${conn.downX},${conn.downY}) accessible: ${downAccessible}`);
            
            if (!upAccessible || !downAccessible) {
                console.warn(`Stairs at floor ${conn.floor} may be blocked!`);
            }
        }
    }
    
    // Smart exit placement: ensure exit is always reachable
    let exitPlaced = false;
    
    // Strategy 1: If we have working stairs, place exit on top floor
    if (floorConnections.length > 0) {
        const topFloor = floors[maxFloors - 1];
        let exitPos = findRandomEmptyCell(topFloor);
        if (exitPos) {
            topFloor[exitPos.y][exitPos.x] = 3; // Gold exit door
            console.log("Placed exit on top floor (stairs available) at", exitPos.x, exitPos.y);
            exitPlaced = true;
        }
    }
    
    // Strategy 2: If no stairs or stairs failed, place exit on current floor
    if (!exitPlaced) {
        console.log("No working stairs found, placing exit on current floor");
        // We'll place the exit in resetGame() after the current floor is set
        exitPlaced = true;
    }
    
    if (!exitPlaced) {
        console.error("Failed to place exit anywhere");
    }
}

function addDungeonObjects(floorMap, floorIndex) {
    // Add torches for lighting (more elegant placement for mansion stages)
    const torchCount = stageIndex >= 4 ? 4 + Math.floor(prng() * 3) : 3 + Math.floor(prng() * 3);
    for (let i = 0; i < torchCount; i++) {
        let pos = findRandomEmptyCell(floorMap);
        if (pos) {
            floorMap[pos.y][pos.x] = 7; // Torch
        }
    }
    
    // Add bones and blood stains (less gore for mansion stages)
    if (stageIndex < 4) {
    for (let i = 0; i < 2 + Math.floor(prng() * 2); i++) {
        let pos = findRandomEmptyCell(floorMap);
        if (pos) {
            floorMap[pos.y][pos.x] = 8; // Bones
        }
    }
    
    for (let i = 0; i < 1 + Math.floor(prng() * 2); i++) {
        let pos = findRandomEmptyCell(floorMap);
        if (pos) {
            floorMap[pos.y][pos.x] = 9; // Blood stain
            }
        }
    }
    
    // Add cobwebs in corners (more elegant for mansion stages)
    const cobwebCount = stageIndex >= 4 ? 1 + Math.floor(prng() * 2) : 2 + Math.floor(prng() * 2);
    for (let i = 0; i < cobwebCount; i++) {
        let pos = findRandomEmptyCell(floorMap);
        if (pos) {
            floorMap[pos.y][pos.x] = 10; // Cobweb
        }
    }
    
    // Add altar on higher floors
    if (floorIndex > 0 && prng() < 0.7) {
        let pos = findRandomEmptyCell(floorMap);
        if (pos) {
            floorMap[pos.y][pos.x] = 11; // Altar
        }
    }
    
    // Add cage on highest floor
    if (floorIndex === maxFloors - 1 && prng() < 0.6) {
        let pos = findRandomEmptyCell(floorMap);
        if (pos) {
            floorMap[pos.y][pos.x] = 12; // Cage
        }
    }
}

function resetGame() {
    // Stage-specific adjustments for multi-floor system
    if (stageIndex >= 1) {
        // Stages 2+ should have more floors and more complex stair systems
        maxFloors = Math.min(4, 3 + stageIndex); // Increase floors for higher stages
        console.log(`Stage ${stageIndex + 1}: Setting maxFloors to ${maxFloors}`);
    } else {
        maxFloors = 3; // Default for stage 1
    }
    
    generateMultiFloorMaze();
    console.log("After generateMultiFloorMaze:");
    console.log("floors array length:", floors.length);
    console.log("floorConnections:", floorConnections);
    console.log("Current floor:", currentFloor);
    console.log("Stage:", stageIndex + 1, "Max floors:", maxFloors);
    
    // Debug: check map generation
    if (floors && floors.length > 0) {
        const currentMap = floors[0];
        let emptyCells = 0;
        for (let y = 0; y < currentMap.length; y++) {
            for (let x = 0; x < currentMap[0].length; x++) {
                if (currentMap[y][x] === 0) emptyCells++;
            }
        }
        console.log(`Map size: ${currentMap.length}x${currentMap[0].length}, Empty cells: ${emptyCells}`);
    }
    
    currentFloor = 0;
    map = floors[currentFloor];
    console.log("Set currentFloor to 0, map size:", map.length, "x", map[0].length);
    
    sprites = [];
    
    let spawn = findSafeSpawnCell();
    player = { x: spawn.x + 0.5, y: spawn.y + 0.5, angle: prng() * Math.PI * 2, sanity: 100, hasBronzeKey: false, hasGoldKey: false, stamina: 1, moveSpeedMultiplier: 1, keenEye: false, graceMs: 2000, closetEntryTime: null, closetExitTime: null, closetGracePeriod: 3000, lastMovement: 0 };
    
    // Reset player abilities
    playerAbilities.crouching = false;
    playerAbilities.stealthMode = false;
    
    // Reset sanity system
    sanitySystem.currentSanity = sanitySystem.maxSanity;
    sanitySystem.deactivateSanityEffects();
    
    // Reset closet-related timers
    player.closetExitTime = null;
    player.closetGracePeriod = 3000; // 3 seconds of grace period
    
    // Reset shift interval to base value
    currentShiftInterval = SHIFT_INTERVAL;

    // Scatter bronze keys and items in corridors
    for (let i = 0; i < 2 + Math.floor(prng()*2); i++) {
        let keyPos = findRandomEmptyCell(map);
        if (keyPos) {
            sprites.push({ x: keyPos.x + 0.5, y: keyPos.y + 0.5, type: 'bronzeKey', texture: assets.bronzeKeySprite });
        }
    }
    if (prng() < 0.6) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'flashlight', texture: assets.flashlightSprite }); }
    if (prng() < 0.6) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'vitamins', texture: assets.vitaminsSprite }); }
    if (prng() < 0.5) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'lockpick', texture: assets.lockpickSprite }); }
    
    // Place additional random items in corridors
    if (prng() < 0.7) { 
        let p = findRandomEmptyCell(map); 
        if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'vitamins', texture: assets.vitaminsSprite }); 
    }
    if (prng() < 0.6) { 
        let p = findRandomEmptyCell(map); 
        if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'lockpick', texture: assets.lockpickSprite }); 
    }
    
    // Add new items
    if (prng() < 0.4) { 
        let p = findRandomEmptyCell(map); 
        if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'smokeBomb', texture: assets.smokeBombSprite }); 
    }
    if (prng() < 0.4) { 
        let p = findRandomEmptyCell(map); 
        if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'noiseMaker', texture: assets.noiseMakerSprite }); 
    }
    
    // Smart exit placement: check if we need to place exit on current floor
    let exitExists = false;
    for (let y = 0; y < MAP_SIZE; y++) {
        for (let x = 0; x < MAP_SIZE; x++) {
            if (map[y][x] === 3) { // Gold exit door
                exitExists = true;
                break;
            }
        }
        if (exitExists) break;
    }
    
    // If no exit exists on current floor and no stairs available, place exit here
    if (!exitExists && floorConnections.length === 0) {
        let exitPos = findWellConnectedExitPosition(map);
        if (exitPos) {
            map[exitPos.y][exitPos.x] = 3; // Gold exit door
            console.log("Placed exit on current floor (no stairs) at", exitPos.x, exitPos.y);
        } else {
            console.error("Failed to place exit on current floor");
        }
    }
    
    // Additional safety: if we have stairs but no working connections, ensure exit is reachable
    if (!exitExists && floorConnections.length > 0) {
        // Check if any of the floor connections actually work
        let workingStairs = false;
        for (let conn of floorConnections) {
            if (conn.floor === currentFloor && (conn.upX !== undefined || conn.downX !== undefined)) {
                workingStairs = true;
                break;
            }
        }
        
        if (!workingStairs) {
            console.log("Stairs exist but connections are broken, placing exit on current floor");
            let exitPos = findWellConnectedExitPosition(map);
            if (exitPos) {
                map[exitPos.y][exitPos.x] = 3; // Gold exit door
                console.log("Placed fallback exit on current floor at", exitPos.x, exitPos.y);
            }
        }
    }
    // Place some bronze doors
    for (let i = 0; i < 3; i++) {
        let d = findRandomEmptyCell(map);
        if (d && map[d.y][d.x] === 0) map[d.y][d.x] = 2; // 2 for BRONZE door
    }
    
    // Place closets on wall tiles - simplified for reliability
    closetInteriors = [];
    let closetsPlaced = 0;
    let attempts = 0;
    
    while (closetsPlaced < 10 && attempts++ < 600) {
        let c = findRandomWallAdjacentToFloor();
        if (!c) break;
        
        // Don't place closets too close to doors or stairs
        const nearImportant = [[1,0],[-1,0],[0,1],[0,-1]].some(([dx,dy]) => {
            const nx = c.x + dx;
            const ny = c.y + dy;
            return map[ny] && (map[ny][nx] === 2 || map[ny][nx] === 3 || map[ny][nx] === 5 || map[ny][nx] === 6);
        });
        if (nearImportant) continue;
        
        // Determine facing direction: from wall to corridor
        const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
        let face = null;
        for (let [dx,dy] of neighbors) { 
            if (map[c.y+dy] && map[c.y+dy][c.x+dx] === 0) { 
                face = [dx,dy]; 
                break; 
            } 
        }
        if (!face) continue;
        
        // Create closet interior
        const interiorX = c.x - face[0];
        const interiorY = c.y - face[1];
        
        if (interiorY >= 0 && interiorY < MAP_SIZE && interiorX >= 0 && interiorX < MAP_SIZE) {
            // Only place if interior space is a wall (can be carved)
            if (map[interiorY][interiorX] === 1) {
                map[c.y][c.x] = 4; // closet on wall
                map[interiorY][interiorX] = 0; // carve interior as floor
                closetInteriors.push({ 
                    x: interiorX, 
                    y: interiorY, 
                    facingX: c.x, 
                    facingY: c.y,
                    direction: face 
                });
                closetsPlaced++;
            }
        }
    }
    
    console.log(`Placed ${closetsPlaced} closets`);

    // Place containers snapped to walls along corridors (smaller footprint)
    for (let i = 0; i < 14; i++) {
        let c = findRandomEmptyCell(map);
        if (!c) continue;
        if (map[c.y][c.x] !== 0) continue;
        // Snap toward nearest wall direction
        const dirs = [ [1,0], [-1,0], [0,1], [0,-1] ];
        let chosen = null;
        for (let [dx,dy] of dirs) {
            const wx = c.x + dx;
            const wy = c.y + dy;
            if (wx>=0 && wx<MAP_SIZE && wy>=0 && wy<MAP_SIZE && map[wy][wx] === 1) { chosen = [dx,dy]; break; }
        }
        let cx = c.x + 0.5;
        let cy = c.y + 0.5;
        if (chosen) {
            // Offset more toward wall to avoid center of corridor
            cx = c.x + 0.5 + chosen[0]*0.35;
            cy = c.y + 0.5 + chosen[1]*0.35;
        }
        
        // Choose random container type for variety
        const containerTypes = [
            { texture: assets.containerClosed, name: 'chest' },
            { texture: assets.containerCrate, name: 'crate' },
            { texture: assets.containerCabinet, name: 'cabinet' },
            { texture: assets.containerDrawer, name: 'drawer' }
        ];
        const containerType = containerTypes[Math.floor(prng() * containerTypes.length)];
        
        sprites.push({ 
            x: cx, 
            y: cy, 
            type: 'container', 
            containerType: containerType.name,
            opened: false, 
            contains: null, 
            texture: containerType.texture, 
            snap: chosen 
        });
    }
    console.log("Placed", sprites.filter(s => s.type === 'container').length, "containers total");

    // Place varied loot in containers with stage-specific adjustments
    const containers = sprites.filter(s => s.type === 'container');
    if (containers.length > 0) {
        // Stage-specific gold key placement - higher chances in early stages
        let goldKeyChance = 0.8; // 80% chance for stage 1
        if (stageIndex === 1) goldKeyChance = 0.9; // 90% chance for stage 2
        else if (stageIndex === 2) goldKeyChance = 0.85; // 85% chance for stage 3
        else if (stageIndex >= 3) goldKeyChance = 0.7; // 70% chance for later stages
        
        if (prng() < goldKeyChance) {
            // Place gold key in a random container
            const goldKeyIdx = Math.floor(prng() * containers.length);
            containers[goldKeyIdx].contains = { type: 'goldKey' };
            console.log(`Placed gold key in container ${goldKeyIdx} for stage ${stageIndex + 1}`);
        }
        
        // Place other items with stage-specific chances
        const itemTypes = ['flashlight', 'vitamins', 'lockpick', 'bronzeKey', 'smokeBomb', 'noiseMaker'];
        const stageMultipliers = [1.0, 1.2, 1.1, 0.9, 0.8]; // Stage 1-5 multipliers
        
        for (let itemType of itemTypes) {
            let baseChance = 0.6; // Base 60% chance
            
            // Adjust chances based on stage
            if (stageIndex < stageMultipliers.length) {
                baseChance *= stageMultipliers[stageIndex];
            }
            
            // Special adjustments for early stages
            if (stageIndex <= 2) {
                if (itemType === 'bronzeKey') baseChance *= 1.3; // More bronze keys in early stages
                if (itemType === 'flashlight') baseChance *= 1.2; // More flashlights in early stages
            }
            
            if (prng() < baseChance) {
                let placed = false;
                for (let attempts = 0; attempts < 15; attempts++) {
                    const idx = Math.floor(prng() * containers.length);
                    if (containers[idx].contains === null) {
                        containers[idx].contains = { type: itemType };
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    // If no empty container, place item in corridor
                    let pos = findRandomEmptyCell(map);
                    if (pos) {
                        let texture = assets.bronzeKeySprite;
                        if (itemType === 'flashlight') texture = assets.flashlightSprite;
                        else if (itemType === 'vitamins') texture = assets.vitaminsSprite;
                        else if (itemType === 'lockpick') texture = assets.lockpickSprite;
                        else if (itemType === 'smokeBomb') texture = assets.smokeBombSprite;
                        else if (itemType === 'noiseMaker') texture = assets.noiseMakerSprite;
                        
                        sprites.push({ x: pos.x + 0.5, y: pos.y + 0.5, type: itemType, texture: texture });
                    }
                }
            }
        }
        
        // Add some containers with interesting "empty" messages instead of just "empty"
        const emptyContainers = containers.filter(c => c.contains === null);
        if (emptyContainers.length > 0) {
            // Stage-specific empty messages for more variety
            const stageMessages = {
                0: [ // Stage 1 - Basement
                    'Old newspapers and dust.',
                    'Broken glass and cobwebs.',
                    'A few rusty nails.',
                    'Empty food wrappers.',
                    'A broken pencil.',
                    'Faded photographs.',
                    'A torn piece of cloth.',
                    'Some loose change.',
                    'A broken watch.',
                    'Empty medicine bottles.'
                ],
                1: [ // Stage 2 - Second floor
                    'Old magazines and dust.',
                    'Broken picture frames.',
                    'Empty jewelry boxes.',
                    'Torn curtains.',
                    'A broken mirror.',
                    'Faded wallpaper samples.',
                    'Empty perfume bottles.',
                    'Broken teacups.',
                    'Old letters.',
                    'Empty photo albums.'
                ],
                2: [ // Stage 3 - Bloody stage
                    'Blood-stained rags.',
                    'Broken medical equipment.',
                    'Empty syringes.',
                    'Torn bandages.',
                    'Broken glass vials.',
                    'Faded medical charts.',
                    'Empty medicine bottles.',
                    'Broken scalpels.',
                    'Old medical books.',
                    'Empty IV bags.'
                ],
                3: [ // Stage 4 - Fourth floor
                    'Broken electronics.',
                    'Empty circuit boards.',
                    'Torn blueprints.',
                    'Broken tools.',
                    'Empty fuel cans.',
                    'Broken machinery parts.',
                    'Old technical manuals.',
                    'Empty chemical bottles.',
                    'Broken gauges.',
                    'Empty oil cans.'
                ],
                4: [ // Stage 5 - Mansion
                    'Elegant but empty.',
                    'Fine china dust.',
                    'Empty wine bottles.',
                    'Broken crystal.',
                    'Faded silk.',
                    'Empty jewelry cases.',
                    'Broken chandelier pieces.',
                    'Empty perfume bottles.',
                    'Torn velvet.',
                    'Empty silverware boxes.'
                ]
            };
            
            const currentStageMessages = stageMessages[stageIndex] || stageMessages[0];
            
            // Apply interesting messages to 40% of empty containers in early stages, 30% in later stages
            const messageChance = stageIndex <= 2 ? 0.4 : 0.3;
            const containersToEnhance = Math.floor(emptyContainers.length * messageChance);
            for (let i = 0; i < containersToEnhance && i < emptyContainers.length; i++) {
                const randomMessage = currentStageMessages[Math.floor(prng() * currentStageMessages.length)];
                emptyContainers[i].emptyMessage = randomMessage;
            }
        }
        
        console.log(`Placed loot in containers for stage ${stageIndex + 1}:`, containers.filter(c => c.contains).map(c => c.contains.type));
        console.log(`Gold key chance was ${(goldKeyChance * 100).toFixed(0)}% for this stage`);
    }
    
    enemies = [];
    // Scatter enemies around the map (ensuring they don't spawn near player)
    const count = enemiesForStage();
    console.log(`Attempting to spawn ${count} enemies for stage ${stageIndex + 1}`);
    
    for (let i = 0; i < count; i++) {
        let enemySpawn = findSafeEnemySpawn(map, spawn);
        if (enemySpawn) {
            // Get available monster types for current stage
            const availableMonsters = getMonsterTypesForStage(stageIndex);
            const enemyType = availableMonsters[Math.floor(prng() * availableMonsters.length)];
            const stats = getMonsterStats(enemyType, stageIndex);
            
            let enemy = { 
                x: enemySpawn.x + 0.5, 
                y: enemySpawn.y + 0.5, 
                path: [], 
                state: 'PATROL',
                type: enemyType,
                lastSeenPlayer: null,
                spawnTime: Date.now(),
                spawnGracePeriod: 5000, // 5 seconds grace period after spawn
                hearingRange: stats.hearingRange,
                memory: stats.memory,
                speed: stats.speed,
                stealth: stats.stealth,
                scale: stats.scale,
                currentFloor: currentFloor, // Track which floor this enemy is on
                patrolTarget: null, // Initialize patrol system
                patrolRadius: 3 + Math.random() * 2 // Random patrol radius between 3-5 tiles
            };
            console.log(`Created ${enemyType} enemy on floor ${currentFloor} at (${enemy.x.toFixed(1)}, ${enemy.y.toFixed(1)})`);
            enemies.push(enemy);
            console.log(`Spawned ${enemyType} enemy at (${enemySpawn.x}, ${enemySpawn.y})`);
        } else {
            console.warn(`Failed to find safe spawn position for enemy ${i + 1}`);
        }
    }
    
    console.log(`Total enemies spawned: ${enemies.length}`);
    
    // Reset special enemies
    stalkerEnemy = null;
    rushEvent.active = false;
    rushEvent.startTime = 0;
    
    // Reset floor system
    currentFloor = 0;
    map = floors[currentFloor];
    
    // Stage-specific difficulty scaling
    if (stageIndex >= 1) {
        // Increase difficulty for stages 2+
        currentShiftInterval = Math.max(60000, SHIFT_INTERVAL - (stageIndex * 2000)); // More consistent shifts
        currentEnemySpeed = BASE_ENEMY_SPEED + (stageIndex * 0.0004); // Balanced enemy scaling
        currentPathUpdateInterval = Math.max(300, ENEMY_PATH_UPDATE_INTERVAL - (stageIndex * 150)); // More frequent path updates
        console.log(`Stage ${stageIndex + 1} difficulty: shift=${currentShiftInterval}ms, speed=${currentEnemySpeed}, pathUpdate=${currentPathUpdateInterval}ms`);
    } else {
        // Reset to defaults for stage 1
        currentShiftInterval = SHIFT_INTERVAL;
        currentEnemySpeed = BASE_ENEMY_SPEED;
        currentPathUpdateInterval = ENEMY_PATH_UPDATE_INTERVAL;
    }
    
    // Reset game state to playing
    currentGameState = GAME_STATE.PLAYING;
    
    // Reset UI indicators
    if (hiddenIndicator) hiddenIndicator.style.display = 'none';
    
    // Ensure HUD is visible
    if (hud) hud.style.display = 'block';

    lastShiftTime = Date.now();
    stageStartTime = Date.now();
    currentAffix = pickAffix();
    applyAffix();
}

function nextStageOrWin() {
    stageIndex += 1;
    if (stageIndex > STAGES.length) {
        // Completed all stages
        currentGameState = GAME_STATE.WON;
        totalElapsedMs += Date.now() - stageStartTime;
        saveRun(true);
        showRunSummary(true);
        return;
    }
    // Continue to next stage
    totalElapsedMs += Date.now() - stageStartTime;
    resetGame();
    showPopup(stageIndex === 0 ? "First stage" : STAGES[stageIndex - 1]);
    
    // Show mansion transition message for stage 5
    if (stageIndex === 4) {
        setTimeout(() => {
            showPopup("The house transforms into an elegant mansion...");
        }, 2000);
    }
}

function showRunSummary(won) {
    const elapsed = totalElapsedMs;
    const minutes = Math.floor(elapsed / 60000);
    const seconds = Math.floor((elapsed % 60000) / 1000);
    const millis = elapsed % 1000;
    
    let summaryContent = won ? 
        `🎉 VICTORY! 🎉\n\n` :
        `DEFEAT\n\n`;
    
    summaryContent += `Time: ${minutes}:${seconds.toString().padStart(2,'0')}.${millis.toString().padStart(3,'0')}\n`;
    summaryContent += `Stages Completed: ${stageIndex}\n`;
    summaryContent += `Floors Explored: ${maxFloors * stageIndex}\n`;
    summaryContent += `Final Affix: ${currentAffix}\n`;
    
    if (won) {
        summaryContent += `\n🏆 You've escaped the monster house! 🏆\n`;
        summaryContent += `But the memory will haunt you forever...`;
    } else {
        summaryContent += `\nYour sanity lingers in the darkness.\n`;
        summaryContent += `The house claims another victim.`;
    }
    
    if (summaryText) summaryText.textContent = summaryContent;
    if (summaryPanel) summaryPanel.style.display = 'block';
    
    // Hide HUD when showing summary
    if (hud) hud.style.display = 'none';
    
    // Ensure game state is set correctly for defeat
    if (!won) {
        currentGameState = GAME_STATE.GAMEOVER;
    }
}

function playProximityAudio() {
    if (!audioCues.enabled || Date.now() - audioCues.lastPlayed < audioCues.cooldown) return;
    
    // Find nearest enemy
    let nearestEnemy = null;
    let nearestDist = Infinity;
    
    for (let enemy of enemies) {
        const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
        if (dist < nearestDist) {
            nearestDist = dist;
            nearestEnemy = enemy;
        }
    }
    
    if (stalkerEnemy) {
        const dist = Math.hypot(player.x - stalkerEnemy.x, player.y - stalkerEnemy.y);
        if (dist < nearestDist) {
            nearestDist = dist;
            nearestEnemy = stalkerEnemy;
        }
    }
    
    // Play audio cues based on proximity
    if (nearestEnemy && nearestDist < 8) {
        if (nearestDist < 2) {
            // Very close - danger sound
            playAudioCue('danger');
        } else if (nearestDist < 4) {
            // Close - warning sound
            playAudioCue('warning');
        } else if (nearestDist < 6) {
            // Medium - ambient sound
            playAudioCue('ambient');
        } else {
            // Far - subtle sound
            playAudioCue('subtle');
        }
        audioCues.lastPlayed = Date.now();
    }
}

function playAudioCue(type) {
    // Create audio context for proximity-based sounds
    if (!window.audioContext) {
        window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    const audioContext = window.audioContext;
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    let frequency, duration, volume;
    
    switch(type) {
        case 'danger':
            frequency = 200; // Low, ominous tone
            duration = 0.3;
            volume = 0.3;
            break;
        case 'warning':
            frequency = 400; // Medium warning tone
            duration = 0.2;
            volume = 0.2;
            break;
        case 'ambient':
            frequency = 600; // Higher ambient tone
            duration = 0.15;
            volume = 0.15;
            break;
        case 'subtle':
            frequency = 800; // High subtle tone
            duration = 0.1;
            volume = 0.1;
            break;
        default:
            return;
    }
    
    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
    gainNode.gain.setValueAtTime(volume * (settings.vol || 0.5), audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
    
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + duration);
}

function renderRunSummary() {
    if (summaryPanel && summaryPanel.style.display === 'block') {
        // Summary panel is already visible, no need to re-render
        return;
    }
    
    // This function is called when the summary panel needs to be rendered
    // The actual content is set in showRunSummary()
}

function renderSettingsMenu() {
    if (settingsPanel && settingsPanel.style.display === 'block') {
        // Settings panel is already visible, no need to re-render
        return;
    }
    
    // This function is called when the settings panel needs to be rendered
    // The actual content is set in the HTML and updated via event listeners
}

function renderPauseMenu() {
    if (pauseMenu && pauseMenu.style.display === 'block') {
        // Pause menu is already visible, no need to re-render
        return;
    }
    
    // This function is called when the pause menu needs to be rendered
    // The actual content is set in the HTML and updated via event listeners
}

function startRun() {
    // Reset game state completely
    currentGameState = GAME_STATE.PLAYING;
    
    stageIndex = 0;
    totalElapsedMs = 0;
    runStartTime = Date.now();
    const seedStr = (seedInput && seedInput.value.trim()) ? seedInput.value.trim() : `${Math.floor(Math.random()*1e9)}`;
    prng = mulberry32(hashStringToSeed(seedStr));
    
    // Hide any open panels when starting a new run
    if (summaryPanel) summaryPanel.style.display = 'none';
    if (pauseMenu) pauseMenu.style.display = 'none';
    if (settingsPanel) settingsPanel.style.display = 'none';
    
    resetGame();
    showPopup("First stage");
    
    // Ensure HUD is visible
    if (hud) hud.style.display = 'block';
    
    // Start ambient audio loop
    playAmbientLoop();
}

function msToClock(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const millis = ms % 1000;
    return `${minutes}:${seconds.toString().padStart(2,'0')}.${millis.toString().padStart(3,'0')}`;
}

function showPopup(text) {
    if (popupEl) popupEl.textContent = text;
    popupLife = 120; // ~2 seconds
    if (popupEl) popupEl.style.opacity = '1';
    setTimeout(() => { if (popupEl) popupEl.style.opacity = '0'; }, 1500);
}

function saveRun(won) {
    try {
        const runs = JSON.parse(localStorage.getItem('mh_runs') || '[]');
        const finishedMs = totalElapsedMs + (currentGameState === GAME_STATE.PLAYING ? (Date.now() - stageStartTime) : 0);
        runs.unshift({
            ts: Date.now(),
            stages: Math.min(stageIndex, STAGES.length + 1),
            won: !!won,
            timeMs: finishedMs
        });
        while (runs.length > 10) runs.pop();
        localStorage.setItem('mh_runs', JSON.stringify(runs));
    } catch(e) {}
}

function renderLeaderboard() {
    if (!leaderboardList) return;
    let runs = [];
    try { runs = JSON.parse(localStorage.getItem('mh_runs') || '[]'); } catch(e) { runs = []; }
    leaderboardList.innerHTML = '';
    if (!runs.length) {
        const li = document.createElement('li');
        li.textContent = 'No runs yet. Escape if you can.';
        leaderboardList.appendChild(li);
        return;
    }
    runs.forEach(run => {
        const li = document.createElement('li');
        const date = new Date(run.ts);
        li.textContent = `${date.toLocaleDateString()} ${date.toLocaleTimeString()} — Stages: ${run.stages} — ${msToClock(run.timeMs)}${run.won ? ' ✓' : ''}`;
        leaderboardList.appendChild(li);
    });
}

// =============================================================================
// --- MAZE, PATHFINDING, AND SHIFTING ---
// =============================================================================
function generateMaze(w, h) {
    // Create a more interesting, balanced maze using a hybrid approach
    let maze = Array(h).fill(null).map(() => Array(w).fill(1));
    
    // Start with a more open center area
    const centerY = Math.floor(h / 2);
    const centerX = Math.floor(w / 2);
    
    // Create a central hub with multiple paths
    for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
            const ny = centerY + dy;
            const nx = centerX + dx;
            if (ny > 0 && ny < h - 1 && nx > 0 && nx < w - 1) {
                maze[ny][nx] = 0;
            }
        }
    }
    
    // Create main corridors in a cross pattern
    for (let i = 1; i < w - 1; i++) {
        if (i % 3 === 0) { // Vertical corridors
            for (let y = 1; y < h - 1; y++) {
                if (maze[y][i] === 1) maze[y][i] = 0;
            }
        }
    }
    
    for (let i = 1; i < h - 1; i++) {
        if (i % 3 === 0) { // Horizontal corridors
            for (let x = 1; x < w - 1; x++) {
                if (maze[i][x] === 1) maze[i][x] = 0;
            }
        }
    }
    
    // Add diagonal connections to break up the grid
    for (let y = 2; y < h - 2; y += 2) {
        for (let x = 2; x < w - 2; x += 2) {
            if (maze[y][x] === 1 && prng() < 0.4) {
                // Create diagonal paths
                if (maze[y-1][x-1] === 0 && maze[y+1][x+1] === 0) {
                    maze[y][x] = 0;
                } else if (maze[y-1][x+1] === 0 && maze[y+1][x-1] === 0) {
                    maze[y][x] = 0;
                }
            }
        }
    }
    
    // Add some random rooms and open areas with better placement
    for (let room = 0; room < 4; room++) {
        const roomSize = 3 + Math.floor(prng() * 3);
        let roomX, roomY;
        let attempts = 0;
        
        // Try to place room in a good location
        do {
            roomX = 2 + Math.floor(prng() * (w - roomSize - 2));
            roomY = 2 + Math.floor(prng() * (h - roomSize - 2));
            attempts++;
        } while (attempts < 20 && !isGoodRoomLocation(roomX, roomY, roomSize, maze, w, h));
        
        // Place the room
        for (let dy = 0; dy < roomSize; dy++) {
            for (let dx = 0; dx < roomSize; dx++) {
                const ny = roomY + dy;
                const nx = roomX + dx;
                if (ny > 0 && ny < h - 1 && nx > 0 && nx < w - 1) {
                    maze[ny][nx] = 0;
                }
            }
        }
        
        // Ensure room has at least one connection to the main path
        ensureRoomConnectivity(roomX, roomY, roomSize, maze, w, h);
    }
    
    // Ensure spawn area is completely open and accessible
    for (let dy = -1; dy <= 2; dy++) {
        for (let dx = -1; dx <= 2; dx++) {
            const ny = 1 + dy;
            const nx = 1 + dx;
            if (ny >= 0 && ny < h && nx >= 0 && nx < w) {
                maze[ny][nx] = 0;
            }
        }
    }
    
    // Ensure exit area is accessible
    const exitY = h - 2;
    const exitX = w - 2;
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            const ny = exitY + dy;
            const nx = exitX + dx;
            if (ny >= 0 && ny < h && nx >= 0 && nx < w) {
                maze[ny][nx] = 0;
            }
        }
    }
    
    // Add some winding paths to break up straight corridors
    for (let path = 0; path < 6; path++) {
        let startX = 1 + Math.floor(prng() * (w - 2));
        let startY = 1 + Math.floor(prng() * (h - 2));
        
        if (maze[startY][startX] === 0) {
            let pathLength = 5 + Math.floor(prng() * 8);
            let currentX = startX;
            let currentY = startY;
            
            for (let step = 0; step < pathLength; step++) {
                const directions = [[1,0], [-1,0], [0,1], [0,-1]];
                const [dx, dy] = directions[Math.floor(prng() * directions.length)];
                
                const nextX = currentX + dx;
                const nextY = currentY + dy;
                
                if (nextX > 0 && nextX < w - 1 && nextY > 0 && nextY < h - 1) {
                    maze[nextY][nextX] = 0;
                    currentX = nextX;
                    currentY = nextY;
                }
            }
        }
    }
    
    // Validate connectivity and fix any isolated areas
    let visited = new Set();
    let queue = [[centerX, centerY]];
    visited.add(`${centerX},${centerY}`);
    
    while (queue.length > 0) {
        const [x, y] = queue.shift();
        const directions = [[1,0], [-1,0], [0,1], [0,-1]];
        
        for (let [dx, dy] of directions) {
            const nx = x + dx;
            const ny = y + dy;
            const key = `${nx},${ny}`;
            
            if (nx >= 0 && nx < w && ny >= 0 && ny < h && maze[ny][nx] === 0 && !visited.has(key)) {
                visited.add(key);
                queue.push([nx, ny]);
            }
        }
    }
    
    // Connect any unreachable areas
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            if (maze[y][x] === 0 && !visited.has(`${x},${y}`)) {
                // Find nearest visited cell and create a path
                let nearestDist = Infinity;
                let nearestCell = null;
                
                for (let vy = 0; vy < h; vy++) {
                    for (let vx = 0; vx < w; vx++) {
                        if (visited.has(`${vx},${vy}`)) {
                            const dist = Math.hypot(x - vx, y - vy);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestCell = [vx, vy];
                            }
                        }
                    }
                }
                
                if (nearestCell) {
                    // Create a path to the nearest visited cell
                    const [vx, vy] = nearestCell;
                    let cx = vx, cy = vy;
                    
                    while (cx !== x || cy !== y) {
                        if (cx !== x) {
                            cx += Math.sign(x - vx);
                            maze[cy][cx] = 0;
                        }
                        if (cy !== y) {
                            cy += Math.sign(y - vy);
                            maze[cy][cx] = 0;
                        }
                    }
                }
            }
        }
    }
    
    // Count walls vs open spaces for debugging
    let walls = 0, open = 0;
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            if (maze[y][x] === 1) walls++;
            else open++;
        }
    }
    
    // Ensure minimum open space (at least 35% open)
    const openPercentage = (open / (walls + open)) * 100;
    if (openPercentage < 35) {
        console.log(`Maze too cramped (${openPercentage.toFixed(1)}% open), adding more open space...`);
        
        // Add more open areas by converting some walls to open space
        for (let y = 1; y < h - 1; y++) {
            for (let x = 1; x < w - 1; x++) {
                if (maze[y][x] === 1 && prng() < 0.15) {
                    maze[y][x] = 0;
                }
            }
        }
        
        // Recalculate
        walls = 0; open = 0;
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                if (maze[y][x] === 1) walls++;
                else open++;
            }
        }
    }
    
    console.log(`Generated maze: ${walls} walls, ${open} open spaces (${(open/(walls+open)*100).toFixed(1)}% open)`);
    
    return maze;
}

function isGoodRoomLocation(roomX, roomY, roomSize, maze, w, h) {
    // Check if room placement is good (not too close to edges, not overlapping with existing open areas)
    if (roomX < 2 || roomY < 2 || roomX + roomSize >= w - 2 || roomY + roomSize >= h - 2) {
        return false;
    }
    
    // Check for overlap with existing open areas (avoid creating huge open spaces)
    let openCount = 0;
    for (let dy = 0; dy < roomSize; dy++) {
        for (let dx = 0; dx < roomSize; dx++) {
            if (maze[roomY + dy][roomX + dx] === 0) {
                openCount++;
            }
        }
    }
    
    // Allow some overlap but not too much
    return openCount < (roomSize * roomSize * 0.5);
}

function ensureRoomConnectivity(roomX, roomY, roomSize, maze, w, h) {
    // Ensure the room connects to the main path system
    const directions = [[1,0], [-1,0], [0,1], [0,-1]];
    let connected = false;
    
    // Check if room is already connected
    for (let dy = 0; dy < roomSize; dy++) {
        for (let dx = 0; dx < roomSize; dx++) {
            const ny = roomY + dy;
            const nx = roomX + dx;
            
            for (let [dx2, dy2] of directions) {
                const checkX = nx + dx2;
                const checkY = ny + dy2;
                if (checkX >= 0 && checkX < w && checkY >= 0 && checkY < h && maze[checkY][checkX] === 0) {
                    // Check if this connection leads to the main path
                    if (isConnectedToMainPath(checkX, checkY, maze, w, h)) {
                        connected = true;
                        break;
                    }
                }
            }
            if (connected) break;
        }
        if (connected) break;
    }
    
    // If not connected, create a connection
    if (!connected) {
        // Find the best place to create a connection
        let bestConnection = null;
        let bestScore = -1;
        
        for (let dy = 0; dy < roomSize; dy++) {
            for (let dx = 0; dx < roomSize; dx++) {
                const ny = roomY + dy;
                const nx = roomX + dx;
                
                for (let [dx2, dy2] of directions) {
                    const checkX = nx + dx2;
                    const checkY = ny + dy2;
                    if (checkX >= 0 && checkX < w && checkY >= 0 && checkY < h && maze[checkY][checkX] === 1) {
                        // This is a wall we can break
                        const score = countNearbyOpenSpaces(checkX, checkY, maze, w, h);
                        if (score > bestScore) {
                            bestScore = score;
                            bestConnection = {x: checkX, y: checkY};
                        }
                    }
                }
            }
        }
        
        if (bestConnection) {
            maze[bestConnection.y][bestConnection.x] = 0;
        }
    }
}

function isConnectedToMainPath(x, y, maze, w, h) {
    // Simple flood fill to check if position connects to main path
    const visited = new Set();
    const queue = [[x, y]];
    visited.add(`${x},${y}`);
    
    while (queue.length > 0) {
        const [cx, cy] = queue.shift();
        
        // If we reach the center area, we're connected to main path
        if (Math.abs(cx - Math.floor(w/2)) <= 2 && Math.abs(cy - Math.floor(h/2)) <= 2) {
            return true;
        }
        
        const directions = [[1,0], [-1,0], [0,1], [0,-1]];
        for (let [dx, dy] of directions) {
            const nx = cx + dx;
            const ny = cy + dy;
            const key = `${nx},${ny}`;
            
            if (nx >= 0 && nx < w && ny >= 0 && ny < h && maze[ny][nx] === 0 && !visited.has(key)) {
                visited.add(key);
                queue.push([nx, ny]);
            }
        }
    }
    
    return false;
}

function countNearbyOpenSpaces(x, y, maze, w, h) {
    let count = 0;
    const directions = [[1,0], [-1,0], [0,1], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]];
    
    for (let [dx, dy] of directions) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < w && ny >= 0 && ny < h && maze[ny][nx] === 0) {
            count++;
        }
    }
    
    return count;
}

function findRandomEmptyCell(floorMap = map) {
    let x, y;
    for(let i=0; i<100; i++) {
        x = Math.floor(prng() * (MAP_SIZE - 2)) + 1;
        y = Math.floor(prng() * (MAP_SIZE - 2)) + 1;
        if (floorMap[y][x] === 0) {
            console.log("Found empty cell at", x, y, "after", i+1, "attempts");
            return { x, y };
        }
    }
    console.error("Failed to find empty cell after 100 attempts in floorMap:", floorMap);
    return null;
}

function findRandomWallAdjacentToFloor() {
    let tries = 0;
    while (tries++ < 400) {
        const x = Math.floor(prng() * (MAP_SIZE - 2)) + 1;
        const y = Math.floor(prng() * (MAP_SIZE - 2)) + 1;
        if (map[y][x] !== 1) continue; // must be a wall
        const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
        let hasOpen = false;
        for (let [dx,dy] of neighbors) {
            if (map[y+dy] && map[y+dy][x+dx] === 0) { hasOpen = true; break; }
        }
        if (hasOpen) return { x, y };
    }
    return null;
}



function isClosetInterior(x, y) {
    // Check if the given position is a closet interior tile
    return closetInteriors.some(closet => closet.x === x && closet.y === y);
}

function isOnClosetTile(x, y) {
    // Check if the given position is either a closet wall or interior
    return map[y] && (map[y][x] === 4 || isClosetInterior(x, y));
}

function isNearCloset(x, y) {
    // Check if player is within 1 tile of a closet
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE) {
                if (map[ny][nx] === 4 || isClosetInterior(nx, ny)) {
                    return true;
                }
            }
        }
    }
    return false;
}

function findNearestCloset(x, y) {
    // Find the closest closet to the given position
    let nearestCloset = null;
    let nearestDist = Infinity;
    
    for (let closet of closetInteriors) {
        const dist = Math.hypot(closet.x - x, closet.y - y);
        if (dist < nearestDist) {
            nearestDist = dist;
            nearestCloset = closet;
        }
    }
    
    return nearestCloset;
}

function isFacingCloset() {
    // Check if player is facing a closet wall
    const facingX = Math.floor(player.x + Math.cos(player.angle) * 0.7);
    const facingY = Math.floor(player.y + Math.sin(player.angle) * 0.7);
    
    if (facingX < 0 || facingX >= MAP_SIZE || facingY < 0 || facingY >= MAP_SIZE) return false;
    
    return map[facingY][facingX] === 4; // Closet wall tile
}

function findClosetData(x, y) {
    // Find closet data for a given position (either interior or wall)
    if (map[y][x] === 4) {
        // This is a closet wall - find the corresponding interior
        const directions = [[1,0], [-1,0], [0,1], [0,-1]];
        for (let [dx, dy] of directions) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
                // Check if this is a closet interior
                const closet = closetInteriors.find(c => c.x === nx && c.y === ny);
                if (closet) {
                    return {
                        ...closet,
                        wallX: x,
                        wallY: y
                    };
                }
            }
        }
    } else if (map[y][x] === 0) {
        // This might be a closet interior
        const closet = closetInteriors.find(c => c.x === x && c.y === y);
        if (closet) {
            return closet;
        }
    }
    
    return null;
}

function findSafeSpawnCell() {
    let cell = null; let tries = 0;
    while (!cell && tries++ < 400) {
        const c = findRandomEmptyCell(map);
        if (!c) break;
        
        // Ensure spawn point has good connectivity (not cut off)
        if (isPositionWellConnected(c.x, c.y)) {
            // Ensure not adjacent to many walls (open area)
            const walls = [[1,0],[-1,0],[0,1],[0,-1]].filter(([dx,dy]) => 
                map[c.y+dy] && map[c.y+dy][c.x+dx] === 1
            ).length;
            if (walls <= 1) cell = c;
        }
    }
    return cell || findRandomEmptyCell(map);
}

function isPositionWellConnected(x, y) {
    // Check if position has good connectivity to the rest of the map
    // Count accessible neighbors and ensure path to multiple areas
    let accessibleNeighbors = 0;
    let hasPathToOpenArea = false;
    
    // Check immediate neighbors
    for (let [dx, dy] of [[1,0], [-1,0], [0,1], [0,-1]]) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            accessibleNeighbors++;
            
            // Check if this neighbor leads to a more open area
            for (let [dx2, dy2] of [[1,0], [-1,0], [0,1], [0,-1]]) {
                const nx2 = nx + dx2;
                const ny2 = ny + dy2;
                if (nx2 >= 0 && nx2 < MAP_SIZE && ny2 >= 0 && ny2 < MAP_SIZE && map[ny2][nx2] === 0) {
                    hasPathToOpenArea = true;
                    break;
                }
            }
        }
    }
    
    // For stage 1, be less strict about connectivity requirements
    if (stageIndex === 0) {
        return accessibleNeighbors >= 1; // Only need 1 accessible neighbor for stage 1
    }
    
    // Position is well connected if it has at least 2 accessible neighbors and leads to open areas
    return accessibleNeighbors >= 2 && hasPathToOpenArea;
}

function findWellConnectedExitPosition(map) {
    // Find the best exit position that's well connected to the map
    let bestPositions = [];
    
    // Try to find positions with excellent connectivity
    for (let y = 0; y < MAP_SIZE; y++) {
        for (let x = 0; x < MAP_SIZE; x++) {
            if (map[y][x] === 0) { // Empty floor tile
                const connectivity = calculatePositionConnectivity(x, y, map);
                if (connectivity >= 3) { // At least 3 good connections
                    bestPositions.push({ x, y, connectivity });
                }
            }
        }
    }
    
    // Sort by connectivity (highest first)
    bestPositions.sort((a, b) => b.connectivity - a.connectivity);
    
    // Return the best position, or fallback to random if none found
    if (bestPositions.length > 0) {
        return bestPositions[0];
    }
    
    // Fallback: find any position with at least 2 connections
    for (let y = 0; y < MAP_SIZE; y++) {
        for (let x = 0; x < MAP_SIZE; x++) {
            if (map[y][x] === 0) {
                const connectivity = calculatePositionConnectivity(x, y, map);
                if (connectivity >= 2) {
                    return { x, y };
                }
            }
        }
    }
    
    // Last resort: any empty cell
    return findRandomEmptyCell(map);
}

function calculatePositionConnectivity(x, y, map) {
    let connectivity = 0;
    
    // Check all 4 directions
    for (let [dx, dy] of [[1,0], [-1,0], [0,1], [0,-1]]) {
        const nx = x + dx;
        const ny = y + dy;
        
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            connectivity++;
            
            // Bonus points for positions that lead to more open areas
            for (let [dx2, dy2] of [[1,0], [-1,0], [0,1], [0,-1]]) {
                const nx2 = nx + dx2;
                const ny2 = ny + dy2;
                if (nx2 >= 0 && nx2 < MAP_SIZE && ny2 >= 0 && ny2 < MAP_SIZE && map[ny2][nx2] === 0) {
                    connectivity += 0.5; // Bonus for extended connectivity
                }
            }
        }
    }
    
    return connectivity;
}

function findSafeEnemySpawn(map, playerSpawn) {
    // Find enemy spawn position that's far enough from player
    // For stage 1, use a smaller minimum distance to make spawning easier
    const MIN_SPAWN_DISTANCE = stageIndex === 0 ? 5 : 8; // Shorter distance for stage 1
    let attempts = 0;
    const maxAttempts = 200;
    
    console.log(`Finding safe enemy spawn. Player at (${playerSpawn.x}, ${playerSpawn.y}), min distance: ${MIN_SPAWN_DISTANCE}`);
    
    while (attempts < maxAttempts) {
        const spawnPos = findRandomEmptyCell(map);
        if (!spawnPos) {
            console.warn("No random empty cell found for enemy spawn");
            break;
        }
        
        // Calculate distance from player spawn
        const distanceFromPlayer = Math.hypot(
            spawnPos.x - playerSpawn.x, 
            spawnPos.y - playerSpawn.y
        );
        
        // Check if position is well connected and far enough from player
        if (distanceFromPlayer >= MIN_SPAWN_DISTANCE && isPositionWellConnected(spawnPos.x, spawnPos.y)) {
            console.log(`Found safe enemy spawn at (${spawnPos.x}, ${spawnPos.y}), distance: ${distanceFromPlayer.toFixed(1)}`);
            return spawnPos;
        }
        
        attempts++;
    }
    
    // Fallback: find any position that's at least moderately far from player
    console.log(`Fallback: searching for moderately distant spawn positions`);
    for (let y = 0; y < MAP_SIZE; y++) {
        for (let x = 0; x < MAP_SIZE; x++) {
            if (map[y][x] === 0) {
                const distanceFromPlayer = Math.hypot(x - playerSpawn.x, y - playerSpawn.y);
                if (distanceFromPlayer >= MIN_SPAWN_DISTANCE * 0.7) { // Allow slightly closer as fallback
                    console.log(`Fallback spawn found at (${x}, ${y}), distance: ${distanceFromPlayer.toFixed(1)}`);
                    return { x, y };
                }
            }
        }
    }
    
    // Last resort: any empty cell
    console.log("Last resort: using any random empty cell");
    return findRandomEmptyCell(map);
}

function shiftMaze() {
    console.log(`House shift triggered! Current interval: ${currentShiftInterval}ms, Stage: ${stageIndex + 1}`);
    console.log(`Player position before shift: (${player.x.toFixed(2)}, ${player.y.toFixed(2)})`);
    
    // Safety check: ensure map is initialized for the core shift operation
    if (!map || !Array.isArray(map) || map.length === 0) {
        console.warn("shiftMaze: map not properly initialized, skipping shift");
        return;
    }
    
    // Shift current floor with enhanced failsafe system
    console.log("Shifting maze rows...");
    const tempRow = map.pop();
    map.unshift(tempRow);
    
    // Rotate staircases on all floors (only if floors array exists)
    if (floors && Array.isArray(floors) && floors.length > 0) {
        for (let f = 0; f < floors.length; f++) {
            const floor = floors[f];
            if (floor && Array.isArray(floor) && floor.length > 0) {
                const tempRowFloor = floor.pop();
                floor.unshift(tempRowFloor);
            }
        }
    }
    
    // Update floor connections to match new positions (only if they exist)
    if (floorConnections && Array.isArray(floorConnections)) {
        floorConnections.forEach(conn => {
            if (conn && typeof conn.upY === 'number' && typeof conn.downY === 'number') {
                conn.upY = (conn.upY + 1) % MAP_SIZE;
                conn.downY = (conn.downY + 1) % MAP_SIZE;
            }
        });
    }
    
    // Enhanced house shift failsafe for player positioning
    let playerRelocated = false;
    if (map && player && typeof player.x === 'number' && typeof player.y === 'number' && 
        Math.floor(player.y) >= 0 && Math.floor(player.y) < map.length && 
        Math.floor(player.x) >= 0 && Math.floor(player.x) < map[0].length) {
        
        // Only relocate if player is actually in a solid wall (not stairs or decorative objects)
        const playerTile = map[Math.floor(player.y)][Math.floor(player.x)];
        if (playerTile === 1) { // Only relocate if in a solid wall
            console.log("House shift: player stuck in wall, relocating...");
            
            // Try to find adjacent safe tile
            for (let [dx, dy] of [[0,1], [0,-1], [1,0], [-1,0]]) {
                 const newX = Math.floor(player.x+dx);
                 const newY = Math.floor(player.y+dy);
                 if (newY >= 0 && newY < map.length && newX >= 0 && newX < map[0].length && map[newY][newX] === 0) {
                     player.x = newX + 0.5;
                     player.y = newY + 0.5;
                     playerRelocated = true;
                     console.log("House shift: relocated player to adjacent safe tile");
                     break;
                 }
            }
        }
        
        // If no adjacent safe tile found, use more aggressive search
        if (!playerRelocated) {
            console.log("House shift: no adjacent safe tile, searching wider area");
            for (let radius = 2; radius <= 4; radius++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        if (Math.abs(dx) + Math.abs(dy) === radius) { // Diamond pattern
                            const nx = Math.floor(player.x) + dx;
                            const ny = Math.floor(player.y) + dy;
                            if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map && ny < map.length && nx < map[0].length && map[ny][nx] === 0) {
                                player.x = nx + 0.5;
                                player.y = ny + 0.5;
                                playerRelocated = true;
                                console.log(`House shift: relocated player to safe tile at distance ${radius}`);
                                break;
                            }
                        }
                    }
                    if (playerRelocated) break;
                }
                if (playerRelocated) break;
            }
        }
        
        // Final failsafe: emergency spawn if still stuck
        if (!playerRelocated) {
            console.log("House shift: emergency spawn - all else failed");
            player.x = 1.5;
            player.y = 1.5;
            message.text = "The house shift was too violent! You've been relocated.";
            message.life = 200;
        }
    }
    message.text = "House has shifted!";
    message.life = 150;
    
    // Show prominent house shift popup
    showPopup("HOUSE HAS SHIFTED! ");
    
    // Add screen shake effect
    visualEffects.screenShake = {
        active: true,
        intensity: 8,
        duration: 30
    };
    
    // Sanity effect from house shift
    sanitySystem.currentSanity = Math.max(0, sanitySystem.currentSanity + sanitySystem.events.houseShift);
    
    lastShiftTime = Date.now();
    
    // Play house shift sound
    playSound('houseShift', 0.8);
    
    console.log(`Player position after shift: (${player.x.toFixed(2)}, ${player.y.toFixed(2)})`);

    // Ensure enemies are not stuck in walls after shift
    if (enemies && Array.isArray(enemies)) {
        for (let e of enemies) {
            if (!e || typeof e.x !== 'number' || typeof e.y !== 'number') continue;
            let ex = Math.floor(e.x);
            let ey = Math.floor(e.y);
            if (ey < 0 || ey >= MAP_SIZE || ex < 0 || ex >= MAP_SIZE || 
                !map || ey >= map.length || ex >= map[0].length || map[ey][ex] > 0) {
                // Relocate to a safe random cell FAR from player (minimum 8 tiles distance)
                let safe = null; let tries = 0;
                while (!safe && tries++ < 300) {
                    const cell = findRandomEmptyCell(map);
                    if (!cell) break;
                    const dist = Math.hypot(cell.x + 0.5 - player.x, cell.y + 0.5 - player.y);
                    if (dist > 8) safe = cell; // Increased minimum distance from 3 to 8
                }
                
                // If findRandomEmptyCell failed, try a more aggressive search
                if (!safe) {
                    console.log("House shift: findRandomEmptyCell failed for enemy, trying manual search");
                    for (let radius = 1; radius <= 8; radius++) { // Increased search radius
                        for (let dx = -radius; dx <= radius; dx++) {
                            for (let dy = -radius; dy <= radius; dy++) {
                                if (Math.abs(dx) + Math.abs(dy) === radius) { // Diamond pattern
                                    const nx = ex + dx;
                                    const ny = ey + dy;
                                    if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && 
                                        ny < map.length && nx < map[0].length && map[ny][nx] === 0) {
                                        const dist = Math.hypot(nx + 0.5 - player.x, ny + 0.5 - player.y);
                                        if (dist > 6) { // Increased minimum distance from 3 to 6
                                            safe = { x: nx, y: ny };
                                            break;
                                        }
                                    }
                                }
                            }
                            if (safe) break;
                        }
                        if (safe) break;
                    }
                }
                
                if (safe) { 
                    e.x = safe.x + 0.5; 
                    e.y = safe.y + 0.5; 
                    e.path = []; 
                    console.log(`House shift: relocated enemy to safe position at ${safe.x}, ${safe.y}`);
                } else {
                    console.warn("House shift: could not find safe position for enemy, using emergency spawn");
                    // Emergency fallback: place enemy at a known safe location far from player
                    e.x = MAP_SIZE - 1.5;
                    e.y = MAP_SIZE - 1.5;
                    e.path = [];
                }
            }
        }
    }
    
    // Ensure sprites (containers, items) are not stuck in walls after shift
    if (sprites && Array.isArray(sprites)) {
        for (let i = sprites.length - 1; i >= 0; i--) {
            let sprite = sprites[i];
            if (!sprite || typeof sprite.x !== 'number' || typeof sprite.y !== 'number') continue;
            let sx = Math.floor(sprite.x);
            let sy = Math.floor(sprite.y);
            if (sy < 0 || sy >= MAP_SIZE || sx < 0 || sx >= MAP_SIZE || 
                !map || sy >= map.length || sx >= map[0].length || map[sy][sx] > 0) {
            // Try to find a safe position near the original location
            let safe = null;
            for (let radius = 1; radius <= 3; radius++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        if (Math.abs(dx) + Math.abs(dy) === radius) { // Diamond pattern
                            const nx = sx + dx;
                            const ny = sy + dy;
                            if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
                                safe = { x: nx + 0.5, y: ny + 0.5 };
                                break;
                            }
                        }
                    }
                    if (safe) break;
                }
                if (safe) break;
            }
            
            if (safe) {
                sprite.x = safe.x;
                sprite.y = safe.y;
                console.log(`House shift: relocated ${sprite.type} to safe position`);
            } else {
                // If no safe position found, remove the sprite
                console.log(`House shift: removing ${sprite.type} that couldn't be relocated`);
                sprites.splice(i, 1);
            }
        }
        }
    }
}

function findPath(startX, startY, endX, endY) { // BFS
    // Safety check: ensure map is initialized
    if (!map || !Array.isArray(map) || map.length === 0) {
        console.warn("findPath: map not properly initialized, returning empty path");
        return [];
    }
    
    let queue = [[{x: startX, y: startY}, []]];
    let visited = new Set([`${startX},${startY}`]);

    while(queue.length > 0) {
        let [{x, y}, path] = queue.shift();
        if(x === endX && y === endY) return path;

        for (let [dx, dy] of [[0,1], [0,-1], [1,0], [-1,0]]) {
            let [nx, ny] = [x + dx, y + dy];
            if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && 
                ny < map.length && nx < map[0].length && map[ny][nx] === 0 && !visited.has(`${nx},${ny}`)) {
                visited.add(`${nx},${ny}`);
                let newPath = [...path, {x: nx, y: ny}];
                queue.push([{x: nx, y: ny}, newPath]);
            }
        }
    }
    return [];
}

// New item usage functions
function useSmokeBomb() {
    playSound('smokeBomb', 0.8);
    // Create smoke effect that blocks enemy vision temporarily
    const smokeRadius = 3;
    const smokeDuration = 8000; // 8 seconds
    
    // Find enemies in range and temporarily blind them
    for (let enemy of enemies) {
        const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
        if (dist <= smokeRadius) {
            enemy.blinded = true;
            enemy.blindUntil = Date.now() + smokeDuration;
            // Make them wander randomly while blinded
            enemy.path = [];
            enemy.state = 'BLINDED';
        }
    }
    
    // Also affect stalker if present
    if (stalkerEnemy) {
        const dist = Math.hypot(stalkerEnemy.x - player.x, stalkerEnemy.y - player.y);
        if (dist <= smokeRadius) {
            stalkerEnemy.blinded = true;
            stalkerEnemy.blindUntil = Date.now() + smokeDuration;
            stalkerEnemy.path = [];
        }
    }
    
    message.text = 'Smoke screen deployed! Enemies are temporarily blinded.';
    message.life = 150;
}

function useNoiseMaker() {
    playSound('noiseMaker', 0.9);
    // Create a loud noise that attracts all enemies to a specific location
    const noiseRadius = 6;
    const attractDuration = 5000; // 5 seconds
    
    // Choose a location away from player to attract enemies
    let attractX = player.x + (Math.random() - 0.5) * 8;
    let attractY = player.y + (Math.random() - 0.5) * 8;
    
    // Ensure the location is within bounds and accessible
    attractX = Math.max(1, Math.min(MAP_SIZE - 2, attractX));
    attractY = Math.max(1, Math.min(MAP_SIZE - 2, attractY));
    
    // Make all enemies in range move toward the noise (but respect spawn grace period)
    for (let enemy of enemies) {
        const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
        if (dist <= noiseRadius) {
            // Check if enemy is in spawn grace period
            const inSpawnGrace = enemy.spawnTime && (Date.now() - enemy.spawnTime) < enemy.spawnGracePeriod;
            
            if (!inSpawnGrace) {
                enemy.attractedTo = { x: attractX, y: attractY };
                enemy.attractedUntil = Date.now() + attractDuration;
                enemy.state = 'ATTRACTED';
                // Clear current path and set new target
                enemy.path = findPath(Math.floor(enemy.x), Math.floor(enemy.y), Math.floor(attractX), Math.floor(attractY));
            }
        }
    }
    
    // Also affect stalker if present
    if (stalkerEnemy) {
        const dist = Math.hypot(stalkerEnemy.x - player.x, stalkerEnemy.y - player.y);
        if (dist <= noiseRadius) {
            stalkerEnemy.attractedTo = { x: attractX, y: attractY };
            stalkerEnemy.attractedUntil = Date.now() + attractDuration;
            stalkerEnemy.state = 'ATTRACTED';
            stalkerEnemy.path = findPath(Math.floor(stalkerEnemy.x), Math.floor(stalkerEnemy.y), Math.floor(attractX), Math.floor(attractY));
        }
    }
    
    message.text = 'Noise maker activated! Enemies are attracted to the sound.';
    message.life = 150;
}

function usePanicButton() {
    // Panic button - emergency sanity recovery and temporary invincibility
    if (sanitySystem.currentSanity <= sanitySystem.criticalSanityThreshold) {
        // Dramatic sanity recovery
        sanitySystem.currentSanity = Math.min(sanitySystem.maxSanity, sanitySystem.currentSanity + 40);
        
        // Temporary invincibility (3 seconds)
        player.panicInvincibility = Date.now() + 3000;
        
        // Clear all hallucinations
        enemies = enemies.filter(e => !e.isHallucination);
        
        // Temporary speed boost
        player.panicSpeedBoost = Date.now() + 5000;
        
        // Visual and audio effects
        showPopup("PANIC MODE ACTIVATED!");
        playSound('rushEvent', 0.8);
        
        message.text = "PANIC MODE: You feel a surge of adrenaline!";
        message.life = 200;
        
        // Deactivate all sanity effects temporarily
        sanitySystem.deactivateSanityEffects();
        setTimeout(() => {
            if (sanitySystem.currentSanity <= sanitySystem.criticalSanityThreshold) {
                sanitySystem.checkSanityEffects();
            }
        }, 10000); // Re-check after 10 seconds
    }
}


// =============================================================================
// --- INPUT HANDLING ---
// =============================================================================
const isMobile = 'ontouchstart' in window;

function setupInputs() {
    if (isMobile) {
        mobileControls.style.display = 'block';
        const joyThumb = document.getElementById('joystick-thumb');
        
        // Function to update joystick center position
        const updateJoyCenter = () => {
            const joyBase = document.getElementById('joystick-base').getBoundingClientRect();
            touchState.joyCenter = { x: joyBase.left + joyBase.width/2, y: joyBase.top + joyBase.height/2 };
            console.log("Joystick center updated:", touchState.joyCenter);
        };
        
        touchState = { move: null, look: null, joyCenter: { x: 0, y: 0 } };
        updateJoyCenter(); // Initial calculation
        
        // Update joystick center on window resize
        window.addEventListener('resize', updateJoyCenter);

        canvas.addEventListener('touchstart', e => {
            // Block touch input if game is paused
            if (currentGameState === GAME_STATE.PAUSED) return;
            
            // Update joystick center position before processing touches
            updateJoyCenter();
            
            for (let touch of e.changedTouches) {
                if (touch.clientX < window.innerWidth / 2) {
                    touchState.move = { id: touch.identifier, startX: touch.clientX, startY: touch.clientY, currentX: touch.clientX, currentY: touch.clientY };
                } else {
                    touchState.look = { id: touch.identifier, lastX: touch.clientX };
                }
            }
        });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            // Block touch input if game is paused
            if (currentGameState === GAME_STATE.PAUSED) return;
            
            // Update joystick center position
            updateJoyCenter();
            
            for (let touch of e.changedTouches) {
                if(touchState.move && touch.identifier === touchState.move.id){
                    touchState.move.currentX = touch.clientX;
                    touchState.move.currentY = touch.clientY;
                    let dx = touch.clientX - touchState.joyCenter.x;
                    let dy = touch.clientY - touchState.joyCenter.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    const joyBase = document.getElementById('joystick-base').getBoundingClientRect();
                    let clampedDist = Math.min(dist, joyBase.width/2 - 30);
                    joyThumb.style.transform = `translate(calc(-50% + ${clampedDist * dx/dist}px), calc(-50% + ${clampedDist * dy/dist}px))`;
                }
                if(touchState.look && touch.identifier === touchState.look.id){
                    // Fixed inverted look controls with smoothing
                    const deltaX = touch.clientX - touchState.look.lastX;
                    cameraSmoothing.mobile.targetAngle -= deltaX * ROTATION_SPEED * 1.5; // Reduced multiplier for smoother control
                    touchState.look.lastX = touch.clientX;
                }
            }
        });
        canvas.addEventListener('touchend', e => {
             for (let touch of e.changedTouches) {
                if(touchState.move && touch.identifier === touchState.move.id) { touchState.move = null; joyThumb.style.transform = `translate(-50%, -50%)`; }
                if(touchState.look && touch.identifier === touchState.look.id) touchState.look = null;
            }
        });
        document.getElementById('hide-button').addEventListener('touchstart', e => { 
            e.preventDefault(); 
            // Block hide button if game is paused
            if (currentGameState === GAME_STATE.PAUSED) return;
            tryToggleHide(); 
        });
        
        // New mobile button handlers
        document.getElementById('interact-button').addEventListener('touchstart', e => {
            e.preventDefault();
            if (currentGameState === GAME_STATE.PAUSED) return;
            tryInteract();
        });
        
        document.getElementById('door-button').addEventListener('touchstart', e => {
            e.preventDefault();
            if (currentGameState === GAME_STATE.PAUSED) return;
            tryOpenDoor();
        });
        
        document.getElementById('flashlight-button').addEventListener('touchstart', e => {
            e.preventDefault();
            if (currentGameState === GAME_STATE.PAUSED) return;
            if (inventory.flashlight) {
                inventory.flashlight = !inventory.flashlight;
                if (hudFlash) hudFlash.textContent = inventory.flashlight ? 'On' : 'Off';
        if (flashlightStatus) flashlightStatus.textContent = inventory.flashlight ? 'On' : 'Off';
            }
        });
        
        const crouchButton = document.getElementById('crouch-button');
        if (crouchButton) {
            // Mobile touch events
            crouchButton.addEventListener('touchstart', e => {
                e.preventDefault();
                if (currentGameState === GAME_STATE.PAUSED) return;
                playerAbilities.crouching = !playerAbilities.crouching;
                playerAbilities.stealthMode = playerAbilities.crouching;
                message.text = playerAbilities.crouching ? 'Crouching - Stealth mode active' : 'Standing - Normal mode';
                message.life = 120;
            });
            
            // Desktop click event
            crouchButton.addEventListener('click', e => {
                e.preventDefault();
                if (currentGameState === GAME_STATE.PAUSED) return;
                playerAbilities.crouching = !playerAbilities.crouching;
                playerAbilities.stealthMode = playerAbilities.crouching;
                message.text = playerAbilities.crouching ? 'Crouching - Stealth mode active' : 'Standing - Normal mode';
                message.life = 120;
            });
        }
    } else {
        document.addEventListener('keydown', e => {
            // Block input if game is paused
            if (currentGameState === GAME_STATE.PAUSED) return;
            
            keys[e.key.toLowerCase()] = true;
            
            // Handle immediate actions on keydown
            if (e.key.toLowerCase() === 'h') {
                console.log("H key pressed, current game state:", currentGameState, "calling tryToggleHide...");
                tryToggleHide();
            }
            if (e.key.toLowerCase() === 'e') {
                console.log("E key pressed, current game state:", currentGameState, "calling tryInteract...");
                tryInteract();
            }
            if (e.key === ' ' || e.code === 'Space') {
                // Check if player is on stairs first
                const playerTileX = Math.floor(player.x);
                const playerTileY = Math.floor(player.y);
                if (map[playerTileY][playerTileX] === 5) { // Stairs up
                    useStairs('up');
                } else if (map[playerTileY][playerTileX] === 6) { // Stairs down
                    useStairs('down');
                } else {
                    // Default door opening behavior
                    tryOpenDoor();
                }
            }
            if (e.key.toLowerCase() === 'f' && inventory.flashlight) { 
                inventory.flashlight = !inventory.flashlight; 
                if (hudFlash) hudFlash.textContent = inventory.flashlight ? 'On' : 'Off';
        if (flashlightStatus) flashlightStatus.textContent = inventory.flashlight ? 'On' : 'Off'; 
            }
            if (e.key.toLowerCase() === 'v' && inventory.vitamins > 0) { 
                inventory.vitamins -= 1; 
                inventory.vitActiveUntil = Date.now() + 6000; 
                message.text = 'Speed surge!'; 
                message.life = 120; 
                if (hudVits) hudVits.textContent = String(inventory.vitamins); 
                
                // Sanity boost from vitamins
                sanitySystem.currentSanity = Math.min(sanitySystem.maxSanity, sanitySystem.currentSanity + 15);
            }
            // New abilities
            if (e.key.toLowerCase() === 'c') {
                playerAbilities.crouching = !playerAbilities.crouching;
                playerAbilities.stealthMode = playerAbilities.crouching;
                message.text = playerAbilities.crouching ? 'Crouching - Stealth mode active' : 'Standing - Normal mode';
                message.life = 120;
            }
            if (e.key.toLowerCase() === 'q' && inventory.smokeBomb > 0) {
                inventory.smokeBomb--;
                useSmokeBomb();
                message.text = 'Smoke bomb deployed!';
                message.life = 120;
            }
            if (e.key.toLowerCase() === 'z' && inventory.noiseMaker > 0) {
                inventory.noiseMaker--;
                useNoiseMaker();
                message.text = 'Noise maker activated!';
                message.life = 120;
            }
            
            // Panic button - press P when sanity is critically low
            if (e.key.toLowerCase() === 'p' && sanitySystem.currentSanity <= sanitySystem.criticalSanityThreshold) {
                usePanicButton();
            }
            // Debug: Manual floor change (F1 for up, F2 for down)
            if (e.key === 'F1') {
                if (currentFloor < floors.length - 1) {
                    currentFloor++;
                    map = floors[currentFloor];
                    message.text = `Debug: Manually moved to floor ${currentFloor + 1}`; message.life = 150;
                    console.log("Manual floor change to:", currentFloor);
                } else {
                    message.text = "Already on top floor"; message.life = 100;
                }
            }
            if (e.key === 'F2') {
                if (currentFloor > 0) {
                    currentFloor--;
                    map = floors[currentFloor];
                    message.text = `Debug: Manually moved to floor ${currentFloor + 1}`; message.life = 150;
                    console.log("Manual floor change to:", currentFloor);
                } else {
                    message.text = "Already on bottom floor"; message.life = 100;
                }
            }
        });
        document.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
        });
        document.addEventListener('mousemove', e => {
            if (currentGameState === GAME_STATE.PLAYING && document.pointerLockElement === canvas) {
                // Only process mouse movement if we're actually in playing state and pointer is locked
                if (e.movementX !== 0) {
                    const oldAngle = player.angle;
                    
                    // Calculate DPI adjustment for this movement
                    const dpiAdjustment = calculateDPIAdjustment(e.movementX);
                    
                    // Apply DPI adjustment to rotation
                    const movement = e.movementX * ROTATION_SPEED * (settings.sens||1) * dpiAdjustment;
                    
                    // Add smoothing to reduce jittery movement and make rotation feel more natural
                    const smoothingFactor = 0.9; // Higher smoothing for more natural feel
                    const smoothedMovement = movement * (1 - smoothingFactor) + (player.lastMovement || 0) * smoothingFactor;
                    player.angle += smoothedMovement;
                    player.lastMovement = smoothedMovement;
                    
                    // Keep angle within reasonable bounds and prevent floating point accumulation
                    if (player.angle > Math.PI * 2) player.angle -= Math.PI * 2;
                    if (player.angle < 0) player.angle += Math.PI * 2;
                    
                    // Debug: log rotation changes to identify issues
                    if (Math.abs(movement) > 0.001) { // Only log significant movements
                        console.log(`Mouse movement: movementX=${e.movementX}, DPI adj=${dpiAdjustment.toFixed(3)}, rotation=${movement.toFixed(6)}, smoothed=${smoothedMovement.toFixed(6)}, angle: ${oldAngle.toFixed(6)} -> ${player.angle.toFixed(6)}`);
                    }
                }
            }
        });
    }

    mainMenu.addEventListener('click', () => {
        console.log('Main menu clicked, current state:', currentGameState);
        if ([GAME_STATE.MENU, GAME_STATE.GAMEOVER, GAME_STATE.WON].includes(currentGameState)) {
            console.log('Starting new run...');
            startRun();
            currentGameState = GAME_STATE.PLAYING;
            mainMenu.style.opacity = '0';
            mainMenu.style.pointerEvents = 'none';
            hud.style.display = 'block';
            // Hide any open panels
            if (pauseMenu) pauseMenu.style.display = 'none';
            if (settingsPanel) settingsPanel.style.display = 'none';
            if (summaryPanel) summaryPanel.style.display = 'none';
            if (!isMobile) canvas.requestPointerLock();
            
            // Start DPI detection when game starts
            setTimeout(() => {
                detectMouseDPI();
                if (dpiInfo) {
                    dpiInfo.textContent = "Mouse: Detecting DPI...";
                    dpiInfo.style.display = 'block';
                }
            }, 1000); // Wait 1 second for pointer lock to be established
        }
    });

    if (dailyBtn) {
        dailyBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const d = new Date();
            const seedStr = `${d.getUTCFullYear()}-${(d.getUTCMonth()+1).toString().padStart(2,'0')}-${d.getUTCDate().toString().padStart(2,'0')}`;
            if (seedInput) seedInput.value = seedStr;
        });
    }

    document.addEventListener('pointerlockchange', () => {
        console.log(`Pointer lock changed. Element: ${document.pointerLockElement}, Canvas: ${canvas}, Game State: ${currentGameState}`);
        if (document.pointerLockElement !== canvas && currentGameState === GAME_STATE.PLAYING) {
            // Pause the game when pointer lock is lost
            console.log("Pointer lock lost, pausing game");
            currentGameState = GAME_STATE.PAUSED;
            pauseMenu.style.display = 'block';
            // Keep HUD visible during pause
        } else if (document.pointerLockElement === canvas && currentGameState === GAME_STATE.PLAYING) {
            console.log("Pointer lock acquired");
        }
    });

    // Pause and settings
    document.addEventListener('keydown', e => {
        if (e.key === 'Escape') {
            if (currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.HIDDEN) {
                // Pause the game
                currentGameState = GAME_STATE.PAUSED;
                pauseMenu.style.display = 'block';
                // Don't change mainMenu opacity here - keep it hidden
            } else if (currentGameState === GAME_STATE.PAUSED) {
                // Resume the game
                currentGameState = GAME_STATE.PLAYING;
                pauseMenu.style.display = 'none';
                // Don't change mainMenu - it should stay hidden during gameplay
                if (!isMobile) canvas.requestPointerLock();
            } else if (summaryPanel.style.display === 'block') {
                // Close summary panel with Escape key
                summaryPanel.style.display = 'none';
            }
        }
    });
    if (btnResume) btnResume.addEventListener('click', () => {
        // Resume the game - restore previous state
        if (currentGameState === GAME_STATE.PAUSED) {
            // Determine what state to return to based on what was active before pause
            // If player was hidden, return to hidden state
            if (player.closetEntryTime) {
                currentGameState = GAME_STATE.HIDDEN;
            } else {
                currentGameState = GAME_STATE.PLAYING;
            }
        }
        pauseMenu.style.display = 'none';
        // Ensure HUD is visible when resuming
        if (hud) hud.style.display = 'block';
        if (!isMobile) canvas.requestPointerLock();
    });
    if (btnRestart) btnRestart.addEventListener('click', () => {
        // Only restart if we're not in the middle of a run
        if (currentGameState === GAME_STATE.MENU) {
            startRun();
        } else {
            // Reset current stage but keep run progress
            resetGame();
        }
        // Return to playing state after restart
        currentGameState = GAME_STATE.PLAYING;
        pauseMenu.style.display = 'none';
        // Ensure HUD is visible when restarting
        if (hud) hud.style.display = 'block';
        if (!isMobile) canvas.requestPointerLock();
    });
    if (btnSettings) btnSettings.addEventListener('click', () => { settingsPanel.style.display = 'block'; });
    if (btnCloseSettings) btnCloseSettings.addEventListener('click', () => { settingsPanel.style.display = 'none'; });
    
    if (btnDetectDpi) btnDetectDpi.addEventListener('click', () => {
        detectMouseDPI();
        message.text = "Move your mouse slowly to calibrate DPI sensitivity..."; message.life = 200;
        if (dpiInfo) {
            dpiInfo.textContent = "Mouse: Detecting DPI...";
            dpiInfo.style.display = 'block';
        }
    });
    if (btnSummaryClose) btnSummaryClose.addEventListener('click', () => { summaryPanel.style.display = 'none'; });

    // Initialize settings UI
    if (optSens) optSens.value = settings.sens;
    if (optBright) optBright.value = settings.bright;
    if (optVol) optVol.value = settings.vol;
    if (optAudioCues) optAudioCues.checked = settings.audioCues;
    if (optScale) optScale.value = settings.scale;
    const saveSettings = () => { localStorage.setItem('mh_settings', JSON.stringify(settings)); };
    if (optSens) optSens.addEventListener('input', () => { settings.sens = parseFloat(optSens.value); saveSettings(); });
    if (optBright) optBright.addEventListener('input', () => { settings.bright = parseFloat(optBright.value); saveSettings(); });
    if (optVol) optVol.addEventListener('input', () => { settings.vol = parseFloat(optVol.value); saveSettings(); });
    if (optAudioCues) optAudioCues.addEventListener('change', () => { audioCues.enabled = optAudioCues.checked; settings.audioCues = optAudioCues.checked; saveSettings(); });
    if (optScale) optScale.addEventListener('input', () => { settings.scale = parseFloat(optScale.value); resizeCanvasScale(); saveSettings(); });
}

function tryInteract() {
    // If player is hidden, exit the closet
    if (currentGameState === GAME_STATE.HIDDEN) {
        console.log("E key pressed while hidden, exiting closet...");
        handleClosetExit();
        return;
    }
    
    const px = Math.floor(player.x);
    const py = Math.floor(player.y);
    
    // Check for stairs interaction (standing on stairs)
    if (map[py][px] === 5) { // Stairs up
        useStairs('up');
        return;
    } else if (map[py][px] === 6) { // Stairs down
        useStairs('down');
        return;
    }
    
    // Open container or toggle hide
    if (map[py][px] === 4) {
        tryToggleHide();
        return;
    }
    
    // Check for container in front of player
    const ix = Math.floor(player.x + Math.cos(player.angle) * 0.8);
    const iy = Math.floor(player.y + Math.sin(player.angle) * 0.8);
    let nearest = null;
    let minD = 0.9;
    for (let s of sprites) {
        if (s.type === 'container') {
            const d = Math.hypot(s.x - player.x, s.y - player.y);
            if (d < minD && Math.floor(s.x) === ix && Math.floor(s.y) === iy) { nearest = s; minD = d; }
        }
    }
    if (nearest) {
        if (!nearest.opened) {
            nearest.opened = true;
            nearest.texture = assets.containerOpen;
            
            if (nearest.contains) {
                // Handle different item types
                switch (nearest.contains.type) {
                    case 'goldKey':
                        player.hasGoldKey = true;
                        message.text = '🎉 You found the GOLD key! 🎉';
                        message.life = 250;
                        playSound('keyPickup', 1.0);
                        break;
                    case 'bronzeKey':
                        player.hasBronzeKey = true;
                        message.text = '🔑 You found a bronze key!';
                        message.life = 150;
                        playSound('keyPickup', 0.8);
                        break;
                    case 'flashlight':
                        inventory.flashlight = true;
                        message.text = '🔦 You found a flashlight! Press F to toggle.';
                        message.life = 200;
                        playSound('itemPickup', 0.7);
                        if (hudFlash) hudFlash.textContent = 'On';
                if (flashlightStatus) flashlightStatus.textContent = 'On';
                        if (flashlightStatus) flashlightStatus.textContent = 'On';
                        break;
                    case 'vitamins':
                        inventory.vitamins += 2;
                        message.text = '💊 You found vitamins! (+2) Press V to use.';
                        message.life = 200;
                        playSound('itemPickup', 0.6);
                        if (hudVits) hudVits.textContent = String(inventory.vitamins);
                        break;
                    case 'lockpick':
                        inventory.lockpick += 1;
                        message.text = '🔓 You found a lockpick! (+1) Use on bronze doors.';
                        message.life = 200;
                        playSound('itemPickup', 0.8);
                        if (hudPicks) hudPicks.textContent = String(inventory.lockpick);
                        break;
                    case 'smokeBomb':
                        inventory.smokeBomb += 1;
                        message.text = '💨 You found a smoke bomb! (+1) Press Q to use.';
                        message.life = 200;
                        playSound('itemPickup', 0.7);
                        if (hudSmoke) hudSmoke.textContent = String(inventory.smokeBomb);
                        break;
                    case 'noiseMaker':
                        inventory.noiseMaker += 1;
                        message.text = '🔊 You found a noise maker! (+1) Press Z to use.';
                        message.life = 200;
                        playSound('itemPickup', 0.7);
                        if (hudNoise) hudNoise.textContent = String(inventory.noiseMaker);
                        break;
                    default:
                        message.text = 'You found something useful.';
                        message.life = 100;
                        break;
                }
            } else {
                // Handle empty containers with interesting messages
                if (nearest.emptyMessage) {
                    message.text = nearest.emptyMessage;
                    message.life = 120;
                } else {
                    // Fallback empty messages
                    const fallbackMessages = [
                        'Nothing useful here.',
                        'Just dust and cobwebs.',
                        'Empty and forgotten.',
                        'Nothing of value.',
                        'Long since emptied.'
                    ];
                    message.text = fallbackMessages[Math.floor(prng() * fallbackMessages.length)];
                    message.life = 100;
                }
            }
        } else {
            message.text = 'Already searched thoroughly.';
            message.life = 80;
        }
        return;
    }

    // If facing a closet wall, handle it directly
    if (ix>=0 && ix<MAP_SIZE && iy>=0 && iy<MAP_SIZE && map[iy][ix] === 4) {
        // Check if player is near enough to enter the closet
        const playerTileX = Math.floor(player.x);
        const playerTileY = Math.floor(player.y);
        const distToCloset = Math.hypot(playerTileX - ix, playerTileY - iy);
        
        if (distToCloset <= 1.5) { // Within 1.5 tiles
            // Direct closet entry - don't call tryToggleHide to avoid freezing
            enterClosetDirectly(ix, iy);
        } else {
            message.text = "You need to get closer to the closet to hide in it."; message.life = 120;
        }
        return;
    }
    
    // Check for stairs interaction (facing stairs)
    if (ix>=0 && ix<MAP_SIZE && iy>=0 && iy<MAP_SIZE) {
        if (map[iy][ix] === 5) { // Stairs up
            useStairs('up');
            return;
        } else if (map[iy][ix] === 6) { // Stairs down
            useStairs('down');
            return;
        }
    }
}

function enterClosetDirectly(closetX, closetY) {
    console.log("enterClosetDirectly called for closet at", closetX, closetY);
    
    // Find the closet interior for this wall
    const directions = [[1,0], [-1,0], [0,1], [0,-1]];
    let closetData = null;
    
    for (let [dx, dy] of directions) {
        const nx = closetX + dx;
        const ny = closetY + dy;
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            // Check if this is a closet interior
            const closet = closetInteriors.find(c => c.x === nx && c.y === ny);
            if (closet) {
                closetData = {
                    ...closet,
                    wallX: closetX,
                    wallY: closetY
                };
                break;
            }
        }
    }
    
    if (!closetData) {
        console.log("No closet interior found for wall at", closetX, closetY);
        message.text = "This closet is not accessible."; message.life = 120;
        return;
    }
    
    // Move player into the closet interior
    player.x = closetData.x + 0.5;
    player.y = closetData.y + 0.5;
    
    // Face the opening direction (toward the corridor to see through the slit)
    // The direction field points from wall to corridor, so we need to face the opposite direction
    // to look out from the interior through the opening
    const [dx, dy] = closetData.direction;
    player.angle = Math.atan2(-dy, -dx);
    
    console.log("Player positioned in closet:", {
        position: [player.x, player.y],
        angle: player.angle,
        closetData: closetData,
        direction: [dx, dy]
    });
    
    // Enter hidden state
    currentGameState = GAME_STATE.HIDDEN;
    player.closetEntryTime = Date.now();
    player.closetExitTime = null;
    player.currentCloset = closetData;
    
    // Play closet opening sound
    playSound('closetOpen', 0.8);
    
    // Show hidden indicator
    if (hiddenIndicator) hiddenIndicator.style.display = 'block';
    
    message.text = "You're hidden in the closet. Press H to exit.";
    message.life = 200;
    
    console.log("Successfully entered closet directly, new state:", currentGameState, "closet:", closetData);
}

function tryToggleHide() {
    console.log("tryToggleHide called, current state:", currentGameState);
    
    // If player is already hidden, handle exit
    if (currentGameState === GAME_STATE.HIDDEN) {
        console.log("Player is hidden, handling exit...");
        handleClosetExit();
        return;
    }
    
    // Handle entering closet (only when in PLAYING state)
    if (currentGameState === GAME_STATE.PLAYING) {
        let playerTileX = Math.floor(player.x);
        let playerTileY = Math.floor(player.y);
        
        // Enhanced closet detection: check if player is on, near, or facing a closet
        const onClosetTile = isOnClosetTile(playerTileX, playerTileY);
        const nearCloset = isNearCloset(playerTileX, playerTileY);
        const facingCloset = isFacingCloset();
        
        console.log("Player at", playerTileX, playerTileY, "onClosetTile:", onClosetTile, "nearCloset:", nearCloset, "facingCloset:", facingCloset);
        
        if (onClosetTile || nearCloset || facingCloset) {
            // Find the closet data
            let closetData = null;
            if (onClosetTile) {
                closetData = findClosetData(playerTileX, playerTileY);
                console.log("Found closet data for onClosetTile:", closetData);
                
                // Fallback: if findClosetData fails, try findNearestCloset
                if (!closetData) {
                    closetData = findNearestCloset(playerTileX, playerTileY);
                    console.log("Fallback to findNearestCloset:", closetData);
                }
            } else if (nearCloset) {
                // Find the closest closet
                closetData = findNearestCloset(playerTileX, playerTileY);
                console.log("Found closet data for nearCloset:", closetData);
            } else if (facingCloset) {
                // Player is facing a closet - find the closet they're facing
                const facingX = Math.floor(player.x + Math.cos(player.angle) * 0.7);
                const facingY = Math.floor(player.y + Math.sin(player.angle) * 0.7);
                closetData = findClosetData(facingX, facingY);
                console.log("Found closet data for facingCloset:", closetData);
                
                // Fallback: if findClosetData fails, try findNearestCloset
                if (!closetData) {
                    closetData = findNearestCloset(playerTileX, playerTileY);
                    console.log("Fallback to findNearestCloset for facingCloset:", closetData);
                }
            }
            
            if (!closetData) {
                console.log("No closet data found - closets available:", closetInteriors);
                message.text = "This closet is not safe to hide in."; message.life = 120;
                return;
            }
            
            // Move player into the closet interior and position them to see out
            player.x = closetData.x + 0.5;
            player.y = closetData.y + 0.5;
            
            // Face the opening direction (toward the corridor to see through the slit)
            // The direction field points from wall to corridor, so we need to face the opposite direction
            // to look out from the interior through the opening
            const [dx, dy] = closetData.direction;
            player.angle = Math.atan2(-dy, -dx);
            
            console.log("Positioned player in closet:", {
                position: [player.x, player.y],
                angle: player.angle,
                closetData: closetData,
                direction: [dx, dy]
            });
            
            // Enter hidden state
            currentGameState = GAME_STATE.HIDDEN;
            player.closetEntryTime = Date.now();
            player.closetExitTime = null;
            player.currentCloset = closetData;
            
            // Play closet opening sound
            playSound('closetOpen', 0.8);
            
            // Show hidden indicator
            if (hiddenIndicator) hiddenIndicator.style.display = 'block';
            
            message.text = "You're hidden in the closet. Press H to exit.";
            message.life = 200;
            
            console.log("Successfully entered closet, new state:", currentGameState, "closet:", closetData);
        } else {
            message.text = "No safe closet nearby to hide in."; message.life = 120;
        }
    }
}

function handleClosetExit() {
    console.log("handleClosetExit called");
    
    let placed = false;
    
    // Use the current closet data if available
    if (player.currentCloset) {
        const closet = player.currentCloset;
        const [dx, dy] = closet.direction;
        
        // Calculate the exit position (in front of the closet)
        // The exit should be on the opposite side of the wall from the interior
        const exitX = closet.facingX - dx;
        const exitY = closet.facingY - dy;
        
        // Enhanced safety check - ensure the exit position is truly safe
        if (exitX >= 0 && exitX < MAP_SIZE && exitY >= 0 && exitY < MAP_SIZE && 
            map[exitY][exitX] === 0 && isPositionAccessible(exitX, exitY) && 
            !isWallCollision(exitX, exitY) && isPositionSafeFromEnemies(exitX, exitY)) {
            
            player.x = exitX + 0.5;
            player.y = exitY + 0.5;
            player.angle = Math.atan2(-dy, -dx); // Face away from the closet
            placed = true;
            console.log("Exited closet using stored data, placed at:", exitX, exitY);
        }
    }
    
    // Fallback: find any safe exit position (considering house shifts)
    if (!placed) {
        let exitPositions = [];
        
        // Find all closet openings
        for (let y = 0; y < MAP_SIZE; y++) {
            for (let x = 0; x < MAP_SIZE; x++) {
                if (map[y][x] === 4) {
                    const directions = [[1,0], [-1,0], [0,1], [0,-1]];
                    for (let [dx, dy] of directions) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
                            // Enhanced safety check considering house shifts
                            if (isPositionAccessible(nx, ny) && !isWallCollision(nx, ny) && isPositionSafeAfterShift(nx, ny)) {
                                exitPositions.push({
                                    x: nx, y: ny,
                                    closetX: x, closetY: y,
                                    dx: dx, dy: dy,
                                    accessibility: countAccessibleNeighbors(nx, ny)
                                });
                            }
                        }
                    }
                }
            }
        }
        
        // Sort by accessibility
        exitPositions.sort((a, b) => b.accessibility - a.accessibility);
        
        // Try to place player
        for (let pos of exitPositions) {
            if (isPositionAccessible(pos.x, pos.y) && !isWallCollision(pos.x, pos.y) && isPositionSafeAfterShift(pos.x, pos.y)) {
                player.x = pos.x + 0.5;
                player.y = pos.y + 0.5;
                player.angle = Math.atan2(-pos.dy, -pos.dx); // Face away from the closet
                placed = true;
                console.log("Exited closet using fallback, placed at:", pos.x, pos.y);
                break;
            }
        }
    }
    
    // Emergency fallback with house shift consideration
    if (!placed) {
        let bestPosition = findBestSafePositionAfterShift();
        if (bestPosition && !isWallCollision(bestPosition.x, bestPosition.y)) {
            player.x = bestPosition.x + 0.5;
            player.y = bestPosition.y + 0.5;
            placed = true;
            console.log("Closet exit emergency fallback position:", bestPosition.x, bestPosition.y);
        } else {
            // Last resort: find any open floor tile
            for (let y = 1; y < MAP_SIZE - 1; y++) {
                for (let x = 1; x < MAP_SIZE - 1; x++) {
                    if (map[y][x] === 0 && !isWallCollision(x, y)) {
                        player.x = x + 0.5;
                        player.y = y + 0.5;
                        placed = true;
                        console.log("Closet exit last resort spawn at:", x, y);
                        break;
                    }
                }
                if (placed) break;
            }
            
            if (!placed) {
                player.x = 1.5;
                player.y = 1.5;
                console.log("Closet exit emergency spawn");
            }
        }
    }
    
    // Reset state
    currentGameState = GAME_STATE.PLAYING;
    player.closetEntryTime = null;
    player.closetExitTime = Date.now();
    player.currentCloset = null; // Clear current closet reference
    if (hiddenIndicator) hiddenIndicator.style.display = 'none';
    
    // Play closet closing sound
    playSound('closetClose', 0.6);
    
    console.log("Successfully exited closet, new state:", currentGameState, "placed at:", player.x, player.y);
}

function useStairs(direction) {
    if (direction === 'up') {
        if (currentFloor < floors.length - 1) {
            currentFloor++;
            map = floors[currentFloor];
            
            // Find stairs down on the new floor
            let stairsDown = null;
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (map[y][x] === 6) { // Stairs down
                        stairsDown = {x: x, y: y};
                        break;
                    }
                }
                if (stairsDown) break;
            }
            
            if (stairsDown) {
                // Find a safe position adjacent to the stairs
                let safePosition = findSafePositionNearStairs(stairsDown.x, stairsDown.y);
                if (safePosition) {
                    player.x = safePosition.x;
                    player.y = safePosition.y;
                    message.text = `You climb to floor ${currentFloor + 1}.`;
                    message.life = 150;
                    const stairVolume = playerAbilities.stealthMode ? 0.3 : 0.6;
                    playSound('footsteps', stairVolume);
                    
                    // Update HUD floor display
                    if (hudFloorEl) hudFloorEl.textContent = `${currentFloor + 1}`;
                    
                    // Reset enemies for new floor
                    enemies = [];
                    const count = enemiesForStage();
                    for (let i = 0; i < count; i++) {
                        let enemySpawn = findRandomEmptyCell(map);
                        if (enemySpawn) {
                            const availableMonsters = getMonsterTypesForStage(stageIndex);
                            const enemyType = availableMonsters[Math.floor(prng() * availableMonsters.length)];
                            const stats = getMonsterStats(enemyType, stageIndex);
                            
                            enemies.push({ 
                                x: enemySpawn.x + 0.5, 
                                y: enemySpawn.y + 0.5, 
                                path: [], 
                                state: 'PATROL',
                                type: enemyType,
                                lastSeenPlayer: null,
                                hearingRange: stats.hearingRange,
                                memory: stats.memory,
                                speed: stats.speed,
                                stealth: stats.stealth,
                                scale: stats.scale,
                                currentFloor: currentFloor // Track which floor this enemy is on
                            });
                        }
                    }
                    
                    // Reset sprites for new floor
                    sprites = [];
                    // Place items on new floor
                    for (let i = 0; i < 2 + Math.floor(prng()*2); i++) {
                        let keyPos = findRandomEmptyCell(map);
                        if (keyPos) {
                            sprites.push({ x: keyPos.x + 0.5, y: keyPos.y + 0.5, type: 'bronzeKey', texture: assets.bronzeKeySprite });
                        }
                    }
                    if (prng() < 0.6) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'flashlight', texture: assets.flashlightSprite }); }
                    if (prng() < 0.6) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'vitamins', texture: assets.vitaminsSprite }); }
                    if (prng() < 0.5) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'lockpick', texture: assets.lockpickSprite }); }
                    
                    console.log(`Successfully moved to floor ${currentFloor + 1} at position ${player.x}, ${player.y}`);
                } else {
                    message.text = "These stairs lead to a dead end!";
                    message.life = 120;
                    currentFloor--; // Go back
                    map = floors[currentFloor];
                }
            } else {
                message.text = "These stairs lead to a dead end!";
                message.life = 120;
                currentFloor--; // Go back
                map = floors[currentFloor];
            }
        } else {
            message.text = "You are already on the top floor.";
            message.life = 120;
        }
    } else if (direction === 'down') {
        if (currentFloor > 0) {
            currentFloor--;
            map = floors[currentFloor];
            
            // Find stairs up on the new floor
            let stairsUp = null;
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (map[y][x] === 5) { // Stairs up
                        stairsUp = {x: x, y: y};
                        break;
                    }
                }
                if (stairsUp) break;
            }
            
            if (stairsUp) {
                // Find a safe position adjacent to the stairs
                let safePosition = findSafePositionNearStairs(stairsUp.x, stairsUp.y);
                if (safePosition) {
                    player.x = safePosition.x;
                    player.y = safePosition.y;
                    message.text = `You descend to floor ${currentFloor + 1}.`;
                    message.life = 150;
                    const stairVolume = playerAbilities.stealthMode ? 0.3 : 0.6;
                    playSound('footsteps', stairVolume);
                    
                    // Update HUD floor display
                    if (hudFloorEl) hudFloorEl.textContent = `${currentFloor + 1}`;
                    
                    // Reset enemies for new floor
                    enemies = [];
                    const count = enemiesForStage();
                    for (let i = 0; i < count; i++) {
                        let enemySpawn = findRandomEmptyCell(map);
                        if (enemySpawn) {
                            const availableMonsters = getMonsterTypesForStage(stageIndex);
                            const enemyType = availableMonsters[Math.floor(prng() * availableMonsters.length)];
                            const stats = getMonsterStats(enemyType, stageIndex);
                            
                            enemies.push({ 
                                x: enemySpawn.x + 0.5, 
                                y: enemySpawn.y + 0.5, 
                                path: [], 
                                state: 'PATROL',
                                type: enemyType,
                                lastSeenPlayer: null,
                                hearingRange: stats.hearingRange,
                                memory: stats.memory,
                                speed: stats.speed,
                                stealth: stats.stealth,
                                scale: stats.scale,
                                currentFloor: currentFloor // Track which floor this enemy is on
                            });
                        }
                    }
                    
                    // Reset sprites for new floor
                    sprites = [];
                    // Place items on new floor
                    for (let i = 0; i < 2 + Math.floor(prng()*2); i++) {
                        let keyPos = findRandomEmptyCell(map);
                        if (keyPos) {
                            sprites.push({ x: keyPos.x + 0.5, y: keyPos.y + 0.5, type: 'bronzeKey', texture: assets.bronzeKeySprite });
                        }
                    }
                    if (prng() < 0.6) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'flashlight', texture: assets.flashlightSprite }); }
                    if (prng() < 0.6) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'vitamins', texture: assets.vitaminsSprite }); }
                    if (prng() < 0.5) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'lockpick', texture: assets.lockpickSprite }); }
                    
                    console.log(`Successfully moved to floor ${currentFloor + 1} at position ${player.x}, ${player.y}`);
                } else {
                    message.text = "These stairs lead to a dead end!";
                    message.life = 120;
                    currentFloor++; // Go back
                    map = floors[currentFloor];
                }
            } else {
                message.text = "These stairs lead to a dead end!";
                message.life = 120;
                currentFloor++; // Go back
                map = floors[currentFloor];
            }
        } else {
            message.text = "You are already on the bottom floor.";
            message.life = 120;
        }
    }
}

function tryOpenDoor() {
    const pTileX = Math.floor(player.x), pTileY = Math.floor(player.y);
    if (map[pTileY][pTileX] === 3) {
        if (player.hasGoldKey) {
            playSound('doorCreak', 0.8);
            setTimeout(() => playSound('doorOpen', 1.0), 500);
            nextStageOrWin();
        } else {
            message.text = 'The golden lock won\'t budge without the key.';
            message.life = 120;
        }
        return;
    }
    // If standing adjacent facing a door, allow open
    const fx = Math.floor(player.x + Math.cos(player.angle) * 0.7);
    const fy = Math.floor(player.y + Math.sin(player.angle) * 0.7);
    if (fx >= 0 && fx < MAP_SIZE && fy >= 0 && fy < MAP_SIZE) {
        if (map[fy][fx] === 3) {
            if (player.hasGoldKey) {
                playSound('doorCreak', 0.8);
                setTimeout(() => playSound('doorOpen', 1.0), 500);
                nextStageOrWin();
            }
            else { message.text = 'You need the gold key.'; message.life = 120; }
        } else if (map[fy][fx] === 2) {
            if (player.hasBronzeKey) { 
                playSound('doorCreak', 0.6);
                setTimeout(() => playSound('doorOpen', 0.8), 300);
                map[fy][fx] = 0; 
                player.hasBronzeKey = false; 
                message.text = 'Bronze door unlocked.'; 
                message.life = 120; 
            }
            else if (inventory.lockpick > 0) { 
                playSound('doorCreak', 0.7);
                setTimeout(() => playSound('doorOpen', 0.9), 400);
                map[fy][fx] = 0; 
                inventory.lockpick -= 1; 
                message.text = 'Picked the lock.'; 
                message.life = 120; 
            }
            else { message.text = 'This door needs a bronze key.'; message.life = 120; }
        }
    }
}

function checkClosetSafety() {
    // Check if player is near a closet that can be safely entered and exited
    const playerTileX = Math.floor(player.x);
    const playerTileY = Math.floor(player.y);
    
    // Check if player is on a closet tile
    if (map[playerTileY][playerTileX] === 4) {
        // Check if there's a safe exit from this closet
        return hasSafeExit(playerTileX, playerTileY);
    }
    
    // Check if player is facing a closet
    const facingX = Math.floor(player.x + Math.cos(player.angle) * 0.7);
    const facingY = Math.floor(player.y + Math.sin(player.angle) * 0.7);
    if (facingX >= 0 && facingX < MAP_SIZE && facingY >= 0 && facingY < MAP_SIZE && map[facingY][facingX] === 4) {
        // Check if there's a safe exit from this closet
        return hasSafeExit(facingX, facingY);
    }
    
    return false;
}

function hasSafeExit(closetX, closetY) {
    // Check all 4 directions for open tiles in front of the closet
    const directions = [[1,0], [-1,0], [0,1], [0,-1]];
    
    for (let [dx, dy] of directions) {
        const nx = closetX + dx;
        const ny = closetY + dy;
        
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            // Check if this exit position is truly accessible and safe from enemies
            if (isPositionAccessible(nx, ny) && isPositionSafeFromEnemies(nx, ny)) {
                // Additional check: ensure there's a path away from the closet
                let hasPathAway = false;
                const pathDirections = [[1,0], [-1,0], [0,1], [0,-1]];
                
                for (let [pdx, pdy] of pathDirections) {
                    const px = nx + pdx;
                    const py = ny + pdy;
                    if (px >= 0 && px < MAP_SIZE && py >= 0 && py < MAP_SIZE && map[py][px] === 0) {
                        if (px !== closetX || py !== closetY) { // Not back into the closet
                            hasPathAway = true;
                            break;
                        }
                    }
                }
                
                if (hasPathAway) {
                    return true;
                }
            }
        }
    }
    
    return false;
}

function isPositionSafeFromEnemies(x, y) {
    // Check if the position is safe from nearby enemies
    const safeDistance = 3; // Minimum distance from enemies
    
    for (let enemy of enemies) {
        if (enemy.currentFloor === currentFloor) {
            const distance = Math.hypot(enemy.x - (x + 0.5), enemy.y - (y + 0.5));
            if (distance < safeDistance) {
                return false;
            }
        }
    }
    
    // Check stalker enemy
    if (stalkerEnemy && stalkerEnemy.currentFloor === currentFloor) {
        const distance = Math.hypot(stalkerEnemy.x - (x + 0.5), stalkerEnemy.y - (y + 0.5));
        if (distance < safeDistance) {
            return false;
        }
    }
    
    return true;
}

// Duplicate function removed - using the one defined earlier


// =============================================================================
// --- CORE GAME LOGIC (UPDATE) ---
// =============================================================================
function handleMovement() {
    if (currentGameState !== GAME_STATE.PLAYING) return;
    let dx = 0, dy = 0;
    
    // Keyboard input
    if (keys['w']) { dx += Math.cos(player.angle); dy += Math.sin(player.angle); }
    if (keys['s']) { dx -= Math.cos(player.angle); dy -= Math.sin(player.angle); }
    if (keys['a']) { dx += Math.cos(player.angle - Math.PI/2); dy += Math.sin(player.angle - Math.PI/2); }
    if (keys['d']) { dx += Math.cos(player.angle + Math.PI/2); dy += Math.sin(player.angle + Math.PI/2); }
    
    // Gamepad input - Fixed movement logic
    if (gamepad && (gamepadState.leftStick.x !== 0 || gamepadState.leftStick.y !== 0)) {
        const stickX = gamepadState.leftStick.x;
        const stickY = gamepadState.leftStick.y;
        
        // Forward/backward movement (fixed Y axis - negative Y is forward)
        if (stickY !== 0) {
            dx += Math.cos(player.angle) * (-stickY);
            dy += Math.sin(player.angle) * (-stickY);
        }
        
        // Strafe movement (corrected X axis)
        if (stickX !== 0) {
            dx += Math.cos(player.angle - Math.PI/2) * stickX;
            dy += Math.sin(player.angle - Math.PI/2) * stickX;
        }
    }
    
    // Right stick for looking with smoothing
    if (gamepad && (gamepadState.rightStick.x !== 0 || gamepadState.rightStick.y !== 0)) {
        const lookSensitivity = 0.02; // Reduced sensitivity for smoother control
        // Fixed inverted gamepad look controls with smoothing
        cameraSmoothing.gamepad.targetAngle -= gamepadState.rightStick.x * lookSensitivity;
    }
    
    // Apply camera smoothing for gamepad
    cameraSmoothing.gamepad.currentAngle += (cameraSmoothing.gamepad.targetAngle - cameraSmoothing.gamepad.currentAngle) * cameraSmoothing.gamepad.smoothing;
    player.angle += cameraSmoothing.gamepad.currentAngle;
    cameraSmoothing.gamepad.targetAngle = 0; // Reset target for next frame
    
    // Apply camera smoothing for mobile
    cameraSmoothing.mobile.currentAngle += (cameraSmoothing.mobile.targetAngle - cameraSmoothing.mobile.currentAngle) * cameraSmoothing.mobile.smoothing;
    player.angle += cameraSmoothing.mobile.currentAngle;
    cameraSmoothing.mobile.targetAngle = 0; // Reset target for next frame
    
    // Mobile input - Fixed movement logic
    if (isMobile && touchState.move) {
        let moveX = touchState.move.currentX - touchState.joyCenter.x;
        let moveY = touchState.move.currentY - touchState.joyCenter.y;
        let dist = Math.min(Math.sqrt(moveX*moveX + moveY*moveY) / 50, 1); // Adjusted for new joystick size
        
        // Debug joystick input
        if (Math.abs(moveX) > 5 || Math.abs(moveY) > 5) {
            console.log("Joystick input:", { moveX, moveY, dist });
        }
        
        // Convert joystick input to world movement relative to player angle
        // Forward/backward based on Y axis (inverted for intuitive control)
        if (moveY !== 0) {
            dx += Math.cos(player.angle) * (-moveY / 50) * 0.6; // Improved sensitivity
            dy += Math.sin(player.angle) * (-moveY / 50) * 0.6; // Improved sensitivity
        }
        
        // Strafe left/right based on X axis
        if (moveX !== 0) {
            dx += Math.cos(player.angle + Math.PI/2) * (moveX / 50) * 0.6; // Fixed direction - use + instead of -
            dy += Math.sin(player.angle + Math.PI/2) * (moveX / 50) * 0.6; // Fixed direction - use + instead of -
        }
    }

    let mag = Math.sqrt(dx*dx + dy*dy);
    if(mag > 0) {
        // Sprint mechanics
        const sprinting = !!keys['shift'] && player.stamina > 0.1;
        const vitBoost = (inventory.vitActiveUntil||0) > Date.now() ? 1.1 : 1; // Reduced vitamin boost
        const panicBoost = (player.panicSpeedBoost||0) > Date.now() ? 1.3 : 1; // Panic mode speed boost
        const crouchModifier = playerAbilities.crouching ? 0.8 : 1; // Less severe crouch penalty
        const speedMul = (player.moveSpeedMultiplier || 1) * (sprinting ? 1.12 : 1) * vitBoost * panicBoost * crouchModifier; // Balanced sprint boost
        dx = dx/mag * MOVE_SPEED * speedMul;
        dy = dy/mag * MOVE_SPEED * speedMul;
        // Stamina update
        if (sprinting) player.stamina = Math.max(0, player.stamina - 0.005);
        else player.stamina = Math.min(1, player.stamina + 0.0035);
    }

    // --- COLLISION FIX: Check X and Y movement separately ---
    let nextX = player.x + dx;
    let nextY = player.y + dy;

    // Check X-axis collision - allow walking over decorative objects and stairs
    let xPadding = dx > 0 ? COLLISION_PADDING : -COLLISION_PADDING;
    const probeX = Math.floor(nextX + xPadding);
    const py = Math.floor(player.y);
    if (probeX >= 0 && probeX < MAP_SIZE && py >= 0 && py < MAP_SIZE && 
        (map[py][probeX] === 0 || map[py][probeX] >= 5)) { // Allow walking over stairs (5,6) and decorative objects (7+)
        player.x = nextX;
    }

    // Check Y-axis collision - allow walking over decorative objects and stairs
    let yPadding = dy > 0 ? COLLISION_PADDING : -COLLISION_PADDING;
    const px = Math.floor(player.x);
    const probeY = Math.floor(nextY + yPadding);
    if (px >= 0 && px < MAP_SIZE && probeY >= 0 && probeY < MAP_SIZE && 
        (map[probeY][px] === 0 || map[probeY][px] >= 5)) { // Allow walking over stairs (5,6) and decorative objects (7+)
        player.y = nextY;
    }
}

function update() {
    // Don't update if game is completely stopped or paused
    if (![GAME_STATE.PLAYING, GAME_STATE.HIDDEN].includes(currentGameState)) return;
    
    // Track player angle at start of update
    const startAngle = player.angle;
    
    // Update gamepad state
    updateGamepadState();
    
    // Update audio
    updateAudio();
    
    // Update visual effects and particles
    updateParticles();
    
    // Update sanity system
    const deltaTime = 1/60; // Assuming 60 FPS
    sanitySystem.update(deltaTime);
    
    handleMovement();

    // Prevent house shifts from happening too frequently (minimum 10 seconds between shifts)
    if (Date.now() - lastShiftTime > currentShiftInterval && (Date.now() - lastShiftTime) > 10000) { 
        console.log(`House shift triggered! Time since last shift: ${Date.now() - lastShiftTime}ms, Interval: ${currentShiftInterval}ms`);
        console.log(`Player position: (${player.x.toFixed(2)}, ${player.y.toFixed(2)}), Angle: ${player.angle.toFixed(3)}`);
        
        // Only shift if the game state is stable (not during rapid player movement)
        if (currentGameState === GAME_STATE.PLAYING) {
            shiftMaze(); 
        } else {
            console.log("Skipping house shift - game state not stable");
        }
    }

    let pTileX = Math.floor(player.x), pTileY = Math.floor(player.y);
    for (let i = sprites.length - 1; i >= 0; i--) {
        let sprite = sprites[i];
        if (Math.floor(sprite.x) === pTileX && Math.floor(sprite.y) === pTileY) {
            if (sprite.type === 'bronzeKey') {
                player.hasBronzeKey = true;
                sprites.splice(i, 1);
                playSound('keyPickup', 0.8);
                message.text = "Bronze key acquired."; message.life = 150;
            } else if (sprite.type === 'goldKey') {
                player.hasGoldKey = true;
                sprites.splice(i, 1);
                playSound('keyPickup', 1.0);
                message.text = "You found the GOLD key!"; message.life = 200;
            } else if (sprite.type === 'flashlight') {
                inventory.flashlight = true;
                sprites.splice(i, 1);
                playSound('itemPickup', 0.7, false, sprite.x, sprite.y);
                message.text = "🔦 Flashlight acquired! Press F to toggle."; message.life = 200;
                if (hudFlash) hudFlash.textContent = 'On';
                if (flashlightStatus) flashlightStatus.textContent = 'On';
            } else if (sprite.type === 'vitamins') {
                inventory.vitamins += 2;
                sprites.splice(i, 1);
                playSound('itemPickup', 0.6, false, sprite.x, sprite.y);
                message.text = "💊 Vitamins acquired! (+2) Press V to use."; message.life = 200;
                if (hudVits) hudVits.textContent = String(inventory.vitamins);
            } else if (sprite.type === 'lockpick') {
                inventory.lockpick += 1;
                sprites.splice(i, 1);
                playSound('itemPickup', 0.8, false, sprite.x, sprite.y);
                message.text = "🔓 Lockpick acquired! (+1) Use on bronze doors."; message.life = 200;
                if (hudPicks) hudPicks.textContent = String(inventory.lockpick);
            } else if (sprite.type === 'smokeBomb') {
                inventory.smokeBomb += 1;
                sprites.splice(i, 1);
                playSound('itemPickup', 0.7, false, sprite.x, sprite.y);
                message.text = "💨 Smoke bomb acquired! (+1) Press Q to use."; message.life = 200;
            } else if (sprite.type === 'noiseMaker') {
                inventory.noiseMaker += 1;
                sprites.splice(i, 1);
                playSound('itemPickup', 0.7, false, sprite.x, sprite.y);
                message.text = "🔊 Noise maker acquired! (+1) Press Z to use."; message.life = 200;
            }
        }
    }
    
    // Check for staircase interaction - show prompts
    if (map[pTileY][pTileX] === 5) { // Stairs up
        message.text = "Press SPACE to climb the stairs"; message.life = 120;
    } else if (map[pTileY][pTileX] === 6) { // Stairs down
        message.text = "Press SPACE to descend the stairs"; message.life = 120;
    }
    
    if (map[pTileY][pTileX] === 3) {
        if (player.hasGoldKey) {
            nextStageOrWin();
        } else { message.text = "A golden symbol adorns the lock."; message.life = 120; }
    } else if (map[pTileY][pTileX] === 2) {
        if (player.hasBronzeKey) {
            // Consume bronze key and clear door
            player.hasBronzeKey = false;
            map[pTileY][pTileX] = 0;
            message.text = "Bronze door unlocked."; message.life = 120;
        } else if (inventory.lockpick > 0) { map[pTileY][pTileX] = 0; inventory.lockpick -= 1; message.text = 'Picked the lock.'; message.life = 120; }
        else { message.text = 'This door needs a bronze key.'; message.life = 120; }
    }
    
    // Rush Event Logic
    const now = Date.now();
    const timeSinceShift = now - lastShiftTime;
    const timeSinceLastRush = now - rushEvent.lastTrigger;
    
    if (!rushEvent.active && timeSinceLastRush > rushEvent.cooldown && timeSinceShift > 10000) {
        // Only trigger rush if not during/right after a shift
        if (prng() < 0.0003) { // Very low chance per frame
            rushEvent.active = true;
            rushEvent.startTime = now;
            rushEvent.lastTrigger = now;
            message.text = "RUSH EVENT! Hide quickly!"; message.life = 200;
            
            // Sanity effect from rush event
            sanitySystem.currentSanity = Math.max(0, sanitySystem.currentSanity + sanitySystem.events.rushEvent);
            
            // Play rush event sound
            playSound('rushEvent', 0.9);
        }
    }
    
    if (rushEvent.active && now - rushEvent.startTime > rushEvent.duration) {
        rushEvent.active = false;
        message.text = "The rush has passed."; message.life = 150;
    }
    
    // Stalker Enemy Logic
    if (!stalkerEnemy && timeSinceShift > 8000) { // Spawn after shift cooldown
        if (prng() < 0.0001) { // Very low chance per frame
            let spawnPos = findRandomEmptyCell(map);
            if (spawnPos) {
                stalkerEnemy = {
                    x: spawnPos.x + 0.5, y: spawnPos.y + 0.5,
                    path: [], lastPathUpdate: 0, lastChase: 0,
                    chaseInterval: 12000 + Math.floor(prng() * 8000), // 12-20s between chases
                    chaseDuration: 4000 + Math.floor(prng() * 8000), // 4-7s chase duration
                    currentFloor: currentFloor // Track which floor this enemy is on
                };
                message.text = "Something stalks you from the shadows..."; message.life = 180;
                
                // Play enemy spawn sound
                playSound('enemyGrowl', 0.7);
            }
        }
    }
    
    if (stalkerEnemy) {
        const timeSinceLastChase = now - stalkerEnemy.lastChase;
        const inChase = timeSinceLastChase < stalkerEnemy.chaseDuration;
        
        if (inChase && currentGameState === GAME_STATE.PLAYING) {
            // Chase mode: aggressive pathfinding
            if (now - stalkerEnemy.lastPathUpdate > 500) {
                stalkerEnemy.path = findPath(Math.floor(stalkerEnemy.x), Math.floor(stalkerEnemy.y), pTileX, pTileY);
                stalkerEnemy.lastPathUpdate = now;
            }
        } else if (timeSinceLastChase > stalkerEnemy.chaseInterval) {
            // Start new chase
            stalkerEnemy.lastChase = now;
            message.text = "The stalker begins its hunt..."; message.life = 120;
        }
        
        // Handle stalker behavior when player is hidden
        if (currentGameState === GAME_STATE.HIDDEN) {
            if (stalkerEnemy.state === 'CHASING' || inChase) {
                // If stalker was chasing, they should search the area
                if (!stalkerEnemy.patrolTarget || Math.hypot(stalkerEnemy.x - stalkerEnemy.patrolTarget.x, stalkerEnemy.y - stalkerEnemy.patrolTarget.y) < 0.5) {
                    // Set new search target near last known player position
                    const searchRadius = 6;
                    const searchAngle = Math.random() * Math.PI * 2;
                    const searchX = player.x + Math.cos(searchAngle) * searchRadius;
                    const searchY = player.y + Math.sin(searchAngle) * searchRadius;
                    
                    // Ensure search target is within bounds and accessible
                    const clampedX = Math.max(1, Math.min(MAP_SIZE - 2, Math.floor(searchX)));
                    const clampedY = Math.max(1, Math.min(MAP_SIZE - 2, Math.floor(searchY)));
                    
                    if (map[clampedY][clampedX] === 0) {
                        stalkerEnemy.patrolTarget = { x: clampedX + 0.5, y: clampedY + 0.5 };
                        stalkerEnemy.path = findPath(Math.floor(stalkerEnemy.x), Math.floor(stalkerEnemy.y), clampedX, clampedY);
                        stalkerEnemy.state = 'SEARCHING';
                    }
                }
            } else {
                // Normal patrol behavior when not chasing
                if (!stalkerEnemy.patrolTarget || Math.hypot(stalkerEnemy.x - stalkerEnemy.patrolTarget.x, stalkerEnemy.y - stalkerEnemy.patrolTarget.y) < 0.5) {
                    // Set new random patrol target
                    const patrolX = 1 + Math.random() * (MAP_SIZE - 2);
                    const patrolY = 1 + Math.random() * (MAP_SIZE - 2);
                    
                    if (map[patrolY][patrolX] === 0) {
                        stalkerEnemy.patrolTarget = { x: patrolX + 0.5, y: patrolY + 0.5 };
                        stalkerEnemy.path = findPath(Math.floor(stalkerEnemy.x), Math.floor(stalkerEnemy.y), patrolX, patrolY);
                    }
                }
            }
        }
        
        // Move stalker
        if (stalkerEnemy.path && stalkerEnemy.path.length > 0) {
            let target = stalkerEnemy.path[0];
            let dx = (target.x + 0.5) - stalkerEnemy.x;
            let dy = (target.y + 0.5) - stalkerEnemy.y;
            let mag = Math.hypot(dx, dy);
            if (mag > 0.1) {
                let speed = inChase ? currentEnemySpeed * 1.2 : currentEnemySpeed * 0.6;
                let moveX = (dx / mag) * speed;
                let moveY = (dy / mag) * speed;
                
                // Collision check for stalker
                let nextX = stalkerEnemy.x + moveX;
                let nextY = stalkerEnemy.y + moveY;
                let xPadding = moveX > 0 ? COLLISION_PADDING : -COLLISION_PADDING;
                let yPadding = moveY > 0 ? COLLISION_PADDING : -COLLISION_PADDING;
                
                const probeX = Math.floor(nextX + xPadding);
                const probeY = Math.floor(nextY + yPadding);
                const currentX = Math.floor(stalkerEnemy.x);
                const currentY = Math.floor(stalkerEnemy.y);
                
                if (probeX >= 0 && probeX < MAP_SIZE && currentY >= 0 && currentY < MAP_SIZE && map[currentY][probeX] === 0) {
                    stalkerEnemy.x = nextX;
                }
                if (currentX >= 0 && currentX < MAP_SIZE && probeY >= 0 && probeY < MAP_SIZE && map[probeY][currentX] === 0) {
                    stalkerEnemy.y = nextY;
                }
            } else {
                stalkerEnemy.path.shift();
            }
        }
        
        // Check collision with player (only if on same floor)
        if (stalkerEnemy.currentFloor === currentFloor) {
            let distToPlayer = Math.hypot(player.x - stalkerEnemy.x, player.y - stalkerEnemy.y);
            const inGrace = (Date.now() - stageStartTime) < (player.graceMs || 0);
            const inPanicInvincibility = (player.panicInvincibility||0) > Date.now();
                    if (currentGameState === GAME_STATE.PLAYING && !inGrace && !inPanicInvincibility && distToPlayer < 0.5) {
            // Add dramatic screen shake before game over
            visualEffects.screenShake = {
                active: true,
                intensity: 15,
                duration: 20
            };
            
            currentGameState = GAME_STATE.GAMEOVER; 
            totalElapsedMs += Date.now() - stageStartTime;
            saveRun(false);
            showRunSummary(false);
            if (hiddenIndicator) hiddenIndicator.style.display = 'none';
        }
        }
    }
    
    // Enhanced Enemy AI for all enemies
    if (enemies.length > 0) {
        console.log(`Processing ${enemies.length} enemies on floor ${currentFloor}`);
    }
    
    for (let enemy of enemies) {
        // Only process enemies on the same floor as player
        if (enemy.currentFloor === currentFloor) {
            let distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
            // Grace period after spawn
            const inGrace = (Date.now() - stageStartTime) < (player.graceMs || 0);
            const inPanicInvincibility = (player.panicInvincibility||0) > Date.now();
            if (currentGameState === GAME_STATE.PLAYING && !inGrace && !inPanicInvincibility && distToPlayer < 0.5) { 
                // Add dramatic screen shake before game over
                visualEffects.screenShake = {
                    active: true,
                    intensity: 15,
                    duration: 20
                };
                
                currentGameState = GAME_STATE.GAMEOVER; 
                totalElapsedMs += Date.now() - stageStartTime;
                saveRun(false);
                showRunSummary(false);
                if (hiddenIndicator) hiddenIndicator.style.display = 'none';
            }
            
            // Check if enemy can hear player footsteps
            if (currentGameState === GAME_STATE.PLAYING && !enemy.blinded) {
                // Check if player is in grace period after leaving closet
                const inGracePeriod = player.closetExitTime && (Date.now() - player.closetExitTime) < player.closetGracePeriod;
                
                if (!inGracePeriod) {
                    const footstepRange = enemy.hearingRange * (playerAbilities.stealthMode ? 0.5 : 1.0);
                    const canHear = distToPlayer <= footstepRange;
                    
                    if (canHear && !enemy.attractedTo) {
                        // Enemy heard player - update last seen position
                        enemy.lastSeenPlayer = { x: player.x, y: player.y, time: Date.now() };
                        enemy.state = 'CHASING';
                        playSound('enemyHear', 0.6, false, enemy.x, enemy.y);
                        
                        // Update path to player (but respect spawn grace period)
                        if (Date.now() - lastEnemyPathUpdateTime > 500) {
                            lastEnemyPathUpdateTime = Date.now();
                            // Only pathfind if not in spawn grace period
                            if (!enemy.spawnTime || (Date.now() - enemy.spawnTime) >= enemy.spawnGracePeriod) {
                                enemy.path = findPath(Math.floor(enemy.x), Math.floor(enemy.y), pTileX, pTileY);
                            }
                        }
                    }
                }
            }
            
            // Handle different enemy states
            if (enemy.state === 'BLINDED' && Date.now() > enemy.blindUntil) {
                enemy.blinded = false;
                enemy.state = 'PATROL';
                enemy.path = [];
            }
            
            if (enemy.state === 'ATTRACTED' && Date.now() > enemy.attractedUntil) {
                enemy.attractedTo = null;
                enemy.state = 'PATROL';
                enemy.path = [];
            }
            
            // Check if enemy is in spawn grace period
            const inSpawnGrace = enemy.spawnTime && (Date.now() - enemy.spawnTime) < enemy.spawnGracePeriod;
            
            // Rush event affects regular enemies (but respect spawn grace period)
            if (rushEvent.active && currentGameState === GAME_STATE.PLAYING && !enemy.blinded && !inSpawnGrace) {
                // Enemies become more aggressive during rush
                if (Date.now() - lastEnemyPathUpdateTime > 300) { // Faster updates
                    lastEnemyPathUpdateTime = Date.now();
                    enemy.path = findPath(Math.floor(enemy.x), Math.floor(enemy.y), pTileX, pTileY);
                }
            } else if (currentGameState === GAME_STATE.PLAYING && Date.now() - lastEnemyPathUpdateTime > currentPathUpdateInterval && !enemy.blinded && !inSpawnGrace) {
                // Only pathfind to player if enemy has actually seen/heard them
                if (enemy.lastSeenPlayer && (Date.now() - enemy.lastSeenPlayer.time) < enemy.memory) {
                    lastEnemyPathUpdateTime = Date.now();
                    enemy.path = findPath(Math.floor(enemy.x), Math.floor(enemy.y), pTileX, pTileY);
                }
            } else if (currentGameState === GAME_STATE.HIDDEN) {
                // Player is hidden - enemies should continue patrolling
                if (enemy.state === 'CHASING') {
                    // If enemy was chasing, they should continue searching the area
                    if (!enemy.patrolTarget || Math.hypot(enemy.x - enemy.patrolTarget.x, enemy.y - enemy.patrolTarget.y) < 0.5) {
                        // Set new patrol target near last seen position
                        const lastSeen = enemy.lastSeenPlayer || { x: player.x, y: player.y };
                        const patrolRadius = 4;
                        const patrolAngle = Math.random() * Math.PI * 2;
                        const patrolX = lastSeen.x + Math.cos(patrolAngle) * patrolRadius;
                        const patrolY = lastSeen.y + Math.sin(patrolAngle) * patrolRadius;
                        
                        // Ensure patrol target is within bounds and accessible
                        const clampedX = Math.max(1, Math.min(MAP_SIZE - 2, Math.floor(patrolX)));
                        const clampedY = Math.max(1, Math.min(MAP_SIZE - 2, Math.floor(patrolY)));
                        
                        if (map[clampedY][clampedX] === 0) {
                            enemy.patrolTarget = { x: clampedX + 0.5, y: clampedY + 0.5 };
                            enemy.path = findPath(Math.floor(enemy.x), Math.floor(enemy.y), clampedX, clampedY);
                            enemy.state = 'PATROLLING';
                        }
                    }
                } else if (enemy.state === 'PATROL' || enemy.state === 'PATROLLING') {
                    // Continue existing patrol or start new one
                    if (!enemy.patrolTarget || Math.hypot(enemy.x - enemy.patrolTarget.x, enemy.y - enemy.patrolTarget.y) < 0.5) {
                        // Set new random patrol target
                        const patrolX = 1 + Math.random() * (MAP_SIZE - 2);
                        const patrolY = 1 + Math.random() * (MAP_SIZE - 2);
                        
                        if (map[patrolY][patrolX] === 0) {
                            enemy.patrolTarget = { x: patrolX + 0.5, y: patrolY + 0.5 };
                            enemy.path = findPath(Math.floor(enemy.x), Math.floor(enemy.y), patrolX, patrolY);
                        }
                    }
                }
            }
            // Enemy movement (only for enemies on same floor)
            if (enemy.path && enemy.path.length > 0) {
                let target = enemy.path[0];
                let dx = (target.x + 0.5) - enemy.x;
                let dy = (target.y + 0.5) - enemy.y;
                let mag = Math.hypot(dx, dy);
                if (mag > 0.1) {
                    let speed = rushEvent.active ? currentEnemySpeed * 1.4 : currentEnemySpeed;
                    let moveX = (dx / mag) * speed;
                    let moveY = (dy / mag) * speed;

                    let nextEnemyX = enemy.x + moveX;
                    let nextEnemyY = enemy.y + moveY;
                    let xPadding = moveX > 0 ? COLLISION_PADDING : -COLLISION_PADDING;
                    let yPadding = moveY > 0 ? COLLISION_PADDING : -COLLISION_PADDING;

                    const eProbeX = Math.floor(nextEnemyX + xPadding);
                    const ey = Math.floor(enemy.y);
                    if (eProbeX >= 0 && eProbeX < MAP_SIZE && ey >= 0 && ey < MAP_SIZE && map[ey][eProbeX] === 0) {
                        enemy.x = nextEnemyX;
                    }
                    const ex = Math.floor(enemy.x);
                    const eProbeY = Math.floor(nextEnemyY + yPadding);
                    if (ex >= 0 && ex < MAP_SIZE && eProbeY >= 0 && eProbeY < MAP_SIZE && map[eProbeY][ex] === 0) {
                        enemy.y = nextEnemyY;
                    }
                } else {
                    enemy.path.shift();
                }
            }
        }
    }
    
    // Closet failsafe: Auto-exit if player stays too long
    if (currentGameState === GAME_STATE.HIDDEN && player.closetEntryTime) {
        const timeInCloset = Date.now() - player.closetEntryTime;
        const CLOSET_TIMEOUT = 15000; // 15 seconds timeout
        
        if (timeInCloset > CLOSET_TIMEOUT) {
            console.log("Closet timeout reached, forcing exit");
            message.text = "You crawled out of that cramped space."; message.life = 150;
            
            // Force exit using the same logic as manual exit
            let placed = false;
            let exitPositions = [];
            
            // Find all closet openings
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (map[y][x] === 4) {
                        const directions = [[1,0], [-1,0], [0,1], [0,-1]];
                        for (let [dx, dy] of directions) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
                                if (isPositionAccessible(nx, ny) && !isWallCollision(nx, ny)) {
                                    exitPositions.push({
                                        x: nx, y: ny,
                                        closetX: x, closetY: y,
                                        dx: dx, dy: dy,
                                        accessibility: countAccessibleNeighbors(nx, ny)
                                    });
                                }
                            }
                        }
                    }
                }
            }
            
            // Sort by accessibility
            exitPositions.sort((a, b) => b.accessibility - a.accessibility);
            
            // Try to place player
            for (let pos of exitPositions) {
                if (isPositionAccessible(pos.x, pos.y) && !isWallCollision(pos.x, pos.y)) {
                    player.x = pos.x + 0.5;
                    player.y = pos.y + 0.5;
                    player.angle = Math.atan2(pos.dy, pos.dx);
                    placed = true;
                    console.log("Auto-exit placed player at:", pos.x, pos.y);
                    break;
                }
            }
            
            // Fallback strategies
            if (!placed) {
                let bestPosition = findBestSafePosition();
                if (bestPosition && !isWallCollision(bestPosition.x, bestPosition.y)) {
                    player.x = bestPosition.x + 0.5;
                    player.y = bestPosition.y + 0.5;
                    placed = true;
                    console.log("Auto-exit fallback position:", bestPosition.x, bestPosition.y);
                }
            }
            
            if (!placed) {
                player.x = 1.5;
                player.y = 1.5;
                console.log("Auto-exit emergency spawn");
            }
            
            // Reset state
            currentGameState = GAME_STATE.PLAYING;
            player.closetEntryTime = null;
            if (hiddenIndicator) hiddenIndicator.style.display = 'none';
            
            // Play closet closing sound
            playSound('closetClose', 0.6);
        }
    }
    
    if (message.life > 0) message.life--;
    if (popupLife > 0) popupLife--;
    
    // Play proximity audio cues
    if (audioCues.enabled) {
        playProximityAudio();
    }
    
    // Check achievements
    achievementSystem.checkAchievements();

    // HUD updates - keep visible during pause
    if (currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.HIDDEN || currentGameState === GAME_STATE.PAUSED) {
        const elapsed = totalElapsedMs + (Date.now() - stageStartTime);
        hudStageEl.textContent = `${Math.min(stageIndex + 1, STAGES.length + 1)}`;
        if (hudFloorEl) hudFloorEl.textContent = `${currentFloor + 1}`;
        hudTimeEl.textContent = msToClock(elapsed);
        if (hudBronzeEl) hudBronzeEl.textContent = player.hasBronzeKey ? '1' : '0';
        if (hudGoldEl) hudGoldEl.textContent = player.hasGoldKey ? 'Yes' : 'No';
        // Exit compass when gold key is acquired
        if (exitCompass) {
            let exitPos = null;
            for (let y=0;y<MAP_SIZE;y++) for (let x=0;x<MAP_SIZE;x++) if (map[y][x]===3) { exitPos={x:x+0.5,y:y+0.5}; break; }
            if (player.hasGoldKey && exitPos) {
                const ang = Math.atan2(exitPos.y - player.y, exitPos.x - player.x) - player.angle;
                const dir = ang > 0 ? (ang > Math.PI/8 ? '→' : '•') : (ang < -Math.PI/8 ? '←' : '•');
                exitCompass.textContent = `Exit: ${dir}`;
            } else {
                exitCompass.textContent = 'Exit: ?';
            }
        }
        if (hudFlash) hudFlash.textContent = inventory.flashlight ? 'On' : 'Off';
        if (flashlightStatus) flashlightStatus.textContent = inventory.flashlight ? 'On' : 'Off';
        if (hudVits) hudVits.textContent = String(inventory.vitamins);
        if (hudPicks) hudPicks.textContent = String(inventory.lockpick);
        if (hudSmoke) hudSmoke.textContent = String(inventory.smokeBomb);
        if (hudNoise) hudNoise.textContent = String(inventory.noiseMaker);
        if (rushWarning) rushWarning.style.display = rushEvent.active ? 'block' : 'none';
        
        // Update panic button indicator
        if (panicButtonIndicator) {
            panicButtonIndicator.style.display = sanitySystem.currentSanity <= sanitySystem.criticalSanityThreshold ? 'block' : 'none';
        }
        

        
        // Update sanity bar
        if (sanityFill) {
            const sanityPercent = (sanitySystem.currentSanity / sanitySystem.maxSanity) * 100;
            sanityFill.style.width = sanityPercent + '%';
            
            // Change color based on sanity level
            if (sanitySystem.currentSanity <= sanitySystem.criticalSanityThreshold) {
                sanityFill.style.background = '#FF0000'; // Red for critical
            } else if (sanitySystem.currentSanity <= sanitySystem.lowSanityThreshold) {
                sanityFill.style.background = '#FF8C00'; // Orange for low
            } else {
                sanityFill.style.background = '#8B0000'; // Dark red for normal
            }
        }
        
        // Update sanity HUD text
        if (hudSanity) {
            hudSanity.textContent = Math.round(sanitySystem.currentSanity);
        }
        
        // Show stairs indicator
        const playerTileX = Math.floor(player.x);
        const playerTileY = Math.floor(player.y);
        if (map[playerTileY] && map[playerTileY][playerTileX] === 5) {
            message.text = `You are on stairs up. Press SPACE to climb to floor ${currentFloor + 2}.`;
            message.life = 60;
        } else if (map[playerTileY] && map[playerTileY][playerTileX] === 6) {
            message.text = `You are on stairs down. Press SPACE to descend to floor ${currentFloor}.`;
            message.life = 60;
        }
        
        // Show stage and floor info in debug area
        if (stageIndex >= 1) {
            ctx.font = '14px Courier New';
            ctx.textAlign = 'left';
            ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
            ctx.fillText(`Stage ${stageIndex + 1}: ${STAGES[stageIndex - 1]}`, 220, 200);
            ctx.fillText(`Floors: ${currentFloor + 1}/${maxFloors}`, 220, 220);
            ctx.fillText(`Stairs: ${floorConnections.length} connections`, 220, 240);
            
            // Show mansion indicator for stage 5+
            if (stageIndex >= 4) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.fillText(`You entered the mansion from the basement.`, 220, 260);
                ctx.fillStyle = 'rgba(255, 255, 0, 0.8)'; // Reset color
            }
        }
        
        // Show hidden state reminder
        if (currentGameState === GAME_STATE.HIDDEN && hiddenIndicator) {
            hiddenIndicator.style.display = 'block';
        }
        
        // Show crouch state indicator
        if (crouchIndicator) {
            if (playerAbilities.crouching) {
                crouchIndicator.style.display = 'block';
            } else {
                crouchIndicator.style.display = 'none';
            }
        }
        
        // Show grace period indicator
        if (gracePeriodIndicator) {
            const inGracePeriod = player.closetExitTime && (Date.now() - player.closetExitTime) < player.closetGracePeriod;
            if (inGracePeriod) {
                gracePeriodIndicator.style.display = 'block';
            } else {
                gracePeriodIndicator.style.display = 'none';
            }
        }
        
        // Show pause state indicator
        if (pauseIndicator) {
            if (currentGameState === GAME_STATE.PAUSED) {
                pauseIndicator.style.display = 'block';
            } else {
                pauseIndicator.style.display = 'none';
            }
        }
        
        // Update shift timer
        if (shiftTimer) {
            if (currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.HIDDEN) {
                const timeUntilShift = Math.max(0, currentShiftInterval - (Date.now() - lastShiftTime));
                const seconds = Math.ceil(timeUntilShift / 1000);
                let affixInfo = '';
                if (currentAffix === 'Labyrinthine') {
                    affixInfo = ' (Labyrinthine)';
                }
                const currentInterval = Math.ceil(currentShiftInterval / 1000);
                const baseInterval = Math.ceil(SHIFT_INTERVAL / 1000);
                if (currentInterval !== baseInterval) {
                    affixInfo += ` [${currentInterval}s]`;
                }
                shiftTimer.textContent = `Next shift: ${seconds}s (Stage ${stageIndex + 1})${affixInfo}`;
                
                // Change color based on urgency
                if (seconds <= 10) {
                    shiftTimer.style.color = '#ff4444'; // Red when close
                } else if (seconds <= 30) {
                    shiftTimer.style.color = '#ffaa00'; // Orange when medium
                } else {
                    shiftTimer.style.color = '#ffaa00'; // Default orange
                }
            } else if (currentGameState === GAME_STATE.MENU) {
                shiftTimer.textContent = 'Next shift: --';
                shiftTimer.style.color = '#666';
            } else {
                shiftTimer.textContent = 'Next shift: --';
                shiftTimer.style.color = '#ffaa00';
            }
        }
    }
    
    // Check if player angle changed unexpectedly during update
    if (Math.abs(player.angle - startAngle) > 0.001) {
        console.log(`Player angle changed during update: ${startAngle.toFixed(6)} -> ${player.angle.toFixed(6)}`);
        console.log(`This suggests something other than mouse movement is modifying the angle`);
    }
} // End of update function

function renderHiddenSlitView(slitY, slitHeight) {
    // Render an enhanced view through the closet slit
    // Show walls, enemies, and corridors for better visibility
    
    const centerX = canvas.width / 2;
    const centerY = slitY + slitHeight / 2;
    
    // Render walls through the slit with extended range for corridor visibility
    for (let i = 0; i < canvas.width; i += 3) { // Reduced pixel skip for better detail
        const rayAngle = (player.angle - FOV / 3) + (i / canvas.width) * (FOV / 1.5); // Wider FOV for slit
        const rayDirX = Math.cos(rayAngle), rayDirY = Math.sin(rayAngle);
        let mapX = Math.floor(player.x), mapY = Math.floor(player.y);
        let deltaDistX = Math.abs(1 / (rayDirX === 0 ? 1e-6 : rayDirX)), deltaDistY = Math.abs(1 / (rayDirY === 0 ? 1e-6 : rayDirY));
        let sideDistX, sideDistY;
        let stepX, stepY, side;
        
        if (rayDirX < 0) { stepX = -1; sideDistX = (player.x - mapX) * deltaDistX; } 
        else { stepX = 1; sideDistX = (mapX + 1.0 - player.x) * deltaDistX; }
        if (rayDirY < 0) { stepY = -1; sideDistY = (mapY + 1.0 - player.y) * deltaDistY; } 
        else { stepY = 1; sideDistY = (mapY + 1.0 - player.y) * deltaDistY; }
        
        let hit = 0;
        let steps = 0;
        while (hit === 0 && steps++ < 12) { // Increased range for better corridor visibility
            if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; } 
            else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
            if (mapY < 0 || mapY >= MAP_SIZE || mapX < 0 || mapX >= MAP_SIZE) { hit = 1; break; }
            if (map[mapY][mapX] > 0) hit = map[mapY][mapX];
        }
        
        if (hit > 0) {
            let perpWallDist = (side === 0) ? (mapX - player.x + (1 - stepX) / 2) / rayDirX : (mapY - player.y + (1 - stepY) / 2) / rayDirY;
            const lineHeight = (slitHeight / Math.max(perpWallDist, 0.0001)) * 0.6; // Slightly taller walls
            const drawStart = centerY - lineHeight / 2;
            const drawEnd = centerY + lineHeight / 2;
            
            if (drawStart < drawEnd) {
                // Enhanced wall colors for better visibility
                let wallColor;
                switch(hit) {
                    case 1: wallColor = '#444'; break; // Regular walls
                    case 2: wallColor = '#8B4513'; break; // Bronze doors
                    case 3: wallColor = '#FFD700'; break; // Gold doors
                    case 4: wallColor = '#654321'; break; // Closets
                    default: wallColor = '#555'; break;
                }
                ctx.fillStyle = wallColor;
                ctx.fillRect(i, drawStart, 3, drawEnd - drawStart);
            }
        }
    }
    
    // Render enemies through the slit with extended range for corridor visibility
    for (let enemy of enemies) {
        // Only show enemies on the same floor
        if (enemy.currentFloor !== currentFloor) continue;
        
        const enemyX = enemy.x - player.x;
        const enemyY = enemy.y - player.y;
        const enemyDist = Math.hypot(enemyX, enemyY);
        if (enemyDist < 6) { // Increased range from 3 to 6 for corridor visibility
            const enemyAngle = Math.atan2(enemyY, enemyX) - player.angle;
            if (Math.abs(enemyAngle) <= FOV / 2) { // Wider angle for better visibility
                const enemyScreenX = Math.tan(enemyAngle) * canvas.width / 2;
                const enemyHeight = (slitHeight / enemyDist) * 0.7;
                const enemyWidth = enemyHeight * 0.8;
                
                const enemyDrawX = centerX + enemyScreenX - enemyWidth / 2;
                const enemyDrawY = centerY - enemyHeight / 2;
                
                if (enemyDrawX >= 0 && enemyDrawX < canvas.width) {
                    // Add subtle glow effect for enemies
                    ctx.shadowColor = 'rgba(255, 0, 0, 0.3)';
                    ctx.shadowBlur = 4;
                    ctx.globalAlpha = 0.9;
                    ctx.drawImage(assets.enemySprite, enemyDrawX, enemyDrawY, enemyWidth, enemyHeight);
                    ctx.globalAlpha = 1.0;
                    ctx.shadowBlur = 0;
                }
            }
        }
    }
    
    // Render stalker if present (same floor only)
    if (stalkerEnemy && stalkerEnemy.currentFloor === currentFloor) {
        const enemyX = stalkerEnemy.x - player.x;
        const enemyY = stalkerEnemy.y - player.y;
        const enemyDist = Math.hypot(enemyX, enemyY);
        if (enemyDist < 8) { // Even longer range for stalker
            const enemyAngle = Math.atan2(enemyY, enemyX) - player.angle;
            if (Math.abs(enemyAngle) <= FOV / 2) {
                const enemyScreenX = Math.tan(enemyAngle) * canvas.width / 2;
                const enemyHeight = (slitHeight / enemyDist) * 0.8;
                const enemyWidth = enemyHeight * 0.8;
                
                const enemyDrawX = centerX + enemyScreenX - enemyWidth / 2;
                const enemyDrawY = centerY - enemyHeight / 2;
                
                if (enemyDrawX >= 0 && enemyDrawX < canvas.width) {
                    // Special effect for stalker
                    ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
                    ctx.shadowBlur = 6;
                    ctx.globalAlpha = 0.7;
                    ctx.drawImage(assets.enemySprite, enemyDrawX, enemyDrawY, enemyWidth, enemyHeight);
                    ctx.globalAlpha = 1.0;
                    ctx.shadowBlur = 0;
                }
            }
        }
    }
    
    // Add subtle ambient lighting to show corridor structure
    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
    ctx.fillRect(0, slitY, canvas.width, slitHeight);
}

// =============================================================================
// --- RENDERING ---
// =============================================================================
function render() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (currentGameState === GAME_STATE.WON || currentGameState === GAME_STATE.GAMEOVER) {
        // Clear any closet state when showing end game screen
        if (player && player.closetEntryTime) {
            player.closetEntryTime = null;
            player.closetExitTime = null;
        }
        if (hiddenIndicator) hiddenIndicator.style.display = 'none';
        
        mainMenu.style.opacity = '1';
        mainMenu.style.pointerEvents = 'auto';
        mainMenu.querySelector('h1').textContent = (currentGameState === GAME_STATE.WON) ? "YOU ESCAPED" : "YOU WERE CAUGHT";
        mainMenu.querySelector('p').textContent = (currentGameState === GAME_STATE.WON) ? "But the memory of the house will never leave you." : "Your sanity is forfeit.";
        // Hide HUD when showing end game screen
        if (hud) hud.style.display = 'none';
        return;
    }
    
    if (currentGameState === GAME_STATE.MENU) return;
    
    // Keep rendering during pause to maintain HUD visibility
    // Note: Game state is PAUSED during pause, but rendering continues
    
    // Safety check: ensure closet state is properly cleared when not hidden
    if (currentGameState !== GAME_STATE.HIDDEN && player && player.closetEntryTime) {
        player.closetEntryTime = null;
        player.closetExitTime = null;
        if (hiddenIndicator) hiddenIndicator.style.display = 'none';
    }
    
    if (currentGameState === GAME_STATE.HIDDEN && player && player.closetEntryTime) {
        // Horizontal slit view through closet door
        ctx.fillStyle = "rgba(0,0,0,0.95)";
        ctx.fillRect(0,0, canvas.width, canvas.height);
        
        // Create a horizontal slit in the center of the screen
        const slitHeight = Math.max(30, canvas.height * 0.12); // Even wider slit for better visibility
        const slitY = canvas.height/2 - slitHeight/2;
        
        // Clear the slit area to show the world
        ctx.clearRect(0, slitY, canvas.width, slitHeight);
        
        // Add subtle dark edges to the slit for realism
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fillRect(0, slitY - 2, canvas.width, 2);
        ctx.fillRect(0, slitY + slitHeight, canvas.width, 2);
        
        // Render a very limited view of the world through the slit
        renderHiddenSlitView(slitY, slitHeight);
        
        // Show enemy detection message if enemies are visible through the slit
        let enemiesVisible = 0;
        for (let enemy of enemies) {
            if (enemy.currentFloor === currentFloor) {
                const enemyDist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
                if (enemyDist < 6) {
                    enemiesVisible++;
                }
            }
        }
        
        if (stalkerEnemy && stalkerEnemy.currentFloor === currentFloor) {
            const stalkerDist = Math.hypot(stalkerEnemy.x - player.x, stalkerEnemy.y - player.y);
            if (stalkerDist < 8) {
                enemiesVisible++;
            }
        }
        
        if (enemiesVisible > 0) {
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.font = '14px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(`⚠️ ${enemiesVisible} enemy${enemiesVisible > 1 ? 'ies' : ''} visible through slit`, canvas.width / 2, slitY - 10);
        }
        
        return;
    }
    
    let zBuffer = [];
    const rayStep = Math.max(1, Math.floor(canvas.width / 800)); // Adaptive ray step for performance
    for (let i = 0; i < canvas.width; i += rayStep) {
        const rayAngle = (player.angle - FOV / 2) + (i / canvas.width) * FOV;
        const rayDirX = Math.cos(rayAngle), rayDirY = Math.sin(rayAngle);
        let mapX = Math.floor(player.x), mapY = Math.floor(player.y);
        let deltaDistX = Math.abs(1 / (rayDirX === 0 ? 1e-6 : rayDirX)), deltaDistY = Math.abs(1 / (rayDirY === 0 ? 1e-6 : rayDirY));
        let sideDistX, sideDistY;
        let stepX, stepY, side;

        if (rayDirX < 0) { stepX = -1; sideDistX = (player.x - mapX) * deltaDistX; } 
        else { stepX = 1; sideDistX = (mapX + 1.0 - player.x) * deltaDistX; }
        if (rayDirY < 0) { stepY = -1; sideDistY = (player.y - mapY) * deltaDistY; } 
        else { stepY = 1; sideDistY = (mapY + 1.0 - player.y) * deltaDistY; }
        
        let hit = 0;
        let steps = 0;
        while (hit === 0 && steps++ < MAX_RAY_STEPS) {
            if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; } 
            else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
            if (mapY < 0 || mapY >= MAP_SIZE || mapX < 0 || mapX >= MAP_SIZE) { hit = 1; break; }
            if (map[mapY][mapX] > 0) hit = map[mapY][mapX];
        }
        
        let perpWallDist = (side === 0) ? (mapX - player.x + (1 - stepX) / 2) / rayDirX : (mapY - player.y + (1 - stepY) / 2) / rayDirY;
        // Fill zBuffer for all pixels in this ray step
        for (let j = 0; j < rayStep && i + j < canvas.width; j++) {
            zBuffer[i + j] = perpWallDist;
        }

        const lineHeight = (canvas.height / Math.max(perpWallDist, 0.0001));
        const drawStart = -lineHeight / 2 + canvas.height / 2;
        
        let wallX = (side === 0) ? player.y + perpWallDist * rayDirY : player.x + perpWallDist * rayDirX;
        wallX -= Math.floor(wallX);
        let texX = Math.floor(wallX * 64);
        
        let texture;
        switch(hit) {
            case 2: texture = assets.bronzeDoorTexture; break;
            case 3: texture = assets.doorTexture; break;
            case 4: texture = assets.closetTexture; break;
            case 5: texture = assets.stairsUpTexture; break;
            case 6: texture = assets.stairsDownTexture; break;
            case 7: texture = assets.torchTexture; break;
            case 8: texture = assets.bonesTexture; break;
            case 9: texture = assets.bloodStainTexture; break;
            case 10: texture = assets.cobwebTexture; break;
            case 11: texture = assets.altarTexture; break;
            case 12: texture = assets.cageTexture; break;
            default: 
                // Use mansion wall texture for stages 5+
                if (stageIndex >= 4 && assets.mansionWallTexture) {
                    texture = assets.mansionWallTexture;
                } else {
                    texture = assets.wallTexture;
                }
                break;
        }

        ctx.drawImage(texture, texX, 0, 1, 64, i, drawStart, rayStep, lineHeight);
        
        const darkness = Math.min(Math.max(perpWallDist / 10, 0), 1);
        ctx.fillStyle = `rgba(0,0,0,${darkness})`;
        ctx.fillRect(i, drawStart, rayStep, lineHeight);
    }
    
    const enemySprites = enemies.map(e => ({
        x: e.x, 
        y: e.y, 
        type: 'enemy', 
        texture: assets.enemySprite,
        inSpawnGrace: e.spawnTime && (Date.now() - e.spawnTime) < e.spawnGracePeriod,
        floor: e.currentFloor,
        scale: e.scale || 1.0
    }));
    
    // Enemy floor info cached for performance
    const allSprites = [...sprites, ...enemySprites];
    allSprites.forEach(s => s.dist = Math.hypot(s.x-player.x, s.y-player.y));
    allSprites.sort((a,b) => b.dist - a.dist);
    
    // Sprite rendering optimized for performance
    for(let sprite of allSprites) {
        // Distance culling for performance
        if (sprite.dist > 15) continue; // Skip sprites that are too far away
        let relX = sprite.x - player.x;
        let relY = sprite.y - player.y;
        
        let angleToSprite = Math.atan2(relY, relX);
        let angleDiff = player.angle - angleToSprite;

        // Normalize angle difference
        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        if (Math.abs(angleDiff) < FOV / 2 + 0.2) { // 0.2 is a small grace margin
            const spriteDist = sprite.dist * Math.cos(angleDiff);
            const spriteHeight = canvas.height / spriteDist;
            const spriteScreenX = canvas.width / 2 + Math.tan(-angleDiff) * (canvas.width / 2) / Math.tan(FOV / 2);
            
            const drawStartY = canvas.height/2 - spriteHeight/2;
            // Scale sprite types
            let scale = 1;
            if (sprite.type === 'container') scale = 0.35; // Made containers even smaller
            if (sprite.type === 'bronzeKey' || sprite.type === 'goldKey') scale = 0.45; // Keys at requested scale
            if (sprite.type === 'flashlight' || sprite.type === 'vitamins' || sprite.type === 'lockpick') scale = 0.3; // Make items smaller
            if (sprite.type === 'enemy' && sprite.scale) scale = sprite.scale; // Use monster-specific scale
            const spriteWidth = spriteHeight * scale;
            const drawStartX = spriteScreenX - spriteWidth / 2;

            for (let stripe = Math.floor(drawStartX); stripe < Math.floor(drawStartX + spriteWidth); stripe++) {
                // --- RENDERING FIX: Only draw sprite pixel if it's closer than the wall ---
                if (stripe >= 0 && stripe < canvas.width && spriteDist < zBuffer[stripe]) {
                    let texX = Math.floor(64 * (stripe - drawStartX) / spriteWidth);
                    
                    // Special rendering for enemies in spawn grace period
                    if (sprite.type === 'enemy' && sprite.inSpawnGrace) {
                        ctx.globalAlpha = 0.4; // Make them semi-transparent
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.3)'; // Add green tint
                        ctx.fillRect(stripe, drawStartY, 1, spriteHeight);
                    }
                    
                    ctx.globalAlpha = sprite.inSpawnGrace ? 0.6 : 1; // Reduce opacity for grace period enemies
                    ctx.drawImage(sprite.texture, texX, 0, 1, 64, stripe, drawStartY, 1, spriteHeight);
                    ctx.globalAlpha = 1; // Reset alpha
                }
            }
        }
    }
    
    // Render stalker enemy
    if (stalkerEnemy) {
        const stalkerX = stalkerEnemy.x - player.x;
        const stalkerY = stalkerEnemy.y - player.y;
        const stalkerDist = Math.hypot(stalkerX, stalkerY);
        if (stalkerDist > 0.1) {
            const stalkerAngle = Math.atan2(stalkerY, stalkerX) - player.angle;
            if (Math.abs(stalkerAngle) <= FOV / 2) {
                const stalkerScreenX = Math.tan(stalkerAngle) * canvas.width / 2;
                const stalkerHeight = (canvas.height / stalkerDist) * 0.9;
                const stalkerWidth = stalkerHeight * 0.8;
                
                const stalkerDrawX = canvas.width / 2 + stalkerScreenX - stalkerWidth / 2;
                const stalkerDrawY = canvas.height / 2 - stalkerHeight / 2;
                
                if (stalkerDist < zBuffer[Math.floor(stalkerDrawX)]) {
                    // Stalker has a darker, more menacing appearance
                    ctx.globalAlpha = 0.8;
                    ctx.drawImage(assets.enemySprite, stalkerDrawX, stalkerDrawY, stalkerWidth, stalkerHeight);
                    ctx.globalAlpha = 1.0;
                }
            }
        }
    }
    
    // Enhanced lighting system with dynamic effects
    let lightRadius = inventory.flashlight ? 0.85 : 0.6;
    let lightIntensity = 1.0;
    
    // Add light flicker effect when sanity is low
    if (sanitySystem.currentSanity <= sanitySystem.lowSanityThreshold) {
        lightIntensity = 0.7 + Math.sin(Date.now() * 0.01) * 0.3;
        lightRadius *= lightIntensity;
    }
    
    // Add screen shake effect
    let shakeX = 0, shakeY = 0;
    if (visualEffects.screenShake.active) {
        shakeX = (Math.random() - 0.5) * visualEffects.screenShake.intensity;
        shakeY = (Math.random() - 0.5) * visualEffects.screenShake.intensity;
        visualEffects.screenShake.duration--;
        if (visualEffects.screenShake.duration <= 0) {
            visualEffects.screenShake.active = false;
        }
    }
    
    // Create enhanced lighting gradient
    const gradient = ctx.createRadialGradient(
        canvas.width / 2 + shakeX, 
        canvas.height / 2 + shakeY, 
        0, 
        canvas.width / 2 + shakeX, 
        canvas.height / 2 + shakeY, 
        canvas.width * lightRadius
    );
    
    // Adjust gradient based on sanity and effects
    let baseDarkness = 0.8 - (settings.bright || 0);
    if (sanitySystem.currentSanity <= sanitySystem.criticalSanityThreshold) {
        baseDarkness += 0.2; // Darker when sanity is critical
    }
    
    gradient.addColorStop(0, 'rgba(0,0,0,0)');
    gradient.addColorStop(0.6, `rgba(0,0,0,${baseDarkness * 0.5})`);
    gradient.addColorStop(0.8, `rgba(0,0,0,${baseDarkness})`);
    gradient.addColorStop(1, 'rgba(0,0,0,1)');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Render particles and visual effects
    renderParticles();
    
    // Add blood drips when sanity is critically low
    if (sanitySystem.currentSanity <= sanitySystem.criticalSanityThreshold && Math.random() < 0.01) {
        visualEffects.bloodDrips.push({
            x: Math.random() * canvas.width,
            y: 0,
            life: 120,
            maxLife: 120,
            alpha: 1.0
        });
    }
    
    // Add shadow waves during house shifts
    if (Date.now() - lastShiftTime < 2000) {
        if (Math.random() < 0.1) {
            visualEffects.shadowWaves.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: 0,
                life: 60,
                maxLife: 60,
                alpha: 1.0
            });
        }
    }
    
    if(message.life > 0) {
        ctx.font = '24px Courier New';
        ctx.textAlign = 'center';
        ctx.fillStyle = `rgba(255, 255, 0, ${message.life/100})`;
        ctx.fillText(message.text, canvas.width / 2, canvas.height - 50);
    }

    // Debug info for stairs - moved to avoid HUD overlap
    if (currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.HIDDEN || currentGameState === GAME_STATE.PAUSED) {
        ctx.font = '16px Courier New';
        ctx.textAlign = 'left';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        
        // Position debug info to the right of the HUD to avoid overlap
        const debugX = 220; // Right of HUD
        const debugY = 30;
        let debugLine = 0;
        
        ctx.fillText(`Floor: ${currentFloor + 1}`, debugX, debugY + (debugLine++ * 20));
        ctx.fillText(`Floor Connections: ${floorConnections.length}`, debugX, debugY + (debugLine++ * 20));
        
        // Show exit status
        let exitOnCurrentFloor = false;
        for (let y = 0; y < MAP_SIZE; y++) {
            for (let x = 0; x < MAP_SIZE; x++) {
                if (map[y][x] === 3) {
                    exitOnCurrentFloor = true;
                    break;
                }
            }
            if (exitOnCurrentFloor) break;
        }
        
        if (exitOnCurrentFloor) {
            ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
            ctx.fillText(`Exit: On Current Floor`, debugX, debugY + (debugLine++ * 20));
        } else if (floorConnections.length > 0) {
            ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
            ctx.fillText(`Exit: On Floor ${maxFloors} (Use Stairs)`, debugX, debugY + (debugLine++ * 20));
        } else {
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.fillText(`Exit: ERROR - Not Found!`, debugX, debugY + (debugLine++ * 20));
        }
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; // Reset color
        
        // Show stair positions on current floor
        let stairsUp = 0, stairsDown = 0;
        for (let y = 0; y < MAP_SIZE; y++) {
            for (let x = 0; x < MAP_SIZE; x++) {
                if (map[y][x] === 5) stairsUp++;
                if (map[y][x] === 6) stairsDown++;
            }
        }
        ctx.fillText(`Stairs Up: ${stairsUp}`, debugX, debugY + (debugLine++ * 20));
        ctx.fillText(`Stairs Down: ${stairsDown}`, debugX, debugY + (debugLine++ * 20));
        
        // Show player position
        ctx.fillText(`Player: ${Math.floor(player.x)}, ${Math.floor(player.y)}`, debugX, debugY + (debugLine++ * 20));
        
        // Show current tile type
        const playerTileX = Math.floor(player.x);
        const playerTileY = Math.floor(player.y);
        const tileType = map[playerTileY] ? map[playerTileY][playerTileX] : 'undefined';
        ctx.fillText(`Tile: ${tileType}`, debugX, debugY + (debugLine++ * 20));
        
        // Show closet safety indicator
        if (currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.PAUSED) {
            const nearCloset = checkClosetSafety();
            if (nearCloset) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.fillText(`🕳️ Safe closet nearby - Press H to hide`, debugX, debugY + (debugLine++ * 20));
            }
            
            // Show nearby items indicator
            const nearbyItems = sprites.filter(s => {
                const dist = Math.hypot(s.x - player.x, s.y - player.y);
                return dist < 1.5 && s.type !== 'container';
            });
            if (nearbyItems.length > 0) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                ctx.fillText(`💎 Items nearby - Walk over to pick up`, debugX, debugY + (debugLine++ * 20));
            }
        }
    }

    // Popup fade handled in DOM for smoothness; keep life for timing if needed

    // Minimap (bottom-right)
    const mmSize = Math.min(180, Math.min(canvas.width, canvas.height) * 0.24);
    const cellSize = mmSize / MAP_SIZE;
    const mmX = canvas.width - mmSize - 16;
    const mmY = canvas.height - mmSize - 16;
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(mmX - 6, mmY - 6, mmSize + 12, mmSize + 12);
    for (let y = 0; y < MAP_SIZE; y++) {
        for (let x = 0; x < MAP_SIZE; x++) {
            const val = map[y][x];
            if (val === 0) ctx.fillStyle = '#222';
            else if (val === 3) ctx.fillStyle = '#4a1'; // Exit
            else if (val === 4) ctx.fillStyle = '#173'; // Closet
            else if (val === 5) ctx.fillStyle = '#FFD700'; // Stairs up - Bright gold
            else if (val === 6) ctx.fillStyle = '#FF8C00'; // Stairs down - Dark orange
            else if (val === 7) ctx.fillStyle = '#FF4500'; // Torch
            else if (val === 8) ctx.fillStyle = '#F5F5DC'; // Bones
            else if (val === 9) ctx.fillStyle = '#8B0000'; // Blood
            else if (val === 10) ctx.fillStyle = '#F5F5DC'; // Cobweb
            else if (val === 11) ctx.fillStyle = '#2F4F4F'; // Altar
            else if (val === 12) ctx.fillStyle = '#696969'; // Cage
            else ctx.fillStyle = '#555';
            ctx.fillRect(mmX + x * cellSize, mmY + y * cellSize, cellSize, cellSize);
            
            // Add distinctive symbols for special tiles
            if (val === 5) { // Stairs up
                ctx.fillStyle = '#000';
                ctx.font = `${Math.max(8, cellSize * 0.6)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('↑', mmX + x * cellSize + cellSize/2, mmY + y * cellSize + cellSize/2);
            } else if (val === 6) { // Stairs down
                ctx.fillStyle = '#000';
                ctx.font = `${Math.max(8, cellSize * 0.6)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('↓', mmX + x * cellSize + cellSize/2, mmY + y * cellSize + cellSize/2);
            } else if (val === 3) { // Exit
                ctx.fillStyle = '#000';
                ctx.font = `${Math.max(8, cellSize * 0.6)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('E', mmX + x * cellSize + cellSize/2, mmY + y * cellSize + cellSize/2);
            } else if (val === 4) { // Closet
                ctx.fillStyle = '#000';
                ctx.font = `${Math.max(8, cellSize * 0.6)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('C', mmX + x * cellSize + cellSize/2, mmY + y * cellSize + cellSize/2);
            }
        }
    }
    
    // Draw sprites: different colors for different types
    for (let s of sprites) {
        if (s.type === 'bronzeKey' || s.type === 'goldKey') {
            ctx.fillStyle = '#FFD700'; // Gold for keys
        } else if (s.type === 'flashlight') {
            ctx.fillStyle = '#FF6347'; // Orange for flashlight
        } else if (s.type === 'vitamins') {
            ctx.fillStyle = '#32CD32'; // Green for vitamins
        } else if (s.type === 'lockpick') {
            ctx.fillStyle = '#FF69B4'; // Pink for lockpicks
        } else if (s.type === 'smokeBomb') {
            ctx.fillStyle = '#808080'; // Gray for smoke bombs
        } else if (s.type === 'noiseMaker') {
            ctx.fillStyle = '#FF4500'; // Orange for noise makers
        } else if (s.type === 'container') {
            ctx.fillStyle = '#8B4513'; // Brown for containers
        } else {
            ctx.fillStyle = '#FFD700'; // Default gold
        }
        ctx.fillRect(mmX + (s.x) * cellSize - 2, mmY + (s.y) * cellSize - 2, 4, 4);
    }
    // Draw enemies in red
    ctx.fillStyle = '#a22';
    for (let e of enemies) {
        ctx.fillRect(mmX + (e.x) * cellSize - 2, mmY + (e.y) * cellSize - 2, 4, 4);
    }
    // Draw stalker in dark red
    if (stalkerEnemy) {
        ctx.fillStyle = '#600';
        ctx.fillRect(mmX + (stalkerEnemy.x) * cellSize - 2, mmY + (stalkerEnemy.y) * cellSize - 2, 4, 4);
    }
    // Draw player in cyan
    ctx.fillStyle = '#0ff';
    ctx.fillRect(mmX + (player.x) * cellSize - 2, mmY + (player.y) * cellSize - 2, 4, 4);
    

    // Keen Eye: draw line to key direction
    if (player.keenEye) {
        const key = sprites.find(s => s.type === 'key');
        if (key) {
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
            ctx.beginPath();
            ctx.moveTo(mmX + player.x * cellSize, mmY + player.y * cellSize);
            ctx.lineTo(mmX + key.x * cellSize, mmY + key.y * cellSize);
            ctx.stroke();
        }
    }
    
    // Render flashlight in player's right hand
    if (inventory.flashlight && currentGameState === GAME_STATE.PLAYING) {
        const handX = canvas.width - 120; // Right side of screen
        const handY = canvas.height - 80; // Bottom area
        const flashlightWidth = 40;
        const flashlightHeight = 60;
        
        // Draw flashlight sprite in player's hand
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.drawImage(assets.flashlightSprite, handX, handY, flashlightWidth, flashlightHeight);
        
        // Add subtle glow effect when flashlight is on
        if (inventory.flashlight) {
            ctx.shadowColor = 'rgba(255, 255, 200, 0.3)';
            ctx.shadowBlur = 8;
            ctx.drawImage(assets.flashlightSprite, handX, handY, flashlightWidth, flashlightHeight);
        }
        ctx.restore();
    }

    // Add minimap legend
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    
    const legendX = mmX;
    const legendY = mmY + mmSize + 20;
    let legendLine = 0;
    
    // Legend for special tiles
    ctx.fillStyle = '#FFD700';
    ctx.fillRect(legendX, legendY + legendLine * 15, 8, 8);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText('↑ Stairs Up', legendX + 12, legendY + legendLine * 15 + 6);
    legendLine++;
    
    ctx.fillStyle = '#FF8C00';
    ctx.fillRect(legendX, legendY + legendLine * 15, 8, 8);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText('↓ Stairs Down', legendX + 12, legendY + legendLine * 15 + 6);
    legendLine++;
    
    ctx.fillStyle = '#4a1';
    ctx.fillRect(legendX, legendY + legendLine * 15, 8, 8);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText('E Exit', legendX + 12, legendY + legendLine * 15 + 6);
    legendLine++;
    
    ctx.fillStyle = '#173';
    ctx.fillRect(legendX, legendY + legendLine * 15, 8, 8);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText('C Closet', legendX + 12, legendY + legendLine * 15 + 6);
    legendLine++;
    

    
    // Legend for items
    ctx.fillStyle = '#FFD700';
    ctx.fillRect(legendX + 120, legendY, 4, 4);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText('Keys', legendX + 120 + 12, legendY + 6);
    legendLine = 1;
    
    ctx.fillStyle = '#a22';
    ctx.fillRect(legendX + 120, legendY + legendLine * 15, 4, 4);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText('Enemies', legendX + 120 + 12, legendY + legendLine * 15 + 6);
    legendLine++;
    
    ctx.fillStyle = '#0ff';
    ctx.fillRect(legendX + 120, legendY + legendLine * 15, 4, 4);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText('You', legendX + 120 + 12, legendY + legendLine * 15 + 6);
}

// =============================================================================
// --- MAIN GAME LOOP ---
// =============================================================================
// Frame rate limiting for stable 60 FPS
let lastFrameTime = 0;
const targetFPS = 60;
const frameInterval = 1000 / targetFPS;

function gameLoop(currentTime) {
    const deltaTime = currentTime - lastFrameTime;
    
    if (deltaTime >= frameInterval) {
        update();
        render();
        lastFrameTime = currentTime - (deltaTime % frameInterval);
    }
    
    requestAnimationFrame(gameLoop);
}

// --- START THE GAME ---
document.addEventListener('DOMContentLoaded', () => {
    try {
        console.log('DOM loaded, initializing game...');
        initializePRNG();
        generateAssets();
        setupInputs();
        initGamepad();
        initAudio();
        loadDPISettings(); // Load DPI settings after DOM is ready
        renderLeaderboard();
        mainMenu.style.opacity = '1';
        mainMenu.style.pointerEvents = 'auto';
        currentGameState = GAME_STATE.MENU;
        console.log('Game initialized, starting game loop...');
        gameLoop();
    } catch (error) {
        console.error('Error starting game:', error);
        alert('Game failed to start. Check console for details.');
    }
});

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

function resizeCanvasScale() {
    const scale = Math.max(0.5, Math.min(1, settings.scale||1));
    canvas.width = Math.floor(window.innerWidth * scale);
    canvas.height = Math.floor(window.innerHeight * scale);
}

function initGamepad() {
    // Listen for gamepad connections
    window.addEventListener("gamepadconnected", (e) => {
        console.log("Gamepad connected:", e.gamepad.id);
        gamepad = e.gamepad;
        message.text = "Controller connected!";
        message.life = 150;
    });
    
    window.addEventListener("gamepaddisconnected", (e) => {
        console.log("Gamepad disconnected:", e.gamepad.id);
        if (gamepad && gamepad.index === e.gamepad.index) {
            gamepad = null;
            message.text = "Controller disconnected";
            message.life = 150;
        }
    });
    
    // Poll for gamepads on startup
    if (navigator.getGamepads) {
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                gamepad = gamepads[i];
                console.log("Found existing gamepad:", gamepad.id);
                break;
            }
        }
    }
}

function updateGamepadState() {
    if (!gamepad) return;
    
    // Block gamepad input if game is paused
    if (currentGameState === GAME_STATE.PAUSED) return;
    
    // Update gamepad state
    const gp = navigator.getGamepads()[gamepad.index];
    if (!gp) {
        gamepad = null;
        return;
    }
    
    // Update sticks with deadzone
    const deadzone = 0.1;
    gamepadState.leftStick.x = Math.abs(gp.axes[0]) > deadzone ? gp.axes[0] : 0;
    gamepadState.leftStick.y = Math.abs(gp.axes[1]) > deadzone ? gp.axes[1] : 0;
    gamepadState.rightStick.x = Math.abs(gp.axes[2]) > deadzone ? gp.axes[2] : 0;
    gamepadState.rightStick.y = Math.abs(gp.axes[3]) > deadzone ? gp.axes[3] : 0;
    
    // Update buttons
    gamepadState.lastButtons = [...gamepadState.buttons];
    for (let i = 0; i < gp.buttons.length && i < 16; i++) {
        gamepadState.buttons[i] = gp.buttons[i].pressed;
    }
    
    // Handle button presses
    if (gamepadState.buttons[0] && !gamepadState.lastButtons[0]) { // A button
        tryInteract();
    }
    if (gamepadState.buttons[1] && !gamepadState.lastButtons[1]) { // B button
        tryToggleHide();
    }
    if (gamepadState.buttons[2] && !gamepadState.lastButtons[2]) { // X button
        tryOpenDoor();
    }
    if (gamepadState.buttons[3] && !gamepadState.lastButtons[3]) { // Y button
        if (inventory.flashlight) {
            inventory.flashlight = !inventory.flashlight;
            if (hudFlash) hudFlash.textContent = inventory.flashlight ? 'On' : 'Off';
        if (flashlightStatus) flashlightStatus.textContent = inventory.flashlight ? 'On' : 'Off';
        }
    }
    if (gamepadState.buttons[4] && !gamepadState.lastButtons[4]) { // LB
        if (inventory.vitamins > 0) {
            inventory.vitamins -= 1;
            inventory.vitActiveUntil = Date.now() + 6000;
            message.text = 'Speed surge!';
            message.life = 120;
            if (hudVits) hudVits.textContent = String(inventory.vitamins);
        }
    }
    if (gamepadState.buttons[5] && !gamepadState.lastButtons[5]) { // RB - Crouch
        playerAbilities.crouching = !playerAbilities.crouching;
        playerAbilities.stealthMode = playerAbilities.crouching;
        message.text = playerAbilities.crouching ? 'Crouching - Stealth mode active' : 'Standing - Normal mode';
        message.life = 120;
    }
}

// Helper functions for closet exit validation
function checkClosetSafety() {
    // Check if player is near a safe closet
    const playerTileX = Math.floor(player.x);
    const playerTileY = Math.floor(player.y);
    
    // Check if player is on or near a closet
    if (isOnClosetTile(playerTileX, playerTileY) || isNearCloset(playerTileX, playerTileY)) {
        return true;
    }
    
    return false;
}

function isPositionSafeAfterShift(x, y) {
    // Check if a position is safe considering potential house shifts
    // This ensures the player won't be trapped after exiting a closet
    
    // Check if position has multiple escape routes
    const directions = [[1,0], [-1,0], [0,1], [0,-1]];
    let escapeRoutes = 0;
    
    for (let [dx, dy] of directions) {
        const nx = x + dx;
        const ny = y + dy;
        
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            // Check if this neighbor also has escape routes
            let neighborEscapeRoutes = 0;
            for (let [dx2, dy2] of directions) {
                const nx2 = nx + dx2;
                const ny2 = ny + dy2;
                if (nx2 >= 0 && nx2 < MAP_SIZE && ny2 >= 0 && ny2 < MAP_SIZE && map[ny2][nx2] === 0) {
                    if (nx2 !== x || ny2 !== y) { // Not back to original position
                        neighborEscapeRoutes++;
                    }
                }
            }
            
            if (neighborEscapeRoutes >= 1) {
                escapeRoutes++;
            }
        }
    }
    
    // Position is safe if it has at least 2 escape routes
    return escapeRoutes >= 2;
}

function findBestSafePositionAfterShift() {
    // Find the best safe position considering house shifts
    let bestPosition = null;
    let bestScore = -1;
    
    for (let y = 1; y < MAP_SIZE - 1; y++) {
        for (let x = 1; x < MAP_SIZE - 1; x++) {
            if (map[y][x] === 0 && isPositionAccessible(x, y) && isPositionSafeAfterShift(x, y)) {
                const accessibility = countAccessibleNeighbors(x, y);
                if (accessibility > bestScore) {
                    bestScore = accessibility;
                    bestPosition = {x, y};
                }
            }
        }
    }
    
    return bestPosition;
}

function isPositionAccessible(x, y) {
    // Check if position is within bounds and open
    if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE || map[y][x] !== 0) {
        return false;
    }
    
    // Check if position has at least 2 open neighbors (not a dead end)
    let openNeighbors = 0;
    const directions = [[1,0], [-1,0], [0,1], [0,-1]];
    
    for (let [dx, dy] of directions) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            openNeighbors++;
        }
    }
    
    return openNeighbors >= 2;
}

function isPositionWellConnected(x, y) {
    // Check if position has good connectivity to the rest of the map
    // Count accessible neighbors and ensure path to multiple areas
    let accessibleNeighbors = 0;
    let hasPathToOpenArea = false;
    
    // Check immediate neighbors
    for (let [dx, dy] of [[1,0], [-1,0], [0,1], [0,-1]]) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            accessibleNeighbors++;
            
            // Check if this neighbor leads to a more open area
            for (let [dx2, dy2] of [[1,0], [-1,0], [0,1], [0,-1]]) {
                const nx2 = nx + dx2;
                const ny2 = ny + dy2;
                if (nx2 >= 0 && nx2 < MAP_SIZE && ny2 >= 0 && ny2 < MAP_SIZE && map[ny2][nx2] === 0) {
                    hasPathToOpenArea = true;
                    break;
                }
            }
        }
    }
    
    // For stage 1, be less strict about connectivity requirements
    if (stageIndex === 0) {
        return accessibleNeighbors >= 1; // Only need 1 accessible neighbor for stage 1
    }
    
    // Position is well connected if it has at least 2 accessible neighbors and leads to open areas
    return accessibleNeighbors >= 2 && hasPathToOpenArea;
}

function countAccessibleNeighbors(x, y) {
    let count = 0;
    const directions = [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]];
    
    for (let [dx, dy] of directions) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            count++;
        }
    }
    
    return count;
}

function findSafePositionNearStairs(stairsX, stairsY) {
    // Look for open positions adjacent to the stairs
    const directions = [[1,0], [-1,0], [0,1], [0,-1]];
    
    for (let [dx, dy] of directions) {
        const nx = stairsX + dx;
        const ny = stairsY + dy;
        
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            // Check if this position is accessible and safe
            if (isPositionAccessible(nx, ny) && !isWallCollision(nx, ny)) {
                return { x: nx + 0.5, y: ny + 0.5 };
            }
        }
    }
    
    // If no adjacent position works, try diagonal positions
    const diagonalDirections = [[1,1], [1,-1], [-1,1], [-1,-1]];
    for (let [dx, dy] of diagonalDirections) {
        const nx = stairsX + dx;
        const ny = stairsY + dy;
        
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            if (isPositionAccessible(nx, ny) && !isWallCollision(nx, ny)) {
                return { x: nx + 0.5, y: ny + 0.5 };
            }
        }
    }
    
    // Final fallback: find any safe position within 2 tiles
    for (let radius = 2; radius <= 3; radius++) {
        for (let dx = -radius; dx <= radius; dx++) {
            for (let dy = -radius; dy <= radius; dy++) {
                if (Math.abs(dx) + Math.abs(dy) === radius) { // Diamond pattern
                    const nx = stairsX + dx;
                    const ny = stairsY + dy;
                    if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
                        if (isPositionAccessible(nx, ny) && !isWallCollision(nx, ny)) {
                            return { x: nx + 0.5, y: ny + 0.5 };
                        }
                    }
                }
            }
        }
    }
    
    return null;
}

function findBestSafePosition() {
    let bestPosition = null;
    let bestScore = -1;
    
    for (let y = 1; y < MAP_SIZE - 1; y++) {
        for (let x = 1; x < MAP_SIZE - 1; x++) {
            if (map[y][x] === 0 && isPositionAccessible(x, y)) {
                const accessibility = countAccessibleNeighbors(x, y);
                if (accessibility > bestScore) {
                    bestScore = accessibility;
                    bestPosition = {x, y};
                }
            }
        }
    }
    
    return bestPosition;
}

function isWallCollision(x, y) {
    // Check if the position would cause the player to be inside a wall
    // This includes checking the player's collision bounds
    const playerRadius = COLLISION_PADDING;
    
    // Check all corners of the player's collision box
    const corners = [
        [x - playerRadius, y - playerRadius],
        [x + playerRadius, y - playerRadius],
        [x - playerRadius, y + playerRadius],
        [x + playerRadius, y + playerRadius]
    ];
    
    for (let [cx, cy] of corners) {
        const mapX = Math.floor(cx);
        const mapY = Math.floor(cy);
        
        if (mapY < 0 || mapY >= MAP_SIZE || mapX < 0 || mapX >= MAP_SIZE) {
            return true; // Out of bounds
        }
        
        if (map[mapY][mapX] === 1) { // Wall
            return true;
        }
    }
    
    return false;
}

// =============================================================================
// Initialize the game
console.log('Script loaded successfully!');

// The game will be initialized when the DOM is loaded
// All initialization is handled in the DOMContentLoaded event listener
</script>
</body>
</html>
