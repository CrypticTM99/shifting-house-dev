<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>The Shifting House</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', Courier, monospace;
            height: 100%;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas */
        }
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            color: #ccc;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            cursor: pointer;
            transition: opacity 0.5s;
            pointer-events: auto;
            z-index: 150;
        }
        #main-menu h1 {
            font-size: 3em;
            color: #a00;
            text-shadow: 2px 2px 4px #000;
        }
        #main-menu p {
            font-size: 1.2em;
            margin: 10px 20px;
        }
        #main-menu .controls {
            margin-top: 20px;
            font-size: 1em;
            color: #888;
        }
        #menu-extras {
            margin-top: 16px;
            display: flex;
            gap: 10px;
            align-items: center;
            pointer-events: auto;
        }
        #seed-input {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.2);
            color: #ddd;
            padding: 6px 8px;
            border-radius: 4px;
        }
        .menu-button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.25);
            color: #eee;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        /* --- Leaderboard --- */
        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 10px 12px;
            text-align: left;
            z-index: 50;
        }
        #leaderboard h3 {
            margin: 0 0 8px 0;
            font-size: 16px;
            color: #eee;
        }
        #leaderboard ul {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 200px;
            overflow: auto;
        }
        #leaderboard li {
            font-size: 12px;
            color: #bbb;
            padding: 4px 0;
            border-bottom: 1px dashed rgba(255,255,255,0.08);
        }
        #leaderboard li:last-child { border-bottom: none; }
        
        /* --- HUD & Popup --- */
        #hud {
            position: absolute;
            top: 12px;
            left: 12px;
            color: #ddd;
            background: rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 14px;
            pointer-events: none;
            z-index: 100;
            max-width: 200px;
            word-wrap: break-word;
        }
        #hud .bar {
            width: 160px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            margin-top: 6px;
            border-radius: 4px;
            overflow: hidden;
        }
        #hud .bar > div { height: 100%; background: #2ecc71; width: 100%; }
        #hud .affix { margin-top: 6px; color: #bbb; }
        
        /* Ensure HUD text doesn't get cut off */
        #hud div {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 16px 22px;
            color: #fff;
            background: rgba(160, 0, 0, 0.85);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            font-size: 28px;
            text-shadow: 2px 2px 6px #000;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            z-index: 300;
        }

        /* --- Settings & Pause --- */
        #pause-menu, #settings-panel, #summary-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10,10,10,0.9);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #ddd;
            padding: 16px 18px;
            min-width: 320px;
            display: none;
            pointer-events: auto;
            z-index: 200;
        }
        .row { display: flex; align-items: center; justify-content: space-between; margin: 6px 0; }
        .row input[type=range] { width: 180px; }
        .menu-actions { display: flex; gap: 8px; justify-content: center; margin-top: 12px; }
        .menu-button { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.25); color: #eee; padding: 6px 10px; border-radius: 4px; cursor: pointer; }
        
        /* --- Mobile Controls --- */
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%; /* Increased from 35% */
            display: none; /* Hidden by default */
            pointer-events: auto;
            z-index: 75;
        }
        #joystick-zone {
            position: absolute;
            left: 0;
            bottom: 0;
            width: 50%;
            height: 100%;
        }
        #joystick-base {
            position: absolute;
            bottom: 60px; /* Increased from 40px */
            left: 50%;
            transform: translateX(-50%);
            width: 140px; /* Increased from 120px */
            height: 140px; /* Increased from 120px */
            background: rgba(128, 128, 128, 0.4); /* More visible */
            border: 2px solid rgba(255,255,255,0.6); /* Added border */
            border-radius: 50%;
        }
        #joystick-thumb {
            position: absolute;
            width: 70px; /* Increased from 60px */
            height: 70px; /* Increased from 60px */
            background: rgba(200, 200, 200, 0.7); /* More visible */
            border: 2px solid rgba(255,255,255,0.8); /* Added border */
            border-radius: 50%;
            top: 35px; /* Adjusted for new size */
            left: 35px; /* Adjusted for new size */
            transition: transform 0.1s;
        }
        #action-buttons {
            position: absolute;
            right: 8%; /* Adjusted from 5% */
            bottom: 60px; /* Increased from 40px */
            display: flex;
            flex-direction: column;
            gap: 15px; /* Added gap between buttons */
        }
        .action-button {
            width: 90px; /* Increased from 80px */
            height: 90px; /* Increased from 80px */
            background: rgba(200, 200, 200, 0.6); /* More visible */
            border: 3px solid rgba(255,255,255,0.7); /* Thicker border */
            border-radius: 50%;
            color: #fff;
            font-size: 20px; /* Increased from 18px */
            font-weight: bold; /* Added weight */
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            text-shadow: 1px 1px 2px #000; /* Added text shadow */
            box-shadow: 0 4px 8px rgba(0,0,0,0.3); /* Added shadow */
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="main-menu">
            <h1>The Shifting House</h1>
            <p>It hunts. It changes. It remembers.</p>
            <p style="font-size: 1.5em; color: #fff; margin-top: 30px;">[ CLICK TO BEGIN ]</p>
            <div class="controls">
                <p><strong>Desktop:</strong> WASD to Move | MOUSE to Look | E to Hide</p>
                <p><strong>Mobile:</strong> Use On-Screen Controls</p>
            </div>
            <div id="menu-extras">
                <input id="seed-input" placeholder="Custom seed (optional)" />
                <button id="daily-btn" class="menu-button">Daily Challenge</button>
            </div>
            <div id="leaderboard">
                <h3>Recent Runs</h3>
                <ul id="leaderboard-list"></ul>
            </div>
        </div>
         <div id="mobile-controls">
            <div id="joystick-zone">
                <div id="joystick-base">
                    <div id="joystick-thumb"></div>
                </div>
            </div>
            <div id="action-buttons">
                <div class="action-button" id="hide-button">Hide</div>
                <div class="action-button" id="interact-button">Interact</div>
                <div class="action-button" id="door-button">Door</div>
                <div class="action-button" id="flashlight-button">Light</div>
            </div>
        </div>
        <div id="hud" style="display:none">
            <div>Stage: <span id="hud-stage">1</span> | Floor: <span id="hud-floor">1</span></div>
            <div>Time: <span id="hud-time">0:00.000</span></div>
            <div>Bronze: <span id="hud-bronze">0</span> | Gold: <span id="hud-gold">No</span></div>
            <div class="affix">Affix: <span id="hud-affix">None</span></div>
            <div class="bar"><div id="stamina-fill" style="width:100%"></div></div>
            <div id="exit-compass" style="margin-top:6px;color:#aaa;">Exit: ?</div>
            <div id="hidden-indicator" style="margin-top:6px;color:#00ff00;font-size:14px;font-weight:bold;display:none;">üï≥Ô∏è HIDDEN - Press H to exit</div>
            <div id="crouch-indicator" style="margin-top:6px;color:#478d8d;font-size:14px;font-weight:bold;display:none;">ü¶Ü CROUCHING - Your footsteps are quieter</div>
            <div id="pause-indicator" style="margin-top:6px;color:#ffaa00;font-size:14px;font-weight:bold;display:none;">‚è∏Ô∏è PAUSED</div>
            <div style="margin-top:6px;color:#aaa;font-size:12px;">Floor: <span id="hud-floor">1</span> | F: Flashlight <span id="hud-flash">Off</span> | Vits: <span id="hud-vits">0</span> | Picks: <span id="hud-picks">0</span></div>
            <div style="margin-top:6px;color:#aaa;font-size:12px;">Q: Smoke <span id="hud-smoke">0</span> | Z: Noise <span id="hud-noise">0</span> | C: Crouch</div>
            <div id="rush-warning" style="margin-top:6px;color:#ff4444;font-size:14px;font-weight:bold;display:none;">‚ö†Ô∏è RUSH! HIDE NOW!</div>
        </div>
        <div id="popup"></div>
        <div id="pause-menu">
            <h3 style="margin:0 0 8px 0;">Paused</h3>
            <div class="menu-actions">
                <button id="btn-resume" class="menu-button">Resume</button>
                <button id="btn-restart" class="menu-button">Restart</button>
                <button id="btn-settings" class="menu-button">Settings</button>
            </div>
        </div>
        <div id="settings-panel">
            <h3 style="margin:0 0 8px 0;">Settings</h3>
            <div class="row"><label>Sensitivity</label><input id="opt-sens" type="range" min="0.5" max="3" step="0.1" value="1"></div>
            <div class="row"><label>Brightness</label><input id="opt-bright" type="range" min="0" max="0.8" step="0.05" value="0"></div>
            <div class="row"><label>Audio Volume</label><input id="opt-vol" type="range" min="0" max="1" step="0.05" value="0.5"></div>
            <div class="row"><label>Proximity Audio</label><input id="opt-audio-cues" type="checkbox" checked></div>
            <div class="row"><label>Resolution Scale</label><input id="opt-scale" type="range" min="0.5" max="1" step="0.05" value="1"></div>
            <div class="menu-actions">
                <button id="btn-close-settings" class="menu-button">Close</button>
            </div>
        </div>
        <div id="summary-panel">
            <h3 style="margin:0 0 8px 0;">Run Summary</h3>
            <div id="summary-text" style="font-size:12px; color:#bbb;"></div>
            <div class="menu-actions"><button id="btn-summary-close" class="menu-button">Close</button></div>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
// =============================================================================
// --- GAME SETUP AND INITIALIZATION ---
// =============================================================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiLayer = document.getElementById('ui-layer');
const mainMenu = document.getElementById('main-menu');
const mobileControls = document.getElementById('mobile-controls');
const hud = document.getElementById('hud');
const hudStageEl = document.getElementById('hud-stage');
const hudFloorEl = document.getElementById('hud-floor');
const hudTimeEl = document.getElementById('hud-time');
const hudBronzeEl = document.getElementById('hud-bronze');
const hudGoldEl = document.getElementById('hud-gold');
const hudAffixEl = document.getElementById('hud-affix');
const staminaFill = document.getElementById('stamina-fill');
const popupEl = document.getElementById('popup');
const leaderboardList = document.getElementById('leaderboard-list');
const seedInput = document.getElementById('seed-input');
const dailyBtn = document.getElementById('daily-btn');
const exitCompass = document.getElementById('exit-compass');
const pauseMenu = document.getElementById('pause-menu');
const settingsPanel = document.getElementById('settings-panel');
const summaryPanel = document.getElementById('summary-panel');
const btnResume = document.getElementById('btn-resume');
const btnRestart = document.getElementById('btn-restart');
const btnSettings = document.getElementById('btn-settings');
const btnCloseSettings = document.getElementById('btn-close-settings');
const btnSummaryClose = document.getElementById('btn-summary-close');
const optSens = document.getElementById('opt-sens');
const optBright = document.getElementById('opt-bright');
const optVol = document.getElementById('opt-vol');
const optScale = document.getElementById('opt-scale');
const optAudioCues = document.getElementById('opt-audio-cues');
const summaryText = document.getElementById('summary-text');
const hudFlash = document.getElementById('hud-flash');
const hudVits = document.getElementById('hud-vits');
const hudPicks = document.getElementById('hud-picks');
const hudSmoke = document.getElementById('hud-smoke');
const hudNoise = document.getElementById('hud-noise');
const rushWarning = document.getElementById('rush-warning');
const hiddenIndicator = document.getElementById('hidden-indicator');
const crouchIndicator = document.getElementById('crouch-indicator');
const pauseIndicator = document.getElementById('pause-indicator');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- GAME STATE ---
const GAME_STATE = { MENU: 'MENU', PLAYING: 'PLAYING', HIDDEN: 'HIDDEN', PAUSED: 'PAUSED', GAMEOVER: 'GAMEOVER', WON: 'WON' };
let currentGameState = GAME_STATE.MENU;

// --- CONSTANTS & SETTINGS ---
const MAP_SIZE = 21;
const MOVE_SPEED = 0.07;
const ROTATION_SPEED = 0.002;
const BASE_ENEMY_SPEED = 0.036;
const SHIFT_INTERVAL = 45000;
const ENEMY_PATH_UPDATE_INTERVAL = 1000;
const FOV = Math.PI / 3;
const COLLISION_PADDING = 0.18; // How far to stay from walls
const MAX_RAY_STEPS = MAP_SIZE * MAP_SIZE;

// --- STAGES & RUN ---
const STAGES = ["Second stage", "Third stage", "Bloody stage", "Fourth stage"]; // After clearing stage 1
let stageIndex = 0; // 0 => first stage
let runStartTime = 0;
let stageStartTime = 0;
let totalElapsedMs = 0;
let currentAffix = "None";
let currentShiftInterval = SHIFT_INTERVAL;
let currentEnemySpeed = BASE_ENEMY_SPEED;
let currentPathUpdateInterval = ENEMY_PATH_UPDATE_INTERVAL;
let prng = Math.random;

// Polyfill for Math.imul if not available
if (!Math.imul) {
    Math.imul = function(a, b) {
        const ah = (a >>> 16) & 0xffff;
        const al = a & 0xffff;
        const bh = (b >>> 16) & 0xffff;
        const bl = b & 0xffff;
        return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
    };
}

// Initialize with a default seed to ensure prng works from the start
function initializePRNG() {
    const defaultSeed = hashStringToSeed('default');
    prng = mulberry32(defaultSeed);
}

// --- MULTI-FLOOR SYSTEM ---
let currentFloor = 0;
let floors = []; // Array of floor maps
let floorConnections = []; // Staircase connections between floors
let maxFloors = 3; // Maximum number of floors per stage

// --- ASSETS ---
let assets = {
    wallTexture: null,
    doorTexture: null,
    closetTexture: null,
    enemySprite: null,
    bronzeKeySprite: null,
    goldKeySprite: null,
    containerClosed: null,
    containerOpen: null,
    bronzeDoorTexture: null,
    flashlightSprite: null,
    vitaminsSprite: null,
    lockpickSprite: null,
    stairsUpTexture: null,
    stairsDownTexture: null,
    torchTexture: null,
    bonesTexture: null,
    cobwebTexture: null,
    bloodStainTexture: null,
    altarTexture: null,
    cageTexture: null,
    smokeBombSprite: null,
    noiseMakerSprite: null,
    trapSprite: null,
    movingWallSprite: null,
    mansionWallTexture: null
};

function generateAssets() {
    const TILE_SIZE = 64;
    const genCanvas = document.createElement('canvas');
    genCanvas.width = TILE_SIZE; genCanvas.height = TILE_SIZE;
    const gCtx = genCanvas.getContext('2d');

    // Wall Texture
    gCtx.fillStyle = '#4a4a4a'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.strokeStyle = '#333'; gCtx.lineWidth = 2;
    for (let i = 0; i < TILE_SIZE; i += 16) {
        gCtx.beginPath(); gCtx.moveTo(0, i); gCtx.lineTo(TILE_SIZE, i); gCtx.stroke();
        for (let j = 0; j < TILE_SIZE; j += 32) {
            let offset = (i / 16) % 2 === 0 ? 0 : 16;
            gCtx.beginPath(); gCtx.moveTo(j + offset, i); gCtx.lineTo(j + offset, i + 16); gCtx.stroke();
        }
    }
    assets.wallTexture = new Image(); assets.wallTexture.src = genCanvas.toDataURL();

    // Mansion Wall Texture (for stages 5+)
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#8B7355'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.strokeStyle = '#654321'; gCtx.lineWidth = 1;
    // Add elegant paneling
    for (let i = 0; i < TILE_SIZE; i += 16) {
        gCtx.beginPath(); gCtx.moveTo(0, i); gCtx.lineTo(TILE_SIZE, i); gCtx.stroke();
    }
    for (let j = 0; j < TILE_SIZE; j += 16) {
        gCtx.beginPath(); gCtx.moveTo(j, 0); gCtx.lineTo(j, TILE_SIZE); gCtx.stroke();
    }
    // Add decorative corners
    gCtx.fillStyle = '#654321';
    gCtx.fillRect(0, 0, 8, 8);
    gCtx.fillRect(TILE_SIZE-8, 0, 8, 8);
    gCtx.fillRect(0, TILE_SIZE-8, 8, 8);
    gCtx.fillRect(TILE_SIZE-8, TILE_SIZE-8, 8, 8);
    // Add center decorative element
    gCtx.fillStyle = '#A0522D';
    gCtx.fillRect(TILE_SIZE/2-4, TILE_SIZE/2-4, 8, 8);
    assets.mansionWallTexture = new Image(); assets.mansionWallTexture.src = genCanvas.toDataURL();

    // Bronze Key Sprite - Redesigned to look like a proper key, not a spoon
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#b87333'; 
    // Key head (ring)
    gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.25, TILE_SIZE*0.12, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#000'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.25, TILE_SIZE*0.08, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#b87333';
    // Key shaft
    gCtx.fillRect(TILE_SIZE*0.48, TILE_SIZE*0.35, TILE_SIZE*0.04, TILE_SIZE*0.4);
    // Key teeth (notches)
    gCtx.fillRect(TILE_SIZE*0.52, TILE_SIZE*0.45, TILE_SIZE*0.06, TILE_SIZE*0.03);
    gCtx.fillRect(TILE_SIZE*0.52, TILE_SIZE*0.55, TILE_SIZE*0.06, TILE_SIZE*0.03);
    assets.bronzeKeySprite = new Image(); assets.bronzeKeySprite.src = genCanvas.toDataURL();

    // Gold Key Sprite - Redesigned to look like a proper key, not a spoon
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#FFD700'; 
    // Key head (ring)
    gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.25, TILE_SIZE*0.12, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#000'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.25, TILE_SIZE*0.08, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#FFD700';
    // Key shaft
    gCtx.fillRect(TILE_SIZE*0.48, TILE_SIZE*0.35, TILE_SIZE*0.04, TILE_SIZE*0.4);
    // Key teeth (notches)
    gCtx.fillRect(TILE_SIZE*0.52, TILE_SIZE*0.45, TILE_SIZE*0.06, TILE_SIZE*0.03);
    gCtx.fillRect(TILE_SIZE*0.52, TILE_SIZE*0.55, TILE_SIZE*0.06, TILE_SIZE*0.03);
    gCtx.fillRect(TILE_SIZE*0.52, TILE_SIZE*0.65, TILE_SIZE*0.06, TILE_SIZE*0.03);
    assets.goldKeySprite = new Image(); assets.goldKeySprite.src = genCanvas.toDataURL();
    
    // Door Texture (with symbol)
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#654321'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.fillStyle = '#4a2e1a'; for(let i = 0; i < 4; i++) { gCtx.fillRect(0, i * 16 + 4, TILE_SIZE, 8); }
    gCtx.fillStyle = '#333'; gCtx.fillRect(TILE_SIZE*0.75, TILE_SIZE*0.45, TILE_SIZE*0.1, TILE_SIZE*0.1);
    // Gold symbol
    gCtx.strokeStyle = '#FFD700'; gCtx.lineWidth = 3;
    gCtx.beginPath();
    gCtx.arc(TILE_SIZE*0.25, TILE_SIZE*0.5, TILE_SIZE*0.12, 0, Math.PI*2);
    gCtx.moveTo(TILE_SIZE*0.25, TILE_SIZE*0.38);
    gCtx.lineTo(TILE_SIZE*0.25, TILE_SIZE*0.62);
    gCtx.stroke();
    assets.doorTexture = new Image(); assets.doorTexture.src = genCanvas.toDataURL();

    // Bronze Door Texture
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#5a3b1f'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.fillStyle = '#3d2816'; for(let i = 0; i < 4; i++) { gCtx.fillRect(0, i * 16 + 5, TILE_SIZE, 7); }
    gCtx.fillStyle = '#333'; gCtx.fillRect(TILE_SIZE*0.75, TILE_SIZE*0.45, TILE_SIZE*0.1, TILE_SIZE*0.1);
    gCtx.strokeStyle = '#b87333'; gCtx.lineWidth = 2;
    gCtx.beginPath(); gCtx.moveTo(TILE_SIZE*0.18, TILE_SIZE*0.35); gCtx.lineTo(TILE_SIZE*0.32, TILE_SIZE*0.65); gCtx.stroke();
    assets.bronzeDoorTexture = new Image(); assets.bronzeDoorTexture.src = genCanvas.toDataURL();
    
    // Closet Texture
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#3a2d1d'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.strokeStyle = '#2c2216'; gCtx.lineWidth = 4;
    gCtx.beginPath(); gCtx.moveTo(TILE_SIZE/2, 0); gCtx.lineTo(TILE_SIZE/2, TILE_SIZE); gCtx.stroke();
    gCtx.fillStyle = '#111'; gCtx.fillRect(TILE_SIZE/2 - 8, TILE_SIZE * 0.1, 4, TILE_SIZE * 0.8);
    assets.closetTexture = new Image(); assets.closetTexture.src = genCanvas.toDataURL();
    
    // Enemy Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    const grd = gCtx.createRadialGradient(TILE_SIZE/2, TILE_SIZE/2, 5, TILE_SIZE/2, TILE_SIZE/2, 30);
    grd.addColorStop(0, 'rgba(20,0,0,1)'); grd.addColorStop(1, 'rgba(0,0,0,0)');
    gCtx.fillStyle = grd; gCtx.fillRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#ff0000'; gCtx.beginPath(); gCtx.arc(TILE_SIZE * 0.4, TILE_SIZE * 0.4, 4, 0, Math.PI * 2); gCtx.fill();
    gCtx.beginPath(); gCtx.arc(TILE_SIZE * 0.6, TILE_SIZE * 0.4, 4, 0, Math.PI * 2); gCtx.fill();
    assets.enemySprite = new Image(); assets.enemySprite.src = genCanvas.toDataURL();

    // Container Closed - Made shorter
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#5b4636'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.fillStyle = '#3d2f24'; gCtx.fillRect(6, 15, TILE_SIZE-12, TILE_SIZE-30); // Reduced height
    gCtx.fillStyle = '#222'; gCtx.fillRect(TILE_SIZE/2 - 6, TILE_SIZE/2 - 2, 12, 4); // Smaller lock
    assets.containerClosed = new Image(); assets.containerClosed.src = genCanvas.toDataURL();

    // Container Open - Made shorter
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#5b4636'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.fillStyle = '#3d2f24'; gCtx.fillRect(6, 15, TILE_SIZE-12, TILE_SIZE-30); // Reduced height
    gCtx.fillStyle = '#3d2f24'; gCtx.fillRect(6, 10, TILE_SIZE-12, 6); // Smaller top
    gCtx.fillStyle = '#222'; gCtx.fillRect(TILE_SIZE/2 - 6, TILE_SIZE/2 - 1, 12, 3); // Smaller lock
    assets.containerOpen = new Image(); assets.containerOpen.src = genCanvas.toDataURL();

    // Flashlight Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#333'; gCtx.fillRect(TILE_SIZE*0.35, TILE_SIZE*0.55, TILE_SIZE*0.3, TILE_SIZE*0.15);
    gCtx.fillStyle = '#666'; gCtx.fillRect(TILE_SIZE*0.25, TILE_SIZE*0.5, TILE_SIZE*0.2, TILE_SIZE*0.25);
    gCtx.fillStyle = '#FFD700'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.6, TILE_SIZE*0.12, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#FFF'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.6, TILE_SIZE*0.08, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#FFD700'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.6, TILE_SIZE*0.04, 0, Math.PI*2); gCtx.fill();
    assets.flashlightSprite = new Image(); assets.flashlightSprite.src = genCanvas.toDataURL();

    // Vitamins Sprite (pill bottle)
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#f39c12'; gCtx.fillRect(TILE_SIZE*0.4, TILE_SIZE*0.35, TILE_SIZE*0.2, TILE_SIZE*0.35);
    gCtx.fillStyle = '#fff'; gCtx.fillRect(TILE_SIZE*0.38, TILE_SIZE*0.25, TILE_SIZE*0.24, TILE_SIZE*0.12);
    gCtx.fillStyle = '#c0392b'; gCtx.fillRect(TILE_SIZE*0.42, TILE_SIZE*0.45, TILE_SIZE*0.16, TILE_SIZE*0.05);
    assets.vitaminsSprite = new Image(); assets.vitaminsSprite.src = genCanvas.toDataURL();

    // Lockpick Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.strokeStyle = '#b87333'; gCtx.lineWidth = 3; gCtx.beginPath(); gCtx.moveTo(TILE_SIZE*0.3, TILE_SIZE*0.7); gCtx.lineTo(TILE_SIZE*0.7, TILE_SIZE*0.3); gCtx.stroke();
    gCtx.lineWidth = 2; gCtx.beginPath(); gCtx.moveTo(TILE_SIZE*0.6, TILE_SIZE*0.4); gCtx.lineTo(TILE_SIZE*0.8, TILE_SIZE*0.45); gCtx.stroke();
    assets.lockpickSprite = new Image(); assets.lockpickSprite.src = genCanvas.toDataURL();
    
    // Stairs Up Sprite - More subtle and less obstructive
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.globalAlpha = 0.7; // Make stairs semi-transparent
    gCtx.fillStyle = '#654321'; gCtx.fillRect(TILE_SIZE*0.3, TILE_SIZE*0.7, TILE_SIZE*0.4, TILE_SIZE*0.2);
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(TILE_SIZE*0.35, TILE_SIZE*0.6, TILE_SIZE*0.3, TILE_SIZE*0.08);
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(TILE_SIZE*0.4, TILE_SIZE*0.5, TILE_SIZE*0.2, TILE_SIZE*0.08);
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(TILE_SIZE*0.45, TILE_SIZE*0.4, TILE_SIZE*0.1, TILE_SIZE*0.08);
    gCtx.fillStyle = '#FFD700'; gCtx.fillRect(TILE_SIZE*0.47, TILE_SIZE*0.35, TILE_SIZE*0.06, TILE_SIZE*0.06);
    gCtx.globalAlpha = 1.0; // Reset transparency
    assets.stairsUpTexture = new Image(); assets.stairsUpTexture.src = genCanvas.toDataURL();
    
    // Stairs Down Sprite - More subtle and less obstructive
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.globalAlpha = 0.7; // Make stairs semi-transparent
    gCtx.fillStyle = '#8B7355'; gCtx.fillRect(TILE_SIZE*0.3, TILE_SIZE*0.1, TILE_SIZE*0.4, TILE_SIZE*0.2);
    gCtx.fillStyle = '#A0522D'; gCtx.fillRect(TILE_SIZE*0.35, TILE_SIZE*0.2, TILE_SIZE*0.3, TILE_SIZE*0.08);
    gCtx.fillStyle = '#A0522D'; gCtx.fillRect(TILE_SIZE*0.4, TILE_SIZE*0.3, TILE_SIZE*0.2, TILE_SIZE*0.08);
    gCtx.fillStyle = '#A0522D'; gCtx.fillRect(TILE_SIZE*0.45, TILE_SIZE*0.4, TILE_SIZE*0.1, TILE_SIZE*0.08);
    gCtx.fillStyle = '#FFD700'; gCtx.fillRect(TILE_SIZE*0.47, TILE_SIZE*0.5, TILE_SIZE*0.06, TILE_SIZE*0.06);
    gCtx.globalAlpha = 1.0; // Reset transparency
    assets.stairsDownTexture = new Image(); assets.stairsDownTexture.src = genCanvas.toDataURL();
    
    // Torch Sprite - Fixed with proper glow effect and wall mounting
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    // Wall bracket
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(TILE_SIZE*0.45, TILE_SIZE*0.6, TILE_SIZE*0.1, TILE_SIZE*0.3);
    // Torch handle
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(TILE_SIZE*0.47, TILE_SIZE*0.5, TILE_SIZE*0.06, TILE_SIZE*0.15);
    
    // Glow effect (outer glow)
    const glowGradient = gCtx.createRadialGradient(TILE_SIZE*0.5, TILE_SIZE*0.45, 0, TILE_SIZE*0.5, TILE_SIZE*0.45, TILE_SIZE*0.25);
    glowGradient.addColorStop(0, 'rgba(255, 69, 0, 0.8)');
    glowGradient.addColorStop(0.5, 'rgba(255, 69, 0, 0.4)');
    glowGradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
    gCtx.fillStyle = glowGradient; gCtx.fillRect(TILE_SIZE*0.25, TILE_SIZE*0.2, TILE_SIZE*0.5, TILE_SIZE*0.5);
    
    // Flame base
    gCtx.fillStyle = '#FF4500'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.45, TILE_SIZE*0.12, 0, Math.PI*2); gCtx.fill();
    // Inner flame
    gCtx.fillStyle = '#FFD700'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.45, TILE_SIZE*0.08, 0, Math.PI*2); gCtx.fill();
    // Flame tip
    gCtx.fillStyle = '#FF6347'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.42, TILE_SIZE*0.06, 0, Math.PI*2); gCtx.fill();
    // Small sparkles
    gCtx.fillStyle = '#FFFFFF'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.38, TILE_SIZE*0.03, 0, Math.PI*2); gCtx.fill();
    assets.torchTexture = new Image(); assets.torchTexture.src = genCanvas.toDataURL();
    
    // Bones Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#F5F5DC'; gCtx.fillRect(TILE_SIZE*0.4, TILE_SIZE*0.3, TILE_SIZE*0.2, TILE_SIZE*0.4);
    gCtx.fillStyle = '#F5F5DC'; gCtx.fillRect(TILE_SIZE*0.35, TILE_SIZE*0.45, TILE_SIZE*0.3, TILE_SIZE*0.1);
    gCtx.fillStyle = '#F5F5DC'; gCtx.fillRect(TILE_SIZE*0.3, TILE_SIZE*0.5, TILE_SIZE*0.4, TILE_SIZE*0.1);
    assets.bonesTexture = new Image(); assets.bonesTexture.src = genCanvas.toDataURL();
    
    // Cobweb Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.strokeStyle = '#F5F5DC'; gCtx.lineWidth = 1;
    gCtx.beginPath(); gCtx.moveTo(TILE_SIZE*0.2, TILE_SIZE*0.2); gCtx.lineTo(TILE_SIZE*0.8, TILE_SIZE*0.3);
    gCtx.moveTo(TILE_SIZE*0.3, TILE_SIZE*0.4); gCtx.lineTo(TILE_SIZE*0.7, TILE_SIZE*0.5);
    gCtx.moveTo(TILE_SIZE*0.4, TILE_SIZE*0.6); gCtx.lineTo(TILE_SIZE*0.6, TILE_SIZE*0.7);
    gCtx.stroke();
    assets.cobwebTexture = new Image(); assets.cobwebTexture.src = genCanvas.toDataURL();
    
    // Blood Stain Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#8B0000'; gCtx.beginPath(); gCtx.ellipse(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.25, TILE_SIZE*0.15, 0, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#DC143C'; gCtx.beginPath(); gCtx.ellipse(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.15, TILE_SIZE*0.08, 0, 0, Math.PI*2); gCtx.fill();
    assets.bloodStainTexture = new Image(); assets.bloodStainTexture.src = genCanvas.toDataURL();
    
    // Altar Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#2F4F4F'; gCtx.fillRect(TILE_SIZE*0.2, TILE_SIZE*0.5, TILE_SIZE*0.6, TILE_SIZE*0.4);
    gCtx.fillStyle = '#696969'; gCtx.fillRect(TILE_SIZE*0.15, TILE_SIZE*0.4, TILE_SIZE*0.7, TILE_SIZE*0.1);
    gCtx.fillStyle = '#FFD700'; gCtx.fillRect(TILE_SIZE*0.4, TILE_SIZE*0.35, TILE_SIZE*0.2, TILE_SIZE*0.1);
    gCtx.fillStyle = '#FF0000'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.3, TILE_SIZE*0.08, 0, Math.PI*2); gCtx.fill();
    assets.altarTexture = new Image(); assets.altarTexture.src = genCanvas.toDataURL();
    
    // Cage Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.strokeStyle = '#696969'; gCtx.lineWidth = 2;
    gCtx.strokeRect(TILE_SIZE*0.2, TILE_SIZE*0.2, TILE_SIZE*0.6, TILE_SIZE*0.6);
    gCtx.beginPath(); gCtx.moveTo(TILE_SIZE*0.2, TILE_SIZE*0.35); gCtx.lineTo(TILE_SIZE*0.8, TILE_SIZE*0.35);
    gCtx.moveTo(TILE_SIZE*0.2, TILE_SIZE*0.5); gCtx.lineTo(TILE_SIZE*0.8, TILE_SIZE*0.5);
    gCtx.moveTo(TILE_SIZE*0.35, TILE_SIZE*0.2); gCtx.lineTo(TILE_SIZE*0.35, TILE_SIZE*0.8);
    gCtx.moveTo(TILE_SIZE*0.5, TILE_SIZE*0.2); gCtx.lineTo(TILE_SIZE*0.5, TILE_SIZE*0.8);
    gCtx.stroke();
    assets.cageTexture = new Image(); assets.cageTexture.src = genCanvas.toDataURL();
    
    // Smoke Bomb Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#333'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.15, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#666'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.12, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#999'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.08, 0, Math.PI*2); gCtx.fill();
    assets.smokeBombSprite = new Image(); assets.smokeBombSprite.src = genCanvas.toDataURL();
    
    // Noise Maker Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#8B4513'; gCtx.fillRect(TILE_SIZE*0.4, TILE_SIZE*0.4, TILE_SIZE*0.2, TILE_SIZE*0.2);
    gCtx.fillStyle = '#FFD700'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.08, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#FF4500'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.04, 0, Math.PI*2); gCtx.fill();
    assets.noiseMakerSprite = new Image(); assets.noiseMakerSprite.src = genCanvas.toDataURL();
    
    // Trap Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#8B0000'; gCtx.fillRect(TILE_SIZE*0.3, TILE_SIZE*0.3, TILE_SIZE*0.4, TILE_SIZE*0.4);
    gCtx.fillStyle = '#FF0000'; gCtx.beginPath(); gCtx.arc(TILE_SIZE*0.5, TILE_SIZE*0.5, TILE_SIZE*0.1, 0, Math.PI*2); gCtx.fill();
    gCtx.fillStyle = '#000'; gCtx.fillRect(TILE_SIZE*0.45, TILE_SIZE*0.45, TILE_SIZE*0.1, TILE_SIZE*0.1);
    assets.trapSprite = new Image(); assets.trapSprite.src = genCanvas.toDataURL();
    
    // Moving Wall Sprite
    gCtx.clearRect(0,0,TILE_SIZE,TILE_SIZE);
    gCtx.fillStyle = '#2F4F4F'; gCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
    gCtx.strokeStyle = '#FFD700'; gCtx.lineWidth = 2;
    gCtx.beginPath(); gCtx.moveTo(TILE_SIZE*0.2, TILE_SIZE*0.2); gCtx.lineTo(TILE_SIZE*0.8, TILE_SIZE*0.8);
    gCtx.moveTo(TILE_SIZE*0.8, TILE_SIZE*0.2); gCtx.lineTo(TILE_SIZE*0.2, TILE_SIZE*0.8);
    gCtx.stroke();
    assets.movingWallSprite = new Image(); assets.movingWallSprite.src = genCanvas.toDataURL();
}

// --- GAME & PLAYER STATE ---
let player = {}, enemies = [], map = [], sprites = [];
let closetInteriors = [];
// sprites: {x,y,type,texture,opened?,contains?}
let keys = {}, touchState = {};
let message = { text: "Find the key. Don't get caught. Use SPACE on stairs to change floors.", life: 300 };
let lastShiftTime = 0, lastEnemyPathUpdateTime = 0;
let popupLife = 0;
let audioCues = { enabled: true, lastPlayed: 0, cooldown: 2000 };
let settings = { sens: 1, bright: 0, vol: 0.5, scale: 1, audioCues: true };
try { const stored = JSON.parse(localStorage.getItem('mh_settings')||'{}'); Object.assign(settings, stored); } catch(e) {}
audioCues.enabled = settings.audioCues;
let inventory = { flashlight: false, vitamins: 0, lockpick: 0, vitActiveUntil: 0, smokeBomb: 0, noiseMaker: 0 };
let rushEvent = { active: false, startTime: 0, duration: 8000, cooldown: 30000, lastTrigger: 0 };
let stalkerEnemy = null;

// New game features
let playerAbilities = { 
    crouching: false, 
    stealthMode: false, 
    lastFootstep: 0,
    surfaceType: 'stone' // stone, wood, carpet
};

let environmentalHazards = [];
let dynamicEvents = { 
    powerOutage: { active: false, startTime: 0, duration: 15000 },
    movingWalls: { active: false, startTime: 0, duration: 20000 },
    lightExtinguishing: { active: false, startTime: 0, duration: 10000 }
};

let achievementSystem = {
    unlocked: new Set(),
    total: 0,
    checkAchievements: function() {
        // Check for various achievements
        if (player.hasGoldKey && !this.unlocked.has('keyfinder')) {
            this.unlocked.add('keyfinder');
            this.total++;
            showPopup('üèÜ Achievement: Key Finder!');
        }
        if (enemies.length === 0 && !this.unlocked.has('pacifist')) {
            this.unlocked.add('pacifist');
            this.total++;
            showPopup('üèÜ Achievement: Pacifist!');
        }
    }
};

// Gamepad support
let gamepad = null;
let gamepadState = {
    leftStick: { x: 0, y: 0 },
    rightStick: { x: 0, y: 0 },
    buttons: new Array(16).fill(false),
    lastButtons: new Array(16).fill(false)
};

// Audio system
let audioContext = null;
let audioEnabled = true;
let sounds = {
    doorOpen: null,
    doorClose: null,
    doorCreak: null,
    footsteps: null,
    heartbeat: null,
    ambient: null,
    closetOpen: null,
    closetClose: null,
    keyPickup: null,
    itemPickup: null,
    enemyGrowl: null,
    houseShift: null,
    rushEvent: null,
    // New enhanced sounds
    footstepsStone: null,
    footstepsWood: null,
    footstepsCarpet: null,
    smokeBomb: null,
    noiseMaker: null,
    trapTrigger: null,
    powerOutage: null,
    movingWall: null,
    lightExtinguish: null,
    enemyHear: null,
    enemyAlert: null
};

let audioNodes = {
    ambient: null,
    heartbeat: null,
    footsteps: null
};

function initAudio() {
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        console.log("Audio context initialized");
        
        // Create audio nodes
        audioNodes.ambient = audioContext.createGain();
        audioNodes.heartbeat = audioContext.createGain();
        audioNodes.footsteps = audioContext.createGain();
        
        // Connect to master output
        audioNodes.ambient.connect(audioContext.destination);
        audioNodes.heartbeat.connect(audioContext.destination);
        audioNodes.footsteps.connect(audioContext.destination);
        
        // Set initial volumes
        audioNodes.ambient.gain.value = 0.1; // Reduced from 0.3
        audioNodes.heartbeat.gain.value = 0.0;
        audioNodes.footsteps.gain.value = 0.0;
        
        // Generate procedural sounds
        generateSounds();
        
    } catch (error) {
        console.warn("Audio not supported:", error);
        audioEnabled = false;
    }
}

function generateSounds() {
    if (!audioEnabled || !audioContext) return;
    
    // Door creak sound
    sounds.doorCreak = generateDoorCreak();
    
    // Door open/close sounds
    sounds.doorOpen = generateDoorSound(0.3, 0.8);
    sounds.doorClose = generateDoorSound(0.1, 0.6);
    
    // Footstep sounds
    sounds.footsteps = generateFootsteps();
    
    // Heartbeat sound
    sounds.heartbeat = generateHeartbeat();
    
    // Ambient house sounds
    sounds.ambient = generateAmbientSounds();
    
    // House shift sound
    sounds.houseShift = generateHouseShift();
    
    // Rush event sound
    sounds.rushEvent = generateRushEvent();
    
    // Item pickup sounds
    sounds.keyPickup = generatePickupSound(800, 0.3);
    sounds.itemPickup = generatePickupSound(600, 0.2);
    
    // Enemy sounds
    sounds.enemyGrowl = generateEnemySound();
    
    // Closet sounds
    sounds.closetOpen = generateClosetSound(0.8);
    sounds.closetClose = generateClosetSound(0.4);
    
    // Enhanced surface-based footsteps
    sounds.footstepsStone = generateFootsteps(120, 0.25);
    sounds.footstepsWood = generateFootsteps(100, 0.2);
    sounds.footstepsCarpet = generateFootsteps(80, 0.15);
    
    // New item sounds
    sounds.smokeBomb = generateSmokeBombSound();
    sounds.noiseMaker = generateNoiseMakerSound();
    sounds.trapTrigger = generateTrapSound();
    
    // Environmental sounds
    sounds.powerOutage = generatePowerOutageSound();
    sounds.movingWall = generateMovingWallSound();
    sounds.lightExtinguish = generateLightExtinguishSound();
    
    // Enemy AI sounds
    sounds.enemyHear = generateEnemyHearSound();
    sounds.enemyAlert = generateEnemyAlertSound();
}

function generateDoorCreak() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 1.5, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const frequency = 200 + Math.sin(t * 2) * 50;
        const amplitude = Math.exp(-t * 2) * 0.3;
        data[i] = Math.sin(t * frequency * Math.PI * 2) * amplitude * (1 + Math.sin(t * 8) * 0.3);
    }
    
    return buffer;
}

function generateDoorSound(attack, decay) {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.5, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const envelope = Math.min(t / attack, 1) * Math.exp(-t / decay);
        const frequency = 150 + Math.sin(t * 20) * 30;
        data[i] = Math.sin(t * frequency * Math.PI * 2) * envelope * 0.4;
    }
    
    return buffer;
}

function generateFootsteps() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.3, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const envelope = Math.exp(-t * 8) * 0.2;
        const frequency = 80 + Math.random() * 40;
        data[i] = Math.sin(t * frequency * Math.PI * 2) * envelope;
    }
    
    return buffer;
}

function generateHeartbeat() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 2, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const beat = Math.sin(t * 2 * Math.PI) > 0 ? 1 : 0;
        const envelope = Math.exp(-(t % 0.5) * 10) * 0.3;
        data[i] = beat * envelope;
    }
    
    return buffer;
}

function generateAmbientSounds() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 3, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const wind = Math.sin(t * 0.5 * Math.PI * 2) * 0.02; // Reduced from 0.05
        const creaks = Math.random() < 0.0001 ? Math.sin(t * 100 * Math.PI * 2) * 0.05 : 0; // Reduced frequency and volume
        const distant = Math.sin(t * 0.1 * Math.PI * 2) * 0.01; // Reduced from 0.03
        data[i] = wind + creaks + distant;
    }
    
    return buffer;
}

function generateHouseShift() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 1, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const rumble = Math.sin(t * 30 * Math.PI * 2) * 0.4;
        const shift = Math.sin(t * 5 * Math.PI * 2) * 0.3;
        const envelope = Math.sin(t * Math.PI) * 0.5;
        data[i] = (rumble + shift) * envelope;
    }
    
    return buffer;
}

function generateRushEvent() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.8, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const alarm = Math.sin(t * 400 * Math.PI * 2) * 0.3;
        const urgency = Math.sin(t * 200 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 3) * 0.6;
        data[i] = (alarm + urgency) * envelope;
    }
    
    return buffer;
}

function generatePickupSound(freq, duration) {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * duration, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const envelope = Math.exp(-t * 8) * 0.3;
        data[i] = Math.sin(t * freq * Math.PI * 2) * envelope;
    }
    
    return buffer;
}

function generateEnemySound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 1, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const growl = Math.sin(t * 120 * Math.PI * 2) * 0.3;
        const rumble = Math.sin(t * 60 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 2) * 0.4;
        data[i] = (growl + rumble) * envelope;
    }
    
    return buffer;
}

function generateClosetSound(volume) {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.4, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const creak = Math.sin(t * 300 * Math.PI * 2) * 0.2;
        const wood = Math.sin(t * 150 * Math.PI * 2) * 0.1;
        const envelope = Math.exp(-t * 4) * volume;
        data[i] = (creak + wood) * envelope;
    }
    
    return buffer;
}

// Enhanced surface-based footsteps
function generateFootsteps(freq, volume) {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.3, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const envelope = Math.exp(-t * 8) * volume;
        const frequency = freq + Math.random() * 20;
        data[i] = Math.sin(t * frequency * Math.PI * 2) * envelope;
    }
    
    return buffer;
}

// New sound effects
function generateSmokeBombSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 1.0, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const whoosh = Math.sin(t * 200 * Math.PI * 2) * 0.3;
        const smoke = Math.sin(t * 50 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 2) * 0.4;
        data[i] = (whoosh + smoke) * envelope;
    }
    
    return buffer;
}

function generateNoiseMakerSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.8, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const alarm = Math.sin(t * 800 * Math.PI * 2) * 0.3;
        const echo = Math.sin(t * 600 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 3) * 0.5;
        data[i] = (alarm + echo) * envelope;
    }
    
    return buffer;
}

function generateTrapSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.5, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const snap = Math.sin(t * 400 * Math.PI * 2) * 0.4;
        const thud = Math.sin(t * 100 * Math.PI * 2) * 0.3;
        const envelope = Math.exp(-t * 6) * 0.6;
        data[i] = (snap + thud) * envelope;
    }
    
    return buffer;
}

function generatePowerOutageSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 1.5, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const buzz = Math.sin(t * 60 * Math.PI * 2) * 0.3;
        const fade = Math.sin(t * 30 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 1.5) * 0.5;
        data[i] = (buzz + fade) * envelope;
    }
    
    return buffer;
}

function generateMovingWallSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 2.0, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const rumble = Math.sin(t * 40 * Math.PI * 2) * 0.4;
        const scrape = Math.sin(t * 200 * Math.PI * 2) * 0.3;
        const envelope = Math.sin(t * Math.PI / 2) * 0.6;
        data[i] = (rumble + scrape) * envelope;
    }
    
    return buffer;
}

function generateLightExtinguishSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.6, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const flicker = Math.sin(t * 300 * Math.PI * 2) * 0.3;
        const extinguish = Math.sin(t * 150 * Math.PI * 2) * 0.2;
        const envelope = Math.exp(-t * 4) * 0.5;
        data[i] = (flicker + extinguish) * envelope;
    }
    
    return buffer;
}

function generateEnemyHearSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.4, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const alert = Math.sin(t * 250 * Math.PI * 2) * 0.3;
        const envelope = Math.exp(-t * 5) * 0.4;
        data[i] = alert * envelope;
    }
    
    return buffer;
}

function generateEnemyAlertSound() {
    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.6, audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < buffer.length; i++) {
        const t = i / audioContext.sampleRate;
        const growl = Math.sin(t * 180 * Math.PI * 2) * 0.4;
        const roar = Math.sin(t * 90 * Math.PI * 2) * 0.3;
        const envelope = Math.exp(-t * 3) * 0.6;
        data[i] = (growl + roar) * envelope;
    }
    
    return buffer;
}

function playSound(soundName, volume = 1.0, loop = false) {
    if (!audioEnabled || !audioContext || !sounds[soundName]) return;
    
    try {
        const source = audioContext.createBufferSource();
        const gainNode = audioContext.createGain();
        
        source.buffer = sounds[soundName];
        source.loop = loop;
        
        gainNode.gain.value = volume * (settings.vol || 0.5);
        
        source.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        source.start();
        
        return { source, gainNode };
    } catch (error) {
        console.warn("Failed to play sound:", soundName, error);
    }
}

function playAmbientLoop() {
    if (!audioEnabled || !audioContext) return;
    
    const source = audioContext.createBufferSource();
    source.buffer = sounds.ambient;
    source.loop = true;
    source.connect(audioNodes.ambient);
    source.start();
    
    audioNodes.ambient.gain.setValueAtTime(0.3, audioContext.currentTime);
    audioNodes.ambient.gain.exponentialRampToValueAtTime(0.3, audioContext.currentTime + 1);
}

function updateAudio() {
    if (!audioEnabled || !audioContext) return;
    
    // Update heartbeat based on player state
    if (currentGameState === GAME_STATE.PLAYING) {
        const enemiesNearby = enemies.some(e => Math.hypot(e.x - player.x, e.y - player.y) < 5);
        const stalkerNearby = stalkerEnemy && Math.hypot(stalkerEnemy.x - player.x, stalkerEnemy.y - player.y) < 8;
        
        if (enemiesNearby || stalkerNearby) {
            audioNodes.heartbeat.gain.setValueAtTime(0.4, audioContext.currentTime);
        } else {
            audioNodes.heartbeat.gain.setValueAtTime(0.0, audioContext.currentTime);
        }
    }
    
    // Update footsteps based on movement and surface type
    const isMoving = keys['w'] || keys['s'] || keys['a'] || keys['d'] || 
                    (gamepad && (gamepadState.leftStick.x !== 0 || gamepadState.leftStick.y !== 0));
    
    if (isMoving && currentGameState === GAME_STATE.PLAYING) {
        // Determine surface type based on player position
        const playerTileX = Math.floor(player.x);
        const playerTileY = Math.floor(player.y);
        let surfaceType = 'stone'; // Default
        
        // Check for different surface types
        if (map[playerTileY] && map[playerTileY][playerTileX] === 0) {
            // Check if near wooden objects (containers, doors)
            const nearWood = sprites.some(s => {
                const dist = Math.hypot(s.x - player.x, s.y - player.y);
                return dist < 2 && (s.type === 'container' || s.type === 'door');
            });
            if (nearWood) surfaceType = 'wood';
        }
        
        // Update surface type and play appropriate footstep sound
        if (playerAbilities.surfaceType !== surfaceType) {
            playerAbilities.surfaceType = surfaceType;
            // Play surface change sound
            const footstepSound = surfaceType === 'wood' ? 'footstepsWood' : 
                                surfaceType === 'carpet' ? 'footstepsCarpet' : 'footstepsStone';
            playSound(footstepSound, 0.3);
        }
        
        audioNodes.footsteps.gain.setValueAtTime(0.2, audioContext.currentTime);
    } else {
        audioNodes.footsteps.gain.setValueAtTime(0.0, audioContext.currentTime);
    }
}

function hashStringToSeed(str) {
    let h = 2166136261 >>> 0;
    for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
    }
    return h >>> 0;
}

function mulberry32(a) {
    return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
}

function pickAffix() {
    const affixes = ["Fleet Footed", "Calm Predator", "Labyrinthine", "Keen Eye"];
    return affixes[Math.floor(prng() * affixes.length)];
}

function applyAffix() {
    // Reset to defaults first
    currentShiftInterval = SHIFT_INTERVAL;
    currentEnemySpeed = BASE_ENEMY_SPEED + stageIndex * 0.004;
    currentPathUpdateInterval = Math.max(400, ENEMY_PATH_UPDATE_INTERVAL - stageIndex * 100);
    player.moveSpeedMultiplier = 1;
    player.keenEye = false;
    switch(currentAffix) {
        case "Fleet Footed":
            player.moveSpeedMultiplier = 1.15;
            break;
        case "Calm Predator":
            currentEnemySpeed *= 0.9;
            break;
        case "Labyrinthine":
            currentShiftInterval = Math.max(20000, SHIFT_INTERVAL - 8000);
            break;
        case "Keen Eye":
            player.keenEye = true;
            break;
        default:
            break;
    }
    if (hudAffixEl) hudAffixEl.textContent = currentAffix;
}

function enemiesForStage() {
    if (stageIndex >= 3) return 3;
    if (stageIndex >= 2) return 2;
    return 1;
}

function generateMultiFloorMaze() {
    floors = [];
    floorConnections = [];
    
    console.log("Generating multi-floor maze with", maxFloors, "floors");
    
    // Generate multiple floors
    for (let f = 0; f < maxFloors; f++) {
        const floorMap = generateMaze(MAP_SIZE, MAP_SIZE);
        floors.push(floorMap);
        console.log("Generated floor", f, "with size", floorMap.length, "x", floorMap[0].length);
        
        // Add dungeon atmosphere objects
        addDungeonObjects(floorMap, f);
    }
    
    // Create staircase connections between floors
    for (let f = 0; f < maxFloors - 1; f++) {
        // For higher stages, try multiple positions to ensure stairs are placed
        let upPos = null, downPos = null;
        let attempts = 0;
        const maxAttempts = stageIndex >= 1 ? 20 : 10; // More attempts for higher stages
        
        while (!upPos && attempts < maxAttempts) {
            upPos = findRandomEmptyCell(floors[f]);
            attempts++;
        }
        
        attempts = 0;
        while (!downPos && attempts < maxAttempts) {
            downPos = findRandomEmptyCell(floors[f + 1]);
            attempts++;
        }
        
        console.log("Floor", f, "upPos:", upPos, "Floor", f+1, "downPos:", downPos, "after", attempts, "attempts");
        
        if (upPos && downPos) {
            floors[f][upPos.y][upPos.x] = 5; // Stairs up
            floors[f + 1][downPos.y][downPos.x] = 6; // Stairs down
            
            floorConnections.push({
                floor: f,
                upX: upPos.x,
                upY: upPos.y,
                downX: downPos.x,
                downY: downPos.y
            });
            
            console.log("Connected floors", f, "and", f+1, "with stairs at", upPos.x, upPos.y, "and", downPos.x, downPos.y);
        } else {
            console.error("Failed to place stairs between floors", f, "and", f+1, "after", maxAttempts, "attempts");
        }
    }
    
    console.log("Final floor connections:", floorConnections);
    console.log("floors array length:", floors.length);
    
    // Validate stair connections for higher stages
    if (stageIndex >= 1) {
        console.log(`Stage ${stageIndex + 1}: Validating stair connections...`);
        for (let conn of floorConnections) {
            // Check if stairs are accessible (not blocked by walls)
            const upAccessible = isPositionAccessible(conn.upX, conn.upY);
            const downAccessible = isPositionAccessible(conn.downX, conn.downY);
            console.log(`Floor ${conn.floor} stairs: up(${conn.upX},${conn.upY}) accessible: ${upAccessible}, down(${conn.downX},${conn.downY}) accessible: ${downAccessible}`);
            
            if (!upAccessible || !downAccessible) {
                console.warn(`Stairs at floor ${conn.floor} may be blocked!`);
            }
        }
    }
    
    // Smart exit placement: ensure exit is always reachable
    let exitPlaced = false;
    
    // Strategy 1: If we have working stairs, place exit on top floor
    if (floorConnections.length > 0) {
        const topFloor = floors[maxFloors - 1];
        let exitPos = findRandomEmptyCell(topFloor);
        if (exitPos) {
            topFloor[exitPos.y][exitPos.x] = 3; // Gold exit door
            console.log("Placed exit on top floor (stairs available) at", exitPos.x, exitPos.y);
            exitPlaced = true;
        }
    }
    
    // Strategy 2: If no stairs or stairs failed, place exit on current floor
    if (!exitPlaced) {
        console.log("No working stairs found, placing exit on current floor");
        // We'll place the exit in resetGame() after the current floor is set
        exitPlaced = true;
    }
    
    if (!exitPlaced) {
        console.error("Failed to place exit anywhere");
    }
}

function addDungeonObjects(floorMap, floorIndex) {
    // Add torches for lighting
    for (let i = 0; i < 3 + Math.floor(prng() * 3); i++) {
        let pos = findRandomEmptyCell(floorMap);
        if (pos) {
            floorMap[pos.y][pos.x] = 7; // Torch
        }
    }
    
    // Add bones and blood stains
    for (let i = 0; i < 2 + Math.floor(prng() * 2); i++) {
        let pos = findRandomEmptyCell(floorMap);
        if (pos) {
            floorMap[pos.y][pos.x] = 8; // Bones
        }
    }
    
    for (let i = 0; i < 1 + Math.floor(prng() * 2); i++) {
        let pos = findRandomEmptyCell(floorMap);
        if (pos) {
            floorMap[pos.y][pos.x] = 9; // Blood stain
        }
    }
    
    // Add cobwebs in corners
    for (let i = 0; i < 2 + Math.floor(prng() * 2); i++) {
        let pos = findRandomEmptyCell(floorMap);
        if (pos) {
            floorMap[pos.y][pos.x] = 10; // Cobweb
        }
    }
    
    // Add altar on higher floors
    if (floorIndex > 0 && prng() < 0.7) {
        let pos = findRandomEmptyCell(floorMap);
        if (pos) {
            floorMap[pos.y][pos.x] = 11; // Altar
        }
    }
    
    // Add cage on highest floor
    if (floorIndex === maxFloors - 1 && prng() < 0.6) {
        let pos = findRandomEmptyCell(floorMap);
        if (pos) {
            floorMap[pos.y][pos.x] = 12; // Cage
        }
    }
}

function resetGame() {
    // Stage-specific adjustments for multi-floor system
    if (stageIndex >= 1) {
        // Stages 2+ should have more floors and more complex stair systems
        maxFloors = Math.min(4, 3 + stageIndex); // Increase floors for higher stages
        console.log(`Stage ${stageIndex + 1}: Setting maxFloors to ${maxFloors}`);
    } else {
        maxFloors = 3; // Default for stage 1
    }
    
    generateMultiFloorMaze();
    console.log("After generateMultiFloorMaze:");
    console.log("floors array length:", floors.length);
    console.log("floorConnections:", floorConnections);
    console.log("Current floor:", currentFloor);
    console.log("Stage:", stageIndex + 1, "Max floors:", maxFloors);
    
    currentFloor = 0;
    map = floors[currentFloor];
    console.log("Set currentFloor to 0, map size:", map.length, "x", map[0].length);
    
    sprites = [];
    
    let spawn = findSafeSpawnCell();
    player = { x: spawn.x + 0.5, y: spawn.y + 0.5, angle: prng() * Math.PI * 2, sanity: 100, hasBronzeKey: false, hasGoldKey: false, stamina: 1, moveSpeedMultiplier: 1, keenEye: false, graceMs: 2000, closetEntryTime: null };

    // Scatter bronze keys and items in corridors
    for (let i = 0; i < 2 + Math.floor(prng()*2); i++) {
        let keyPos = findRandomEmptyCell(map);
        if (keyPos) {
            sprites.push({ x: keyPos.x + 0.5, y: keyPos.y + 0.5, type: 'bronzeKey', texture: assets.bronzeKeySprite });
        }
    }
    if (prng() < 0.6) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'flashlight', texture: assets.flashlightSprite }); }
    if (prng() < 0.6) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'vitamins', texture: assets.vitaminsSprite }); }
    if (prng() < 0.5) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'lockpick', texture: assets.lockpickSprite }); }
    
    // Place additional random items in corridors
    if (prng() < 0.7) { 
        let p = findRandomEmptyCell(map); 
        if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'vitamins', texture: assets.vitaminsSprite }); 
    }
    if (prng() < 0.6) { 
        let p = findRandomEmptyCell(map); 
        if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'lockpick', texture: assets.lockpickSprite }); 
    }
    
    // Add new items
    if (prng() < 0.4) { 
        let p = findRandomEmptyCell(map); 
        if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'smokeBomb', texture: assets.smokeBombSprite }); 
    }
    if (prng() < 0.4) { 
        let p = findRandomEmptyCell(map); 
        if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'noiseMaker', texture: assets.noiseMakerSprite }); 
    }
    
    // Smart exit placement: check if we need to place exit on current floor
    let exitExists = false;
    for (let y = 0; y < MAP_SIZE; y++) {
        for (let x = 0; x < MAP_SIZE; x++) {
            if (map[y][x] === 3) { // Gold exit door
                exitExists = true;
                break;
            }
        }
        if (exitExists) break;
    }
    
    // If no exit exists on current floor and no stairs available, place exit here
    if (!exitExists && floorConnections.length === 0) {
        let exitPos = findRandomEmptyCell(map);
        if (exitPos) {
            map[exitPos.y][exitPos.x] = 3; // Gold exit door
            console.log("Placed exit on current floor (no stairs) at", exitPos.x, exitPos.y);
        } else {
            console.error("Failed to place exit on current floor");
        }
    }
    
    // Additional safety: if we have stairs but no working connections, ensure exit is reachable
    if (!exitExists && floorConnections.length > 0) {
        // Check if any of the floor connections actually work
        let workingStairs = false;
        for (let conn of floorConnections) {
            if (conn.floor === currentFloor && (conn.upX !== undefined || conn.downX !== undefined)) {
                workingStairs = true;
                break;
            }
        }
        
        if (!workingStairs) {
            console.log("Stairs exist but connections are broken, placing exit on current floor");
            let exitPos = findRandomEmptyCell(map);
            if (exitPos) {
                map[exitPos.y][exitPos.x] = 3; // Gold exit door
                console.log("Placed fallback exit on current floor at", exitPos.x, exitPos.y);
            }
        }
    }
    // Place some bronze doors
    for (let i = 0; i < 3; i++) {
        let d = findRandomEmptyCell(map);
        if (d && map[d.y][d.x] === 0) map[d.y][d.x] = 2; // 2 for BRONZE door
    }
    
    // Place closets on wall tiles, and also create an interior floor tile just behind
    closetInteriors = [];
    let closetsPlaced = 0;
    let attempts = 0;
    while (closetsPlaced < 12 && attempts++ < 600) {
        let c = findRandomWallAdjacentToFloor();
        if (!c) break;
        const nearDoor = [[1,0],[-1,0],[0,1],[0,-1]].some(([dx,dy]) => map[c.y+dy] && (map[c.y+dy][c.x+dx] === 2 || map[c.y+dy][c.x+dx] === 3));
        if (nearDoor) continue;
        // Determine facing: from wall to corridor
        const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
        let face = null;
        for (let [dx,dy] of neighbors) { if (map[c.y+dy] && map[c.y+dy][c.x+dx] === 0) { face = [dx,dy]; break; } }
        if (!face) continue;
        map[c.y][c.x] = 4; // closet on wall
        const interiorX = c.x - face[0];
        const interiorY = c.y - face[1];
        if (interiorY>=0 && interiorY<MAP_SIZE && interiorX>=0 && interiorX<MAP_SIZE) {
            // Carve interior as floor if it was wall, to make a hollow closet
            if (map[interiorY][interiorX] === 1) map[interiorY][interiorX] = 0;
            closetInteriors.push({ x: interiorX, y: interiorY });
        }
        closetsPlaced++;
    }

    // Place containers snapped to walls along corridors (smaller footprint)
    for (let i = 0; i < 14; i++) {
        let c = findRandomEmptyCell(map);
        if (!c) continue;
        if (map[c.y][c.x] !== 0) continue;
        // Snap toward nearest wall direction
        const dirs = [ [1,0], [-1,0], [0,1], [0,-1] ];
        let chosen = null;
        for (let [dx,dy] of dirs) {
            const wx = c.x + dx;
            const wy = c.y + dy;
            if (wx>=0 && wx<MAP_SIZE && wy>=0 && wy<MAP_SIZE && map[wy][wx] === 1) { chosen = [dx,dy]; break; }
        }
        let cx = c.x + 0.5;
        let cy = c.y + 0.5;
        if (chosen) {
            // Offset more toward wall to avoid center of corridor
            cx = c.x + 0.5 + chosen[0]*0.35;
            cy = c.y + 0.5 + chosen[1]*0.35;
        }
        sprites.push({ x: cx, y: cy, type: 'container', opened: false, contains: null, texture: assets.containerClosed, snap: chosen });
    }
    console.log("Placed", sprites.filter(s => s.type === 'container').length, "containers total");

    // Place varied loot in containers
    const containers = sprites.filter(s => s.type === 'container');
    if (containers.length > 0) {
        // Place gold key in one container
        const goldKeyIdx = Math.floor(prng() * containers.length);
        containers[goldKeyIdx].contains = { type: 'goldKey' };
        
        // Place other items in random containers
        const itemTypes = ['flashlight', 'vitamins', 'lockpick', 'bronzeKey'];
        for (let itemType of itemTypes) {
            if (prng() < 0.6) { // 60% chance for each item type
                let placed = false;
                for (let attempts = 0; attempts < 10; attempts++) {
                    const idx = Math.floor(prng() * containers.length);
                    if (containers[idx].contains === null) {
                        containers[idx].contains = { type: itemType };
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    // If no empty container, place item in corridor
                    let pos = findRandomEmptyCell(map);
                    if (pos) {
                        let texture = assets.bronzeKeySprite;
                        if (itemType === 'flashlight') texture = assets.flashlightSprite;
                        else if (itemType === 'vitamins') texture = assets.vitaminsSprite;
                        else if (itemType === 'lockpick') texture = assets.lockpickSprite;
                        
                        sprites.push({ x: pos.x + 0.5, y: pos.y + 0.5, type: itemType, texture: texture });
                    }
                }
            }
        }
        
        console.log("Placed loot in containers:", containers.filter(c => c.contains).map(c => c.contains.type));
    }
    
    enemies = [];
    const count = enemiesForStage();
    for (let i = 0; i < count; i++) {
        let enemySpawn = findRandomEmptyCell(map);
        if (enemySpawn) {
            // Create different enemy types
            let enemyType = prng() < 0.3 ? 'hunter' : prng() < 0.5 ? 'ambusher' : 'patrol';
            let enemy = { 
                x: enemySpawn.x + 0.5, 
                y: enemySpawn.y + 0.5, 
                path: [], 
                state: 'PATROL',
                type: enemyType,
                lastSeenPlayer: null,
                hearingRange: enemyType === 'hunter' ? 8 : enemyType === 'ambusher' ? 6 : 4,
                memory: enemyType === 'hunter' ? 10000 : enemyType === 'ambusher' ? 8000 : 5000,
                speed: enemyType === 'hunter' ? currentEnemySpeed * 1.2 : currentEnemySpeed,
                stealth: enemyType === 'hunter' ? 0.7 : 1.0,
                currentFloor: currentFloor // Track which floor this enemy is on
            };
            enemies.push(enemy);
        }
    }
    
    // Reset special enemies
    stalkerEnemy = null;
    rushEvent.active = false;
    rushEvent.startTime = 0;
    
    // Reset floor system
    currentFloor = 0;
    map = floors[currentFloor];
    
    // Stage-specific difficulty scaling
    if (stageIndex >= 1) {
        // Increase difficulty for stages 2+
        currentShiftInterval = Math.max(30000, SHIFT_INTERVAL - (stageIndex * 5000)); // Faster shifts
        currentEnemySpeed = BASE_ENEMY_SPEED + (stageIndex * 0.008); // Faster enemies
        currentPathUpdateInterval = Math.max(300, ENEMY_PATH_UPDATE_INTERVAL - (stageIndex * 150)); // More frequent path updates
        console.log(`Stage ${stageIndex + 1} difficulty: shift=${currentShiftInterval}ms, speed=${currentEnemySpeed}, pathUpdate=${currentPathUpdateInterval}ms`);
    } else {
        // Reset to defaults for stage 1
        currentShiftInterval = SHIFT_INTERVAL;
        currentEnemySpeed = BASE_ENEMY_SPEED;
        currentPathUpdateInterval = ENEMY_PATH_UPDATE_INTERVAL;
    }
    
    // Reset UI indicators
    if (hiddenIndicator) hiddenIndicator.style.display = 'none';
    
    // Ensure HUD is visible
    if (hud) hud.style.display = 'block';

    lastShiftTime = Date.now();
    stageStartTime = Date.now();
    currentAffix = pickAffix();
    applyAffix();
}

function nextStageOrWin() {
    stageIndex += 1;
    if (stageIndex > STAGES.length) {
        // Completed all stages
        currentGameState = GAME_STATE.WON;
        totalElapsedMs += Date.now() - stageStartTime;
        saveRun(true);
        showRunSummary(true);
        return;
    }
    // Continue to next stage
    totalElapsedMs += Date.now() - stageStartTime;
    resetGame();
    showPopup(stageIndex === 0 ? "First stage" : STAGES[stageIndex - 1]);
}

function showRunSummary(won) {
    const elapsed = totalElapsedMs;
    const minutes = Math.floor(elapsed / 60000);
    const seconds = Math.floor((elapsed % 60000) / 1000);
    const millis = elapsed % 1000;
    
    let summaryContent = won ? 
        `üéâ VICTORY! üéâ\n\n` :
        `DEFEAT\n\n`;
    
    summaryContent += `Time: ${minutes}:${seconds.toString().padStart(2,'0')}.${millis.toString().padStart(3,'0')}\n`;
    summaryContent += `Stages Completed: ${stageIndex}\n`;
    summaryContent += `Floors Explored: ${maxFloors * stageIndex}\n`;
    summaryContent += `Final Affix: ${currentAffix}\n`;
    
    if (won) {
        summaryContent += `\nüèÜ You've escaped the monster house! üèÜ\n`;
        summaryContent += `But the memory will haunt you forever...`;
    } else {
        summaryContent += `\nYour sanity lingers in the darkness.\n`;
        summaryContent += `The house claims another victim.`;
    }
    
    if (summaryText) summaryText.textContent = summaryContent;
    if (summaryPanel) summaryPanel.style.display = 'block';
    
    // Hide HUD when showing summary
    if (hud) hud.style.display = 'none';
    
    // Ensure game state is set correctly for defeat
    if (!won) {
        currentGameState = GAME_STATE.GAMEOVER;
    }
}

function playProximityAudio() {
    if (!audioCues.enabled || Date.now() - audioCues.lastPlayed < audioCues.cooldown) return;
    
    // Find nearest enemy
    let nearestEnemy = null;
    let nearestDist = Infinity;
    
    for (let enemy of enemies) {
        const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
        if (dist < nearestDist) {
            nearestDist = dist;
            nearestEnemy = enemy;
        }
    }
    
    if (stalkerEnemy) {
        const dist = Math.hypot(player.x - stalkerEnemy.x, player.y - stalkerEnemy.y);
        if (dist < nearestDist) {
            nearestDist = dist;
            nearestEnemy = stalkerEnemy;
        }
    }
    
    // Play audio cues based on proximity
    if (nearestEnemy && nearestDist < 8) {
        if (nearestDist < 2) {
            // Very close - danger sound
            playAudioCue('danger');
        } else if (nearestDist < 4) {
            // Close - warning sound
            playAudioCue('warning');
        } else if (nearestDist < 6) {
            // Medium - ambient sound
            playAudioCue('ambient');
        } else {
            // Far - subtle sound
            playAudioCue('subtle');
        }
        audioCues.lastPlayed = Date.now();
    }
}

function playAudioCue(type) {
    // Create audio context for proximity-based sounds
    if (!window.audioContext) {
        window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    const audioContext = window.audioContext;
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    let frequency, duration, volume;
    
    switch(type) {
        case 'danger':
            frequency = 200; // Low, ominous tone
            duration = 0.3;
            volume = 0.3;
            break;
        case 'warning':
            frequency = 400; // Medium warning tone
            duration = 0.2;
            volume = 0.2;
            break;
        case 'ambient':
            frequency = 600; // Higher ambient tone
            duration = 0.15;
            volume = 0.15;
            break;
        case 'subtle':
            frequency = 800; // High subtle tone
            duration = 0.1;
            volume = 0.1;
            break;
        default:
            return;
    }
    
    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
    gainNode.gain.setValueAtTime(volume * (settings.vol || 0.5), audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
    
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + duration);
}

function renderRunSummary() {
    if (summaryPanel && summaryPanel.style.display === 'block') {
        // Summary panel is already visible, no need to re-render
        return;
    }
    
    // This function is called when the summary panel needs to be rendered
    // The actual content is set in showRunSummary()
}

function renderSettingsMenu() {
    if (settingsPanel && settingsPanel.style.display === 'block') {
        // Settings panel is already visible, no need to re-render
        return;
    }
    
    // This function is called when the settings panel needs to be rendered
    // The actual content is set in the HTML and updated via event listeners
}

function renderPauseMenu() {
    if (pauseMenu && pauseMenu.style.display === 'block') {
        // Pause menu is already visible, no need to re-render
        return;
    }
    
    // This function is called when the pause menu needs to be rendered
    // The actual content is set in the HTML and updated via event listeners
}

function startRun() {
    stageIndex = 0;
    totalElapsedMs = 0;
    runStartTime = Date.now();
    const seedStr = (seedInput && seedInput.value.trim()) ? seedInput.value.trim() : `${Math.floor(Math.random()*1e9)}`;
    prng = mulberry32(hashStringToSeed(seedStr));
    
    // Hide any open panels when starting a new run
    if (summaryPanel) summaryPanel.style.display = 'none';
    if (pauseMenu) pauseMenu.style.display = 'none';
    if (settingsPanel) settingsPanel.style.display = 'none';
    
    resetGame();
    showPopup("First stage");
    
    // Ensure HUD is visible
    if (hud) hud.style.display = 'block';
    
    // Start ambient audio loop
    playAmbientLoop();
}

function msToClock(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const millis = ms % 1000;
    return `${minutes}:${seconds.toString().padStart(2,'0')}.${millis.toString().padStart(3,'0')}`;
}

function showPopup(text) {
    if (popupEl) popupEl.textContent = text;
    popupLife = 120; // ~2 seconds
    if (popupEl) popupEl.style.opacity = '1';
    setTimeout(() => { if (popupEl) popupEl.style.opacity = '0'; }, 1500);
}

function saveRun(won) {
    try {
        const runs = JSON.parse(localStorage.getItem('mh_runs') || '[]');
        const finishedMs = totalElapsedMs + (currentGameState === GAME_STATE.PLAYING ? (Date.now() - stageStartTime) : 0);
        runs.unshift({
            ts: Date.now(),
            stages: Math.min(stageIndex, STAGES.length + 1),
            won: !!won,
            timeMs: finishedMs
        });
        while (runs.length > 10) runs.pop();
        localStorage.setItem('mh_runs', JSON.stringify(runs));
    } catch(e) {}
}

function renderLeaderboard() {
    if (!leaderboardList) return;
    let runs = [];
    try { runs = JSON.parse(localStorage.getItem('mh_runs') || '[]'); } catch(e) { runs = []; }
    leaderboardList.innerHTML = '';
    if (!runs.length) {
        const li = document.createElement('li');
        li.textContent = 'No runs yet. Escape if you can.';
        leaderboardList.appendChild(li);
        return;
    }
    runs.forEach(run => {
        const li = document.createElement('li');
        const date = new Date(run.ts);
        li.textContent = `${date.toLocaleDateString()} ${date.toLocaleTimeString()} ‚Äî Stages: ${run.stages} ‚Äî ${msToClock(run.timeMs)}${run.won ? ' ‚úì' : ''}`;
        leaderboardList.appendChild(li);
    });
}

// =============================================================================
// --- MAZE, PATHFINDING, AND SHIFTING ---
// =============================================================================
function generateMaze(w, h) {
    // Create a more interesting, balanced maze using a hybrid approach
    let maze = Array(h).fill(null).map(() => Array(w).fill(1));
    
    // Start with a more open center area
    const centerY = Math.floor(h / 2);
    const centerX = Math.floor(w / 2);
    
    // Create a central hub with multiple paths
    for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
            const ny = centerY + dy;
            const nx = centerX + dx;
            if (ny > 0 && ny < h - 1 && nx > 0 && nx < w - 1) {
                maze[ny][nx] = 0;
            }
        }
    }
    
    // Create main corridors in a cross pattern
    for (let i = 1; i < w - 1; i++) {
        if (i % 3 === 0) { // Vertical corridors
            for (let y = 1; y < h - 1; y++) {
                if (maze[y][i] === 1) maze[y][i] = 0;
            }
        }
    }
    
    for (let i = 1; i < h - 1; i++) {
        if (i % 3 === 0) { // Horizontal corridors
            for (let x = 1; x < w - 1; x++) {
                if (maze[i][x] === 1) maze[i][x] = 0;
            }
        }
    }
    
    // Add diagonal connections to break up the grid
    for (let y = 2; y < h - 2; y += 2) {
        for (let x = 2; x < w - 2; x += 2) {
            if (maze[y][x] === 1 && prng() < 0.4) {
                // Create diagonal paths
                if (maze[y-1][x-1] === 0 && maze[y+1][x+1] === 0) {
                    maze[y][x] = 0;
                } else if (maze[y-1][x+1] === 0 && maze[y+1][x-1] === 0) {
                    maze[y][x] = 0;
                }
            }
        }
    }
    
    // Add some random rooms and open areas
    for (let room = 0; room < 4; room++) {
        const roomSize = 3 + Math.floor(prng() * 3);
        const roomX = 2 + Math.floor(prng() * (w - roomSize - 2));
        const roomY = 2 + Math.floor(prng() * (h - roomSize - 2));
        
        for (let dy = 0; dy < roomSize; dy++) {
            for (let dx = 0; dx < roomSize; dx++) {
                const ny = roomY + dy;
                const nx = roomX + dx;
                if (ny > 0 && ny < h - 1 && nx > 0 && nx < w - 1) {
                    maze[ny][nx] = 0;
                }
            }
        }
    }
    
    // Ensure spawn area is completely open and accessible
    for (let dy = -1; dy <= 2; dy++) {
        for (let dx = -1; dx <= 2; dx++) {
            const ny = 1 + dy;
            const nx = 1 + dx;
            if (ny >= 0 && ny < h && nx >= 0 && nx < w) {
                maze[ny][nx] = 0;
            }
        }
    }
    
    // Ensure exit area is accessible
    const exitY = h - 2;
    const exitX = w - 2;
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            const ny = exitY + dy;
            const nx = exitX + dx;
            if (ny >= 0 && ny < h && nx >= 0 && nx < w) {
                maze[ny][nx] = 0;
            }
        }
    }
    
    // Add some winding paths to break up straight corridors
    for (let path = 0; path < 6; path++) {
        let startX = 1 + Math.floor(prng() * (w - 2));
        let startY = 1 + Math.floor(prng() * (h - 2));
        
        if (maze[startY][startX] === 0) {
            let pathLength = 5 + Math.floor(prng() * 8);
            let currentX = startX;
            let currentY = startY;
            
            for (let step = 0; step < pathLength; step++) {
                const directions = [[1,0], [-1,0], [0,1], [0,-1]];
                const [dx, dy] = directions[Math.floor(prng() * directions.length)];
                
                const nextX = currentX + dx;
                const nextY = currentY + dy;
                
                if (nextX > 0 && nextX < w - 1 && nextY > 0 && nextY < h - 1) {
                    maze[nextY][nextX] = 0;
                    currentX = nextX;
                    currentY = nextY;
                }
            }
        }
    }
    
    // Validate connectivity and fix any isolated areas
    let visited = new Set();
    let queue = [[centerX, centerY]];
    visited.add(`${centerX},${centerY}`);
    
    while (queue.length > 0) {
        const [x, y] = queue.shift();
        const directions = [[1,0], [-1,0], [0,1], [0,-1]];
        
        for (let [dx, dy] of directions) {
            const nx = x + dx;
            const ny = y + dy;
            const key = `${nx},${ny}`;
            
            if (nx >= 0 && nx < w && ny >= 0 && ny < h && maze[ny][nx] === 0 && !visited.has(key)) {
                visited.add(key);
                queue.push([nx, ny]);
            }
        }
    }
    
    // Connect any unreachable areas
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            if (maze[y][x] === 0 && !visited.has(`${x},${y}`)) {
                // Find nearest visited cell and create a path
                let nearestDist = Infinity;
                let nearestCell = null;
                
                for (let vy = 0; vy < h; vy++) {
                    for (let vx = 0; vx < w; vx++) {
                        if (visited.has(`${vx},${vy}`)) {
                            const dist = Math.hypot(x - vx, y - vy);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestCell = [vx, vy];
                            }
                        }
                    }
                }
                
                if (nearestCell) {
                    // Create a path to the nearest visited cell
                    const [vx, vy] = nearestCell;
                    let cx = vx, cy = vy;
                    
                    while (cx !== x || cy !== y) {
                        if (cx !== x) {
                            cx += Math.sign(x - vx);
                            maze[cy][cx] = 0;
                        }
                        if (cy !== y) {
                            cy += Math.sign(y - vy);
                            maze[cy][cx] = 0;
                        }
                    }
                }
            }
        }
    }
    
    // Count walls vs open spaces for debugging
    let walls = 0, open = 0;
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            if (maze[y][x] === 1) walls++;
            else open++;
        }
    }
    
    // Ensure minimum open space (at least 35% open)
    const openPercentage = (open / (walls + open)) * 100;
    if (openPercentage < 35) {
        console.log(`Maze too cramped (${openPercentage.toFixed(1)}% open), adding more open space...`);
        
        // Add more open areas by converting some walls to open space
        for (let y = 1; y < h - 1; y++) {
            for (let x = 1; x < w - 1; x++) {
                if (maze[y][x] === 1 && prng() < 0.15) {
                    maze[y][x] = 0;
                }
            }
        }
        
        // Recalculate
        walls = 0; open = 0;
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                if (maze[y][x] === 1) walls++;
                else open++;
            }
        }
    }
    
    console.log(`Generated maze: ${walls} walls, ${open} open spaces (${(open/(walls+open)*100).toFixed(1)}% open)`);
    
    return maze;
}

function findRandomEmptyCell(floorMap = map) {
    let x, y;
    for(let i=0; i<100; i++) {
        x = Math.floor(prng() * (MAP_SIZE - 2)) + 1;
        y = Math.floor(prng() * (MAP_SIZE - 2)) + 1;
        if (floorMap[y][x] === 0) {
            console.log("Found empty cell at", x, y, "after", i+1, "attempts");
            return { x, y };
        }
    }
    console.error("Failed to find empty cell after 100 attempts in floorMap:", floorMap);
    return null;
}

function findRandomWallAdjacentToFloor() {
    let tries = 0;
    while (tries++ < 400) {
        const x = Math.floor(prng() * (MAP_SIZE - 2)) + 1;
        const y = Math.floor(prng() * (MAP_SIZE - 2)) + 1;
        if (map[y][x] !== 1) continue; // must be a wall
        const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
        let hasOpen = false;
        for (let [dx,dy] of neighbors) {
            if (map[y+dy] && map[y+dy][x+dx] === 0) { hasOpen = true; break; }
        }
        if (hasOpen) return { x, y };
    }
    return null;
}

function findSafeSpawnCell() {
    let cell = null; let tries = 0;
    while (!cell && tries++ < 400) {
        const c = findRandomEmptyCell(map);
        if (!c) break;
        // Ensure not adjacent to many walls (open area) and will be far from later enemies
        const walls = [[1,0],[-1,0],[0,1],[0,-1]].filter(([dx,dy]) => map[c.y+dy] && map[c.y+dy][c.x+dx] === 1).length;
        if (walls <= 1) cell = c;
    }
            return cell || findRandomEmptyCell(map);
}

function shiftMaze() {
    // Safety check: ensure map is initialized for the core shift operation
    if (!map || !Array.isArray(map) || map.length === 0) {
        console.warn("shiftMaze: map not properly initialized, skipping shift");
        return;
    }
    
    // Shift current floor with enhanced failsafe system
    const tempRow = map.pop();
    map.unshift(tempRow);
    
    // Rotate staircases on all floors (only if floors array exists)
    if (floors && Array.isArray(floors) && floors.length > 0) {
        for (let f = 0; f < floors.length; f++) {
            const floor = floors[f];
            if (floor && Array.isArray(floor) && floor.length > 0) {
                const tempRowFloor = floor.pop();
                floor.unshift(tempRowFloor);
            }
        }
    }
    
    // Update floor connections to match new positions (only if they exist)
    if (floorConnections && Array.isArray(floorConnections)) {
        floorConnections.forEach(conn => {
            if (conn && typeof conn.upY === 'number' && typeof conn.downY === 'number') {
                conn.upY = (conn.upY + 1) % MAP_SIZE;
                conn.downY = (conn.downY + 1) % MAP_SIZE;
            }
        });
    }
    
    // Enhanced house shift failsafe for player positioning
    let playerRelocated = false;
    if (map && player && typeof player.x === 'number' && typeof player.y === 'number' && 
        Math.floor(player.y) >= 0 && Math.floor(player.y) < map.length && 
        Math.floor(player.x) >= 0 && Math.floor(player.x) < map[0].length &&
        map[Math.floor(player.y)][Math.floor(player.x)] > 0) {
        // Player is in a wall, try to find adjacent safe tile
        for (let [dx, dy] of [[0,1], [0,-1], [1,0], [-1,0]]) {
             const newX = Math.floor(player.x+dx);
             const newY = Math.floor(player.y+dy);
             if (newY >= 0 && newY < map.length && newX >= 0 && newX < map[0].length && map[newY][newX] === 0) {
                 player.x = newX + 0.5;
                 player.y = newY + 0.5;
                 playerRelocated = true;
                 console.log("House shift: relocated player to adjacent safe tile");
                 break;
             }
        }
        
        // If no adjacent safe tile found, use more aggressive search
        if (!playerRelocated) {
            console.log("House shift: no adjacent safe tile, searching wider area");
            for (let radius = 2; radius <= 4; radius++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        if (Math.abs(dx) + Math.abs(dy) === radius) { // Diamond pattern
                            const nx = Math.floor(player.x) + dx;
                            const ny = Math.floor(player.y) + dy;
                            if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map && ny < map.length && nx < map[0].length && map[ny][nx] === 0) {
                                player.x = nx + 0.5;
                                player.y = ny + 0.5;
                                playerRelocated = true;
                                console.log(`House shift: relocated player to safe tile at distance ${radius}`);
                                break;
                            }
                        }
                    }
                    if (playerRelocated) break;
                }
                if (playerRelocated) break;
            }
        }
        
        // Final failsafe: emergency spawn if still stuck
        if (!playerRelocated) {
            console.log("House shift: emergency spawn - all else failed");
            player.x = 1.5;
            player.y = 1.5;
            message.text = "The house shift was too violent! You've been relocated.";
            message.life = 200;
        }
    }
    message.text = "The house shifts around you!";
    message.life = 150;
    lastShiftTime = Date.now();
    
    // Play house shift sound
    playSound('houseShift', 0.8);

    // Ensure enemies are not stuck in walls after shift
    if (enemies && Array.isArray(enemies)) {
        for (let e of enemies) {
            if (!e || typeof e.x !== 'number' || typeof e.y !== 'number') continue;
            let ex = Math.floor(e.x);
            let ey = Math.floor(e.y);
            if (ey < 0 || ey >= MAP_SIZE || ex < 0 || ex >= MAP_SIZE || 
                !map || ey >= map.length || ex >= map[0].length || map[ey][ex] > 0) {
                // Relocate to a safe random cell not adjacent to player
                let safe = null; let tries = 0;
                while (!safe && tries++ < 200) {
                    const cell = findRandomEmptyCell(map);
                    if (!cell) break;
                    const dist = Math.hypot(cell.x + 0.5 - player.x, cell.y + 0.5 - player.y);
                    if (dist > 3) safe = cell;
                }
                
                // If findRandomEmptyCell failed, try a more aggressive search
                if (!safe) {
                    console.log("House shift: findRandomEmptyCell failed for enemy, trying manual search");
                    for (let radius = 1; radius <= 5; radius++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            for (let dy = -radius; dy <= radius; dy++) {
                                if (Math.abs(dx) + Math.abs(dy) === radius) { // Diamond pattern
                                    const nx = ex + dx;
                                    const ny = ey + dy;
                                    if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && 
                                        ny < map.length && nx < map[0].length && map[ny][nx] === 0) {
                                        const dist = Math.hypot(nx + 0.5 - player.x, ny + 0.5 - player.y);
                                        if (dist > 3) {
                                            safe = { x: nx, y: ny };
                                            break;
                                        }
                                    }
                                }
                            }
                            if (safe) break;
                        }
                        if (safe) break;
                    }
                }
                
                if (safe) { 
                    e.x = safe.x + 0.5; 
                    e.y = safe.y + 0.5; 
                    e.path = []; 
                    console.log(`House shift: relocated enemy to safe position at ${safe.x}, ${safe.y}`);
                } else {
                    console.warn("House shift: could not find safe position for enemy, using emergency spawn");
                    // Emergency fallback: place enemy at a known safe location
                    e.x = 1.5;
                    e.y = 1.5;
                    e.path = [];
                }
            }
        }
    }
    
    // Ensure sprites (containers, items) are not stuck in walls after shift
    if (sprites && Array.isArray(sprites)) {
        for (let i = sprites.length - 1; i >= 0; i--) {
            let sprite = sprites[i];
            if (!sprite || typeof sprite.x !== 'number' || typeof sprite.y !== 'number') continue;
            let sx = Math.floor(sprite.x);
            let sy = Math.floor(sprite.y);
            if (sy < 0 || sy >= MAP_SIZE || sx < 0 || sx >= MAP_SIZE || 
                !map || sy >= map.length || sx >= map[0].length || map[sy][sx] > 0) {
            // Try to find a safe position near the original location
            let safe = null;
            for (let radius = 1; radius <= 3; radius++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        if (Math.abs(dx) + Math.abs(dy) === radius) { // Diamond pattern
                            const nx = sx + dx;
                            const ny = sy + dy;
                            if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
                                safe = { x: nx + 0.5, y: ny + 0.5 };
                                break;
                            }
                        }
                    }
                    if (safe) break;
                }
                if (safe) break;
            }
            
            if (safe) {
                sprite.x = safe.x;
                sprite.y = safe.y;
                console.log(`House shift: relocated ${sprite.type} to safe position`);
            } else {
                // If no safe position found, remove the sprite
                console.log(`House shift: removing ${sprite.type} that couldn't be relocated`);
                sprites.splice(i, 1);
            }
        }
        }
    }
}

function findPath(startX, startY, endX, endY) { // BFS
    // Safety check: ensure map is initialized
    if (!map || !Array.isArray(map) || map.length === 0) {
        console.warn("findPath: map not properly initialized, returning empty path");
        return [];
    }
    
    let queue = [[{x: startX, y: startY}, []]];
    let visited = new Set([`${startX},${startY}`]);

    while(queue.length > 0) {
        let [{x, y}, path] = queue.shift();
        if(x === endX && y === endY) return path;

        for (let [dx, dy] of [[0,1], [0,-1], [1,0], [-1,0]]) {
            let [nx, ny] = [x + dx, y + dy];
            if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && 
                ny < map.length && nx < map[0].length && map[ny][nx] === 0 && !visited.has(`${nx},${ny}`)) {
                visited.add(`${nx},${ny}`);
                let newPath = [...path, {x: nx, y: ny}];
                queue.push([{x: nx, y: ny}, newPath]);
            }
        }
    }
    return [];
}

// New item usage functions
function useSmokeBomb() {
    playSound('smokeBomb', 0.8);
    // Create smoke effect that blocks enemy vision temporarily
    const smokeRadius = 3;
    const smokeDuration = 8000; // 8 seconds
    
    // Find enemies in range and temporarily blind them
    for (let enemy of enemies) {
        const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
        if (dist <= smokeRadius) {
            enemy.blinded = true;
            enemy.blindUntil = Date.now() + smokeDuration;
            // Make them wander randomly while blinded
            enemy.path = [];
            enemy.state = 'BLINDED';
        }
    }
    
    // Also affect stalker if present
    if (stalkerEnemy) {
        const dist = Math.hypot(stalkerEnemy.x - player.x, stalkerEnemy.y - player.y);
        if (dist <= smokeRadius) {
            stalkerEnemy.blinded = true;
            stalkerEnemy.blindUntil = Date.now() + smokeDuration;
            stalkerEnemy.path = [];
        }
    }
    
    message.text = 'Smoke screen deployed! Enemies are temporarily blinded.';
    message.life = 150;
}

function useNoiseMaker() {
    playSound('noiseMaker', 0.9);
    // Create a loud noise that attracts all enemies to a specific location
    const noiseRadius = 6;
    const attractDuration = 5000; // 5 seconds
    
    // Choose a location away from player to attract enemies
    let attractX = player.x + (Math.random() - 0.5) * 8;
    let attractY = player.y + (Math.random() - 0.5) * 8;
    
    // Ensure the location is within bounds and accessible
    attractX = Math.max(1, Math.min(MAP_SIZE - 2, attractX));
    attractY = Math.max(1, Math.min(MAP_SIZE - 2, attractY));
    
    // Make all enemies in range move toward the noise
    for (let enemy of enemies) {
        const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
        if (dist <= noiseRadius) {
            enemy.attractedTo = { x: attractX, y: attractY };
            enemy.attractedUntil = Date.now() + attractDuration;
            enemy.state = 'ATTRACTED';
            // Clear current path and set new target
            enemy.path = findPath(Math.floor(enemy.x), Math.floor(enemy.y), Math.floor(attractX), Math.floor(attractY));
        }
    }
    
    // Also affect stalker if present
    if (stalkerEnemy) {
        const dist = Math.hypot(stalkerEnemy.x - player.x, stalkerEnemy.y - player.y);
        if (dist <= noiseRadius) {
            stalkerEnemy.attractedTo = { x: attractX, y: attractY };
            stalkerEnemy.attractedUntil = Date.now() + attractDuration;
            stalkerEnemy.state = 'ATTRACTED';
            stalkerEnemy.path = findPath(Math.floor(stalkerEnemy.x), Math.floor(stalkerEnemy.y), Math.floor(attractX), Math.floor(attractY));
        }
    }
    
    message.text = 'Noise maker activated! Enemies are attracted to the sound.';
    message.life = 150;
}


// =============================================================================
// --- INPUT HANDLING ---
// =============================================================================
const isMobile = 'ontouchstart' in window;

function setupInputs() {
    if (isMobile) {
        mobileControls.style.display = 'block';
        const joyThumb = document.getElementById('joystick-thumb');
        const joyBase = document.getElementById('joystick-base').getBoundingClientRect();
        touchState = { move: null, look: null, joyCenter: { x: joyBase.left + joyBase.width/2, y: joyBase.top + joyBase.height/2 } };

        canvas.addEventListener('touchstart', e => {
            // Block touch input if game is paused
            if (currentGameState === GAME_STATE.PAUSED) return;
            
            for (let touch of e.changedTouches) {
                if (touch.clientX < window.innerWidth / 2) {
                    touchState.move = { id: touch.identifier, startX: touch.clientX, startY: touch.clientY, currentX: touch.clientX, currentY: touch.clientY };
                } else {
                    touchState.look = { id: touch.identifier, lastX: touch.clientX };
                }
            }
        });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            // Block touch input if game is paused
            if (currentGameState === GAME_STATE.PAUSED) return;
            
            for (let touch of e.changedTouches) {
                if(touchState.move && touch.identifier === touchState.move.id){
                    touchState.move.currentX = touch.clientX;
                    touchState.move.currentY = touch.clientY;
                    let dx = touch.clientX - touchState.joyCenter.x;
                    let dy = touch.clientY - touchState.joyCenter.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    let clampedDist = Math.min(dist, joyBase.width/2 - 30);
                    joyThumb.style.transform = `translate(${clampedDist * dx/dist}px, ${clampedDist * dy/dist}px)`;
                }
                if(touchState.look && touch.identifier === touchState.look.id){
                    player.angle += (touch.clientX - touchState.look.lastX) * ROTATION_SPEED * 2.5;
                    touchState.look.lastX = touch.clientX;
                }
            }
        });
        canvas.addEventListener('touchend', e => {
             for (let touch of e.changedTouches) {
                if(touchState.move && touch.identifier === touchState.move.id) { touchState.move = null; joyThumb.style.transform = `translate(0px, 0px)`; }
                if(touchState.look && touch.identifier === touchState.look.id) touchState.look = null;
            }
        });
        document.getElementById('hide-button').addEventListener('touchstart', e => { 
            e.preventDefault(); 
            // Block hide button if game is paused
            if (currentGameState === GAME_STATE.PAUSED) return;
            tryToggleHide(); 
        });
        
        // New mobile button handlers
        document.getElementById('interact-button').addEventListener('touchstart', e => {
            e.preventDefault();
            if (currentGameState === GAME_STATE.PAUSED) return;
            tryInteract();
        });
        
        document.getElementById('door-button').addEventListener('touchstart', e => {
            e.preventDefault();
            if (currentGameState === GAME_STATE.PAUSED) return;
            tryOpenDoor();
        });
        
        document.getElementById('flashlight-button').addEventListener('touchstart', e => {
            e.preventDefault();
            if (currentGameState === GAME_STATE.PAUSED) return;
            if (inventory.flashlight) {
                inventory.flashlight = !inventory.flashlight;
                if (hudFlash) hudFlash.textContent = inventory.flashlight ? 'On' : 'Off';
            }
        });
    } else {
        document.addEventListener('keydown', e => {
            // Block input if game is paused
            if (currentGameState === GAME_STATE.PAUSED) return;
            
            keys[e.key.toLowerCase()] = true;
            
            // Handle immediate actions on keydown
            if (e.key.toLowerCase() === 'h') {
                console.log("H key pressed, current game state:", currentGameState, "calling tryToggleHide...");
                tryToggleHide();
            }
            if (e.key.toLowerCase() === 'e') {
                console.log("E key pressed, current game state:", currentGameState, "calling tryInteract...");
                tryInteract();
            }
            if (e.key === ' ' || e.code === 'Space') {
                // Check if player is on stairs first
                const playerTileX = Math.floor(player.x);
                const playerTileY = Math.floor(player.y);
                if (map[playerTileY][playerTileX] === 5) { // Stairs up
                    useStairs('up');
                } else if (map[playerTileY][playerTileX] === 6) { // Stairs down
                    useStairs('down');
                } else {
                    // Default door opening behavior
                    tryOpenDoor();
                }
            }
            if (e.key.toLowerCase() === 'f' && inventory.flashlight) { 
                inventory.flashlight = !inventory.flashlight; 
                if (hudFlash) hudFlash.textContent = inventory.flashlight ? 'On' : 'Off'; 
            }
            if (e.key.toLowerCase() === 'v' && inventory.vitamins > 0) { 
                inventory.vitamins -= 1; 
                inventory.vitActiveUntil = Date.now() + 6000; 
                message.text = 'Speed surge!'; 
                message.life = 120; 
                if (hudVits) hudVits.textContent = String(inventory.vitamins); 
            }
            // New abilities
            if (e.key.toLowerCase() === 'c') {
                playerAbilities.crouching = !playerAbilities.crouching;
                playerAbilities.stealthMode = playerAbilities.crouching;
                message.text = playerAbilities.crouching ? 'Crouching - Stealth mode active' : 'Standing - Normal mode';
                message.life = 120;
            }
            if (e.key.toLowerCase() === 'q' && inventory.smokeBomb > 0) {
                inventory.smokeBomb--;
                useSmokeBomb();
                message.text = 'Smoke bomb deployed!';
                message.life = 120;
            }
            if (e.key.toLowerCase() === 'z' && inventory.noiseMaker > 0) {
                inventory.noiseMaker--;
                useNoiseMaker();
                message.text = 'Noise maker activated!';
                message.life = 120;
            }
            // Debug: Manual floor change (F1 for up, F2 for down)
            if (e.key === 'F1') {
                if (currentFloor < floors.length - 1) {
                    currentFloor++;
                    map = floors[currentFloor];
                    message.text = `Debug: Manually moved to floor ${currentFloor + 1}`; message.life = 150;
                    console.log("Manual floor change to:", currentFloor);
                } else {
                    message.text = "Already on top floor"; message.life = 100;
                }
            }
            if (e.key === 'F2') {
                if (currentFloor > 0) {
                    currentFloor--;
                    map = floors[currentFloor];
                    message.text = `Debug: Manually moved to floor ${currentFloor + 1}`; message.life = 150;
                    console.log("Manual floor change to:", currentFloor);
                } else {
                    message.text = "Already on bottom floor"; message.life = 100;
                }
            }
        });
        document.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
        });
        document.addEventListener('mousemove', e => {
            if (currentGameState === GAME_STATE.PLAYING && document.pointerLockElement === canvas) {
                player.angle += e.movementX * ROTATION_SPEED * (settings.sens||1);
            }
        });
    }

    mainMenu.addEventListener('click', () => {
        if ([GAME_STATE.MENU, GAME_STATE.GAMEOVER, GAME_STATE.WON].includes(currentGameState)) {
            startRun();
            currentGameState = GAME_STATE.PLAYING;
            mainMenu.style.opacity = '0';
            mainMenu.style.pointerEvents = 'none';
            hud.style.display = 'block';
            // Hide any open panels
            if (pauseMenu) pauseMenu.style.display = 'none';
            if (settingsPanel) settingsPanel.style.display = 'none';
            if (summaryPanel) summaryPanel.style.display = 'none';
            if (!isMobile) canvas.requestPointerLock();
        }
    });

    if (dailyBtn) {
        dailyBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const d = new Date();
            const seedStr = `${d.getUTCFullYear()}-${(d.getUTCMonth()+1).toString().padStart(2,'0')}-${d.getUTCDate().toString().padStart(2,'0')}`;
            if (seedInput) seedInput.value = seedStr;
        });
    }

    document.addEventListener('pointerlockchange', () => {
        if (document.pointerLockElement !== canvas && currentGameState === GAME_STATE.PLAYING) {
            // Pause the game when pointer lock is lost
            currentGameState = GAME_STATE.PAUSED;
            pauseMenu.style.display = 'block';
            // Keep HUD visible during pause
        }
    });

    // Pause and settings
    document.addEventListener('keydown', e => {
        if (e.key === 'Escape') {
            if (currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.HIDDEN) {
                // Pause the game
                currentGameState = GAME_STATE.PAUSED;
                pauseMenu.style.display = 'block';
                // Don't change mainMenu opacity here - keep it hidden
            } else if (currentGameState === GAME_STATE.PAUSED) {
                // Resume the game
                currentGameState = GAME_STATE.PLAYING;
                pauseMenu.style.display = 'none';
                // Don't change mainMenu - it should stay hidden during gameplay
                if (!isMobile) canvas.requestPointerLock();
            } else if (summaryPanel.style.display === 'block') {
                // Close summary panel with Escape key
                summaryPanel.style.display = 'none';
            }
        }
    });
    if (btnResume) btnResume.addEventListener('click', () => {
        // Resume the game - restore previous state
        if (currentGameState === GAME_STATE.PAUSED) {
            // Determine what state to return to based on what was active before pause
            // If player was hidden, return to hidden state
            if (player.closetEntryTime) {
                currentGameState = GAME_STATE.HIDDEN;
            } else {
                currentGameState = GAME_STATE.PLAYING;
            }
        }
        pauseMenu.style.display = 'none';
        // Ensure HUD is visible when resuming
        if (hud) hud.style.display = 'block';
        if (!isMobile) canvas.requestPointerLock();
    });
    if (btnRestart) btnRestart.addEventListener('click', () => {
        // Only restart if we're not in the middle of a run
        if (currentGameState === GAME_STATE.MENU) {
            startRun();
        } else {
            // Reset current stage but keep run progress
            resetGame();
        }
        // Return to playing state after restart
        currentGameState = GAME_STATE.PLAYING;
        pauseMenu.style.display = 'none';
        // Ensure HUD is visible when restarting
        if (hud) hud.style.display = 'block';
        if (!isMobile) canvas.requestPointerLock();
    });
    if (btnSettings) btnSettings.addEventListener('click', () => { settingsPanel.style.display = 'block'; });
    if (btnCloseSettings) btnCloseSettings.addEventListener('click', () => { settingsPanel.style.display = 'none'; });
    if (btnSummaryClose) btnSummaryClose.addEventListener('click', () => { summaryPanel.style.display = 'none'; });

    // Initialize settings UI
    if (optSens) optSens.value = settings.sens;
    if (optBright) optBright.value = settings.bright;
    if (optVol) optVol.value = settings.vol;
    if (optAudioCues) optAudioCues.checked = settings.audioCues;
    if (optScale) optScale.value = settings.scale;
    const saveSettings = () => { localStorage.setItem('mh_settings', JSON.stringify(settings)); };
    if (optSens) optSens.addEventListener('input', () => { settings.sens = parseFloat(optSens.value); saveSettings(); });
    if (optBright) optBright.addEventListener('input', () => { settings.bright = parseFloat(optBright.value); saveSettings(); });
    if (optVol) optVol.addEventListener('input', () => { settings.vol = parseFloat(optVol.value); saveSettings(); });
    if (optAudioCues) optAudioCues.addEventListener('change', () => { audioCues.enabled = optAudioCues.checked; settings.audioCues = optAudioCues.checked; saveSettings(); });
    if (optScale) optScale.addEventListener('input', () => { settings.scale = parseFloat(optScale.value); resizeCanvasScale(); saveSettings(); });
}

function tryInteract() {
    const px = Math.floor(player.x);
    const py = Math.floor(player.y);
    
    // Check for stairs interaction (standing on stairs)
    if (map[py][px] === 5) { // Stairs up
        useStairs('up');
        return;
    } else if (map[py][px] === 6) { // Stairs down
        useStairs('down');
        return;
    }
    
    // Open container or toggle hide
    if (map[py][px] === 4) {
        tryToggleHide();
        return;
    }
    
    // Check for container in front of player
    const ix = Math.floor(player.x + Math.cos(player.angle) * 0.8);
    const iy = Math.floor(player.y + Math.sin(player.angle) * 0.8);
    let nearest = null;
    let minD = 0.9;
    for (let s of sprites) {
        if (s.type === 'container') {
            const d = Math.hypot(s.x - player.x, s.y - player.y);
            if (d < minD && Math.floor(s.x) === ix && Math.floor(s.y) === iy) { nearest = s; minD = d; }
        }
    }
    if (nearest) {
        if (!nearest.opened) {
            nearest.opened = true;
            nearest.texture = assets.containerOpen;
            if (nearest.contains && nearest.contains.type === 'goldKey') {
                player.hasGoldKey = true;
                message.text = 'You found the GOLD key!';
                message.life = 200;
            } else {
                // Chance to spawn a bronze key on opening if none found yet
                if (!player.hasBronzeKey && prng() < 0.35) {
                    player.hasBronzeKey = true;
                    message.text = 'You found a bronze key.';
                    message.life = 150;
                } else {
                    message.text = 'It is empty.';
                    message.life = 100;
                }
            }
        } else {
            message.text = 'Already searched.';
            message.life = 80;
        }
        return;
    }

    // If facing a closet wall, use the main toggle function instead of duplicating logic
    if (ix>=0 && ix<MAP_SIZE && iy>=0 && iy<MAP_SIZE && map[iy][ix] === 4) {
        tryToggleHide();
        return;
    }
    
    // Check for stairs interaction (facing stairs)
    if (ix>=0 && ix<MAP_SIZE && iy>=0 && iy<MAP_SIZE) {
        if (map[iy][ix] === 5) { // Stairs up
            useStairs('up');
            return;
        } else if (map[iy][ix] === 6) { // Stairs down
            useStairs('down');
            return;
        }
    }
}

// generateMap function removed - no longer needed with the new floor system

// spawnEnemies function removed - no longer needed with the new floor system

// placeSprites function removed - no longer needed with the new floor system

function useStairs(direction) {
    if (direction === 'up') {
        if (currentFloor < floors.length - 1) {
            currentFloor++;
            map = floors[currentFloor];
            
            // Find stairs down on the new floor
            let stairsDown = null;
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (map[y][x] === 6) { // Stairs down
                        stairsDown = {x: x, y: y};
                        break;
                    }
                }
                if (stairsDown) break;
            }
            
            if (stairsDown) {
                // Find a safe position adjacent to the stairs
                let safePosition = findSafePositionNearStairs(stairsDown.x, stairsDown.y);
                if (safePosition) {
                    player.x = safePosition.x;
                    player.y = safePosition.y;
                    message.text = `You climb to floor ${currentFloor + 1}.`;
                    message.life = 150;
                    playSound('footsteps', 0.6);
                    
                    // Update HUD floor display
                    if (hudFloorEl) hudFloorEl.textContent = `${currentFloor + 1}`;
                    
                    // Reset enemies for new floor
                    enemies = [];
                    const count = enemiesForStage();
                    for (let i = 0; i < count; i++) {
                        let enemySpawn = findRandomEmptyCell(map);
                        if (enemySpawn) {
                            let enemyType = prng() < 0.3 ? 'hunter' : prng() < 0.5 ? 'ambusher' : 'patrol';
                            enemies.push({ 
                                x: enemySpawn.x + 0.5, 
                                y: enemySpawn.y + 0.5, 
                                path: [], 
                                state: 'PATROL',
                                type: enemyType,
                                lastSeenPlayer: null,
                                hearingRange: enemyType === 'hunter' ? 8 : enemyType === 'ambusher' ? 6 : 4,
                                memory: enemyType === 'hunter' ? 10000 : enemyType === 'ambusher' ? 8000 : 5000,
                                speed: enemyType === 'hunter' ? currentEnemySpeed * 1.2 : currentEnemySpeed,
                                stealth: enemyType === 'hunter' ? 0.7 : 1.0,
                                currentFloor: currentFloor // Track which floor this enemy is on
                            });
                        }
                    }
                    
                    // Reset sprites for new floor
                    sprites = [];
                    // Place items on new floor
                    for (let i = 0; i < 2 + Math.floor(prng()*2); i++) {
                        let keyPos = findRandomEmptyCell(map);
                        if (keyPos) {
                            sprites.push({ x: keyPos.x + 0.5, y: keyPos.y + 0.5, type: 'bronzeKey', texture: assets.bronzeKeySprite });
                        }
                    }
                    if (prng() < 0.6) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'flashlight', texture: assets.flashlightSprite }); }
                    if (prng() < 0.6) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'vitamins', texture: assets.vitaminsSprite }); }
                    if (prng() < 0.5) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'lockpick', texture: assets.lockpickSprite }); }
                    
                    console.log(`Successfully moved to floor ${currentFloor + 1} at position ${player.x}, ${player.y}`);
                } else {
                    message.text = "These stairs lead to a dead end!";
                    message.life = 120;
                    currentFloor--; // Go back
                    map = floors[currentFloor];
                }
            } else {
                message.text = "These stairs lead to a dead end!";
                message.life = 120;
                currentFloor--; // Go back
                map = floors[currentFloor];
            }
        } else {
            message.text = "You are already on the top floor.";
            message.life = 120;
        }
    } else if (direction === 'down') {
        if (currentFloor > 0) {
            currentFloor--;
            map = floors[currentFloor];
            
            // Find stairs up on the new floor
            let stairsUp = null;
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (map[y][x] === 5) { // Stairs up
                        stairsUp = {x: x, y: y};
                        break;
                    }
                }
                if (stairsUp) break;
            }
            
            if (stairsUp) {
                // Find a safe position adjacent to the stairs
                let safePosition = findSafePositionNearStairs(stairsUp.x, stairsUp.y);
                if (safePosition) {
                    player.x = safePosition.x;
                    player.y = safePosition.y;
                    message.text = `You descend to floor ${currentFloor + 1}.`;
                    message.life = 150;
                    playSound('footsteps', 0.6);
                    
                    // Update HUD floor display
                    if (hudFloorEl) hudFloorEl.textContent = `${currentFloor + 1}`;
                    
                    // Reset enemies for new floor
                    enemies = [];
                    const count = enemiesForStage();
                    for (let i = 0; i < count; i++) {
                        let enemySpawn = findRandomEmptyCell(map);
                        if (enemySpawn) {
                            let enemyType = prng() < 0.3 ? 'hunter' : prng() < 0.5 ? 'ambusher' : 'patrol';
                            enemies.push({ 
                                x: enemySpawn.x + 0.5, 
                                y: enemySpawn.y + 0.5, 
                                path: [], 
                                state: 'PATROL',
                                type: enemyType,
                                lastSeenPlayer: null,
                                hearingRange: enemyType === 'hunter' ? 8 : enemyType === 'ambusher' ? 6 : 4,
                                memory: enemyType === 'hunter' ? 10000 : enemyType === 'ambusher' ? 8000 : 5000,
                                speed: enemyType === 'hunter' ? currentEnemySpeed * 1.2 : currentEnemySpeed,
                                stealth: enemyType === 'hunter' ? 0.7 : 1.0,
                                currentFloor: currentFloor // Track which floor this enemy is on
                            });
                        }
                    }
                    
                    // Reset sprites for new floor
                    sprites = [];
                    // Place items on new floor
                    for (let i = 0; i < 2 + Math.floor(prng()*2); i++) {
                        let keyPos = findRandomEmptyCell(map);
                        if (keyPos) {
                            sprites.push({ x: keyPos.x + 0.5, y: keyPos.y + 0.5, type: 'bronzeKey', texture: assets.bronzeKeySprite });
                        }
                    }
                    if (prng() < 0.6) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'flashlight', texture: assets.flashlightSprite }); }
                    if (prng() < 0.6) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'vitamins', texture: assets.vitaminsSprite }); }
                    if (prng() < 0.5) { let p = findRandomEmptyCell(map); if (p) sprites.push({ x: p.x + 0.5, y: p.y + 0.5, type: 'lockpick', texture: assets.lockpickSprite }); }
                    
                    console.log(`Successfully moved to floor ${currentFloor + 1} at position ${player.x}, ${player.y}`);
                } else {
                    message.text = "These stairs lead to a dead end!";
                    message.life = 120;
                    currentFloor++; // Go back
                    map = floors[currentFloor];
                }
            } else {
                message.text = "These stairs lead to a dead end!";
                message.life = 120;
                currentFloor++; // Go back
                map = floors[currentFloor];
            }
        } else {
            message.text = "You are already on the bottom floor.";
            message.life = 120;
        }
    }
}

function tryOpenDoor() {
    const pTileX = Math.floor(player.x), pTileY = Math.floor(player.y);
    if (map[pTileY][pTileX] === 3) {
        if (player.hasGoldKey) {
            playSound('doorCreak', 0.8);
            setTimeout(() => playSound('doorOpen', 1.0), 500);
            nextStageOrWin();
        } else {
            message.text = 'The golden lock won\'t budge without the key.';
            message.life = 120;
        }
        return;
    }
    // If standing adjacent facing a door, allow open
    const fx = Math.floor(player.x + Math.cos(player.angle) * 0.7);
    const fy = Math.floor(player.y + Math.sin(player.angle) * 0.7);
    if (fx >= 0 && fx < MAP_SIZE && fy >= 0 && fy < MAP_SIZE) {
        if (map[fy][fx] === 3) {
            if (player.hasGoldKey) {
                playSound('doorCreak', 0.8);
                setTimeout(() => playSound('doorOpen', 1.0), 500);
                nextStageOrWin();
            }
            else { message.text = 'You need the gold key.'; message.life = 120; }
        } else if (map[fy][fx] === 2) {
            if (player.hasBronzeKey) { 
                playSound('doorCreak', 0.6);
                setTimeout(() => playSound('doorOpen', 0.8), 300);
                map[fy][fx] = 0; 
                player.hasBronzeKey = false; 
                message.text = 'Bronze door unlocked.'; 
                message.life = 120; 
            }
            else if (inventory.lockpick > 0) { 
                playSound('doorCreak', 0.7);
                setTimeout(() => playSound('doorOpen', 0.9), 400);
                map[fy][fx] = 0; 
                inventory.lockpick -= 1; 
                message.text = 'Picked the lock.'; 
                message.life = 120; 
            }
            else { message.text = 'This door needs a bronze key.'; message.life = 120; }
        }
    }
}

function checkClosetSafety() {
    // Check if player is near a closet that can be safely entered and exited
    const playerTileX = Math.floor(player.x);
    const playerTileY = Math.floor(player.y);
    
    // Check if player is on a closet tile
    if (map[playerTileY][playerTileX] === 4) {
        // Check if there's a safe exit from this closet
        return hasSafeExit(playerTileX, playerTileY);
    }
    
    // Check if player is facing a closet
    const facingX = Math.floor(player.x + Math.cos(player.angle) * 0.7);
    const facingY = Math.floor(player.y + Math.sin(player.angle) * 0.7);
    if (facingX >= 0 && facingX < MAP_SIZE && facingY >= 0 && facingY < MAP_SIZE && map[facingY][facingX] === 4) {
        // Check if there's a safe exit from this closet
        return hasSafeExit(facingX, facingY);
    }
    
    return false;
}

function hasSafeExit(closetX, closetY) {
    // Check all 4 directions for open tiles in front of the closet
    const directions = [[1,0], [-1,0], [0,1], [0,-1]];
    
    for (let [dx, dy] of directions) {
        const nx = closetX + dx;
        const ny = closetY + dy;
        
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            // Check if this exit position is truly accessible
            if (isPositionAccessible(nx, ny)) {
                // Additional check: ensure there's a path away from the closet
                let hasPathAway = false;
                const pathDirections = [[1,0], [-1,0], [0,1], [0,-1]];
                
                for (let [pdx, pdy] of pathDirections) {
                    const px = nx + pdx;
                    const py = ny + pdy;
                    if (px >= 0 && px < MAP_SIZE && py >= 0 && py < MAP_SIZE && map[py][px] === 0) {
                        if (px !== closetX || py !== closetY) { // Not back into the closet
                            hasPathAway = true;
                            break;
                        }
                    }
                }
                
                if (hasPathAway) {
                    return true;
                }
            }
        }
    }
    
    return false;
}

function tryToggleHide() {
    console.log("tryToggleHide called, current state:", currentGameState);
    
    // If player is already hidden, handle exit
    if (currentGameState === GAME_STATE.HIDDEN) {
        console.log("Player is hidden, handling exit...");
        handleClosetExit();
        return;
    }
    
    // Handle entering closet (only when in PLAYING state)
    if (currentGameState === GAME_STATE.PLAYING) {
        let playerTileX = Math.floor(player.x);
        let playerTileY = Math.floor(player.y);
        // Closet can be either under player (floor closet) or in front if closet is a wall tile
        let facingX = Math.floor(player.x + Math.cos(player.angle) * 0.7);
        let facingY = Math.floor(player.y + Math.sin(player.angle) * 0.7);
        const onCloset = map[playerTileY][playerTileX] === 4;
        const facingCloset = (facingX >=0 && facingX < MAP_SIZE && facingY >= 0 && facingY < MAP_SIZE && map[facingY][facingX] === 4);
        console.log("Player at", playerTileX, playerTileY, "onCloset:", onCloset, "facingCloset:", facingCloset, "map tile:", map[playerTileY][playerTileX]);
        
        if(onCloset || facingCloset) {
            // Check if we can actually exit before entering hidden state
            let canExit = false;
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (map[y][x] === 4) { // Found a closet
                        // Check if there's an accessible open tile in front of it
                        const directions = [[1,0], [-1,0], [0,1], [0,-1]];
                        for (let [dx, dy] of directions) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
                                // Check if this position is accessible
                                let accessible = false;
                                const checkDirections = [[1,0], [-1,0], [0,1], [0,-1]];
                                for (let [cdx, cdy] of checkDirections) {
                                    const cx = nx + cdx;
                                    const cy = ny + cdy;
                                    if (cx >= 0 && cx < MAP_SIZE && cy >= 0 && cy < MAP_SIZE && map[cy][cx] === 0) {
                                        accessible = true;
                                        break;
                                    }
                                }
                                if (accessible) {
                                    canExit = true;
                                    break;
                                }
                            }
                        }
                        if (canExit) break;
                    }
                }
                if (canExit) break;
            }
            
            if (!canExit) {
                message.text = "This closet is too cramped to hide in safely."; message.life = 120;
                return;
            }
            
            // Position player to see through the closet slit
            if (onCloset) {
                // Player is on a closet floor tile - position them to face the opening
                const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
                let facingDirection = null;
                for (let [dx,dy] of neighbors) {
                    const nx = playerTileX + dx;
                    const ny = playerTileY + dy;
                    if (nx>=0 && nx<MAP_SIZE && ny>=0 && ny<MAP_SIZE && map[ny][nx] === 1) {
                        // Found a wall - face away from it (toward the opening)
                        facingDirection = [-dx, -dy];
                        break;
                    }
                }
                if (facingDirection) {
                    player.angle = Math.atan2(facingDirection[1], facingDirection[0]);
                }
            } else if (facingCloset) {
                // Player is facing a closet wall - position them inside
                const closetX = facingX;
                const closetY = facingY;
                // Find the opening direction
                const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
                for (let [dx,dy] of neighbors) {
                    const nx = closetX + dx;
                    const ny = closetY + dy;
                    if (nx>=0 && nx<MAP_SIZE && ny>=0 && ny<MAP_SIZE && map[ny][nx] === 0) {
                        // This is the opening - move player to the closet interior
                        const interiorX = closetX - dx;
                        const interiorY = closetY - dy;
                        if (interiorX>=0 && interiorX<MAP_SIZE && interiorY>=0 && interiorY<MAP_SIZE && map[interiorY][interiorX] === 0) {
                            player.x = interiorX + 0.5;
                            player.y = interiorY + 0.5;
                            // Face toward the opening
                            player.angle = Math.atan2(dy, dx);
                            break;
                        }
                    }
                }
            }
            
            currentGameState = GAME_STATE.HIDDEN;
            player.closetEntryTime = Date.now(); // Track when player entered closet
            message.text = "You are hidden in the closet. Press H to exit."; message.life = 200;
            if (hiddenIndicator) hiddenIndicator.style.display = 'block';
            
            // Play closet opening sound
            playSound('closetOpen', 0.8);
            
            console.log("Entered hidden state, new state:", currentGameState);
            
            // Ensure player is facing away from the closet wall for better visibility
            if (onCloset || facingCloset) {
                const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
                for (let [dx,dy] of neighbors) {
                    const nx = Math.floor(player.x) + dx;
                    const ny = Math.floor(player.y) + dy;
                    if (nx>=0 && nx<MAP_SIZE && ny>=0 && ny<MAP_SIZE && map[ny][nx] === 1) {
                        // Face away from the wall
                        player.angle = Math.atan2(-dy, -dx);
                        break;
                    }
                }
            }
        }
    } else {
        message.text = "Nowhere to hide here."; message.life = 100;
    }
}

function handleClosetExit() {
    console.log("Attempting to exit closet... current state:", currentGameState, "player position:", player.x, player.y);
    
    // Improved exit strategy with wall collision checks and house shift consideration
    let placed = false;
    let exitPositions = [];
    
    // Strategy 1: Find all closet openings and validate them
    // Note: The map may have shifted while player was hidden, so we need to find
    // the best available exit position regardless of where the player originally entered
    for (let y = 0; y < MAP_SIZE; y++) {
        for (let x = 0; x < MAP_SIZE; x++) {
            if (map[y][x] === 4) { // Found a closet
                // Check all 4 directions for open tiles in front of the closet
                const directions = [[1,0], [-1,0], [0,1], [0,-1]];
                for (let [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
                        // Validate this position is truly accessible and not a wall
                        if (isPositionAccessible(nx, ny) && !isWallCollision(nx, ny)) {
                            // Additional check: ensure this exit has a clear path away from the closet
                            let hasClearPath = false;
                            const pathDirections = [[1,0], [-1,0], [0,1], [0,-1]];
                            for (let [pdx, pdy] of pathDirections) {
                                const px = nx + pdx;
                                const py = ny + pdy;
                                if (px >= 0 && px < MAP_SIZE && py >= 0 && py < MAP_SIZE && map[py][px] === 0) {
                                    if (px !== x || py !== y) { // Not back into the closet
                                        hasClearPath = true;
                                        break;
                                    }
                                }
                            }
                            
                            if (hasClearPath) {
                                exitPositions.push({
                                    x: nx, y: ny,
                                    closetX: x, closetY: y,
                                    dx: dx, dy: dy,
                                    accessibility: countAccessibleNeighbors(nx, ny),
                                    pathQuality: hasClearPath ? 1 : 0
                                });
                            }
                        }
                    }
                }
            }
        }
    }
    
    // Sort by accessibility and path quality (most accessible with clear paths first)
    exitPositions.sort((a, b) => {
        if (a.pathQuality !== b.pathQuality) return b.pathQuality - a.pathQuality;
        return b.accessibility - a.accessibility;
    });
    
    // Try to place player in the best accessible position
    console.log("Found", exitPositions.length, "exit positions, attempting placement...");
    for (let pos of exitPositions) {
        if (isPositionAccessible(pos.x, pos.y) && !isWallCollision(pos.x, pos.y)) {
            player.x = pos.x + 0.5;
            player.y = pos.y + 0.5;
            // Face away from the closet
            player.angle = Math.atan2(pos.dy, pos.dx);
            placed = true;
            console.log("Placed player at validated exit position:", pos.x, pos.y, "accessibility:", pos.accessibility, "pathQuality:", pos.pathQuality);
            break;
        }
    }
    
    // Strategy 2: If no closet exits work, find any safe open area
    // This is especially important after house shifts when the original closet may have moved
    if (!placed) {
        let bestPosition = findBestSafePosition();
        if (bestPosition && !isWallCollision(bestPosition.x, bestPosition.y)) {
            player.x = bestPosition.x + 0.5;
            player.y = bestPosition.y + 0.5;
            placed = true;
            console.log("Placed player in fallback safe position at", bestPosition.x, bestPosition.y, "(house shift fallback)");
        }
    }
    
    // Strategy 3: Emergency spawn area (guaranteed to work)
    // This handles extreme cases where house shifts have made all other positions inaccessible
    if (!placed) {
        player.x = 1.5;
        player.y = 1.5;
        placed = true;
        console.log("Emergency fallback: placed player at spawn area (house shift debug emergency)");
    }
    
    console.log("About to change game state from HIDDEN to PLAYING");
    currentGameState = GAME_STATE.PLAYING;
    player.closetEntryTime = null; // Reset closet entry time
    message.text = "You emerge from the darkness."; message.life = 120;
    if (hiddenIndicator) hiddenIndicator.style.display = 'none';
    
    // Play closet closing sound
    playSound('closetClose', 0.6);
    
    console.log("Successfully exited closet, new state:", currentGameState, "placed at:", player.x, player.y);
}


// =============================================================================
// --- CORE GAME LOGIC (UPDATE) ---
// =============================================================================
function handleMovement() {
    if (currentGameState !== GAME_STATE.PLAYING) return;
    let dx = 0, dy = 0;
    
    // Keyboard input
    if (keys['w']) { dx += Math.cos(player.angle); dy += Math.sin(player.angle); }
    if (keys['s']) { dx -= Math.cos(player.angle); dy -= Math.sin(player.angle); }
    if (keys['a']) { dx += Math.cos(player.angle - Math.PI/2); dy += Math.sin(player.angle - Math.PI/2); }
    if (keys['d']) { dx += Math.cos(player.angle + Math.PI/2); dy += Math.sin(player.angle + Math.PI/2); }
    
    // Gamepad input
    if (gamepad && gamepadState.leftStick.x !== 0 || gamepadState.leftStick.y !== 0) {
        const stickX = gamepadState.leftStick.x;
        const stickY = gamepadState.leftStick.y;
        
        // Forward/backward movement
        if (stickY !== 0) {
            dx += Math.cos(player.angle) * stickY;
            dy += Math.sin(player.angle) * stickY;
        }
        
        // Strafe movement
        if (stickX !== 0) {
            dx += Math.cos(player.angle + Math.PI/2) * stickX;
            dy += Math.sin(player.angle + Math.PI/2) * stickX;
        }
    }
    
    // Right stick for looking
    if (gamepad && (gamepadState.rightStick.x !== 0 || gamepadState.rightStick.y !== 0)) {
        const lookSensitivity = 0.03;
        player.angle += gamepadState.rightStick.x * lookSensitivity;
    }
    
    // Mobile input
    if (isMobile && touchState.move) {
        let moveX = touchState.move.currentX - touchState.joyCenter.x;
        let moveY = touchState.move.currentY - touchState.joyCenter.y;
        let angle = Math.atan2(moveY, moveX);
        let dist = Math.min(Math.sqrt(moveX*moveX + moveY*moveY) / 60, 1);
        
        let forward = -Math.sin(angle - player.angle - Math.PI/2) * dist;
        let strafe = Math.cos(angle - player.angle - Math.PI/2) * dist;

        dx += Math.cos(player.angle) * forward + Math.cos(player.angle + Math.PI/2) * strafe;
        dy += Math.sin(player.angle) * forward + Math.sin(player.angle + Math.PI/2) * strafe;
    }

    let mag = Math.sqrt(dx*dx + dy*dy);
    if(mag > 0) {
        // Sprint mechanics
        const sprinting = !!keys['shift'] && player.stamina > 0.1;
        const vitBoost = (inventory.vitActiveUntil||0) > Date.now() ? 1.35 : 1;
        const crouchModifier = playerAbilities.crouching ? 0.6 : 1; // Crouching makes you slower but quieter
        const speedMul = (player.moveSpeedMultiplier || 1) * (sprinting ? 1.5 : 1) * vitBoost * crouchModifier;
        dx = dx/mag * MOVE_SPEED * speedMul;
        dy = dy/mag * MOVE_SPEED * speedMul;
        // Stamina update
        if (sprinting) player.stamina = Math.max(0, player.stamina - 0.005);
        else player.stamina = Math.min(1, player.stamina + 0.0035);
    }

    // --- COLLISION FIX: Check X and Y movement separately ---
    let nextX = player.x + dx;
    let nextY = player.y + dy;

    // Check X-axis collision - allow walking over decorative objects and stairs
    let xPadding = dx > 0 ? COLLISION_PADDING : -COLLISION_PADDING;
    const probeX = Math.floor(nextX + xPadding);
    const py = Math.floor(player.y);
    if (probeX >= 0 && probeX < MAP_SIZE && py >= 0 && py < MAP_SIZE && 
        (map[py][probeX] === 0 || map[py][probeX] >= 5)) { // Allow walking over stairs (5,6) and decorative objects (7+)
        player.x = nextX;
    }

    // Check Y-axis collision - allow walking over decorative objects and stairs
    let yPadding = dy > 0 ? COLLISION_PADDING : -COLLISION_PADDING;
    const px = Math.floor(player.x);
    const probeY = Math.floor(nextY + yPadding);
    if (px >= 0 && px < MAP_SIZE && probeY >= 0 && probeY < MAP_SIZE && 
        (map[probeY][px] === 0 || map[probeY][px] >= 5)) { // Allow walking over stairs (5,6) and decorative objects (7+)
        player.y = nextY;
    }
}

function update() {
    // Don't update if game is completely stopped or paused
    if (![GAME_STATE.PLAYING, GAME_STATE.HIDDEN].includes(currentGameState)) return;
    
    // Update gamepad state
    updateGamepadState();
    
    // Update audio
    updateAudio();
    
    handleMovement();

    if (Date.now() - lastShiftTime > currentShiftInterval) { shiftMaze(); }

    let pTileX = Math.floor(player.x), pTileY = Math.floor(player.y);
    for (let i = sprites.length - 1; i >= 0; i--) {
        let sprite = sprites[i];
        if (Math.floor(sprite.x) === pTileX && Math.floor(sprite.y) === pTileY) {
            if (sprite.type === 'bronzeKey') {
                player.hasBronzeKey = true;
                sprites.splice(i, 1);
                playSound('keyPickup', 0.8);
                message.text = "Bronze key acquired."; message.life = 150;
            } else if (sprite.type === 'goldKey') {
                player.hasGoldKey = true;
                sprites.splice(i, 1);
                playSound('keyPickup', 1.0);
                message.text = "You found the GOLD key!"; message.life = 200;
            } else if (sprite.type === 'flashlight') {
                inventory.flashlight = true;
                sprites.splice(i, 1);
                playSound('itemPickup', 0.7);
                message.text = "üî¶ Flashlight acquired! Press F to toggle."; message.life = 200;
                if (hudFlash) hudFlash.textContent = 'On';
            } else if (sprite.type === 'vitamins') {
                inventory.vitamins += 2;
                sprites.splice(i, 1);
                playSound('itemPickup', 0.6);
                message.text = "üíä Vitamins acquired! (+2) Press V to use."; message.life = 200;
                if (hudVits) hudVits.textContent = String(inventory.vitamins);
            } else if (sprite.type === 'lockpick') {
                inventory.lockpick += 1;
                sprites.splice(i, 1);
                playSound('itemPickup', 0.8);
                message.text = "üîì Lockpick acquired! (+1) Use on bronze doors."; message.life = 200;
                if (hudPicks) hudPicks.textContent = String(inventory.lockpick);
            } else if (sprite.type === 'smokeBomb') {
                inventory.smokeBomb += 1;
                sprites.splice(i, 1);
                playSound('itemPickup', 0.7);
                message.text = "üí® Smoke bomb acquired! (+1) Press Q to use."; message.life = 200;
            } else if (sprite.type === 'noiseMaker') {
                inventory.noiseMaker += 1;
                sprites.splice(i, 1);
                playSound('itemPickup', 0.7);
                message.text = "üîä Noise maker acquired! (+1) Press Z to use."; message.life = 200;
            }
        }
    }
    
    // Check for staircase interaction - show prompts
    if (map[pTileY][pTileX] === 5) { // Stairs up
        message.text = "Press SPACE to climb the stairs"; message.life = 120;
    } else if (map[pTileY][pTileX] === 6) { // Stairs down
        message.text = "Press SPACE to descend the stairs"; message.life = 120;
    }
    
    if (map[pTileY][pTileX] === 3) {
        if (player.hasGoldKey) {
            nextStageOrWin();
        } else { message.text = "A golden symbol adorns the lock."; message.life = 120; }
    } else if (map[pTileY][pTileX] === 2) {
        if (player.hasBronzeKey) {
            // Consume bronze key and clear door
            player.hasBronzeKey = false;
            map[pTileY][pTileX] = 0;
            message.text = "Bronze door unlocked."; message.life = 120;
        } else if (inventory.lockpick > 0) { map[pTileY][pTileX] = 0; inventory.lockpick -= 1; message.text = 'Picked the lock.'; message.life = 120; }
        else { message.text = 'This door needs a bronze key.'; message.life = 120; }
    }
    
    // Rush Event Logic
    const now = Date.now();
    const timeSinceShift = now - lastShiftTime;
    const timeSinceLastRush = now - rushEvent.lastTrigger;
    
    if (!rushEvent.active && timeSinceLastRush > rushEvent.cooldown && timeSinceShift > 10000) {
        // Only trigger rush if not during/right after a shift
        if (prng() < 0.0003) { // Very low chance per frame
            rushEvent.active = true;
            rushEvent.startTime = now;
            rushEvent.lastTrigger = now;
            message.text = "RUSH EVENT! Hide quickly!"; message.life = 200;
            
            // Play rush event sound
            playSound('rushEvent', 0.9);
        }
    }
    
    if (rushEvent.active && now - rushEvent.startTime > rushEvent.duration) {
        rushEvent.active = false;
        message.text = "The rush has passed."; message.life = 150;
    }
    
    // Stalker Enemy Logic
    if (!stalkerEnemy && timeSinceShift > 8000) { // Spawn after shift cooldown
        if (prng() < 0.0001) { // Very low chance per frame
            let spawnPos = findRandomEmptyCell(map);
            if (spawnPos) {
                stalkerEnemy = {
                    x: spawnPos.x + 0.5, y: spawnPos.y + 0.5,
                    path: [], lastPathUpdate: 0, lastChase: 0,
                    chaseInterval: 12000 + Math.floor(prng() * 8000), // 12-20s between chases
                    chaseDuration: 4000 + Math.floor(prng() * 8000), // 4-7s chase duration
                    currentFloor: currentFloor // Track which floor this enemy is on
                };
                message.text = "Something stalks you from the shadows..."; message.life = 180;
                
                // Play enemy spawn sound
                playSound('enemyGrowl', 0.7);
            }
        }
    }
    
    if (stalkerEnemy) {
        const timeSinceLastChase = now - stalkerEnemy.lastChase;
        const inChase = timeSinceLastChase < stalkerEnemy.chaseDuration;
        
        if (inChase && currentGameState === GAME_STATE.PLAYING) {
            // Chase mode: aggressive pathfinding
            if (now - stalkerEnemy.lastPathUpdate > 500) {
                stalkerEnemy.path = findPath(Math.floor(stalkerEnemy.x), Math.floor(stalkerEnemy.y), pTileX, pTileY);
                stalkerEnemy.lastPathUpdate = now;
            }
        } else if (timeSinceLastChase > stalkerEnemy.chaseInterval) {
            // Start new chase
            stalkerEnemy.lastChase = now;
            message.text = "The stalker begins its hunt..."; message.life = 120;
        }
        
        // Move stalker
        if (stalkerEnemy.path && stalkerEnemy.path.length > 0) {
            let target = stalkerEnemy.path[0];
            let dx = (target.x + 0.5) - stalkerEnemy.x;
            let dy = (target.y + 0.5) - stalkerEnemy.y;
            let mag = Math.hypot(dx, dy);
            if (mag > 0.1) {
                let speed = inChase ? currentEnemySpeed * 1.2 : currentEnemySpeed * 0.6;
                let moveX = (dx / mag) * speed;
                let moveY = (dy / mag) * speed;
                
                // Collision check for stalker
                let nextX = stalkerEnemy.x + moveX;
                let nextY = stalkerEnemy.y + moveY;
                let xPadding = moveX > 0 ? COLLISION_PADDING : -COLLISION_PADDING;
                let yPadding = moveY > 0 ? COLLISION_PADDING : -COLLISION_PADDING;
                
                const probeX = Math.floor(nextX + xPadding);
                const probeY = Math.floor(nextY + yPadding);
                const currentX = Math.floor(stalkerEnemy.x);
                const currentY = Math.floor(stalkerEnemy.y);
                
                if (probeX >= 0 && probeX < MAP_SIZE && currentY >= 0 && currentY < MAP_SIZE && map[currentY][probeX] === 0) {
                    stalkerEnemy.x = nextX;
                }
                if (currentX >= 0 && currentX < MAP_SIZE && probeY >= 0 && probeY < MAP_SIZE && map[probeY][currentX] === 0) {
                    stalkerEnemy.y = nextY;
                }
            } else {
                stalkerEnemy.path.shift();
            }
        }
        
        // Check collision with player (only if on same floor)
        if (stalkerEnemy.currentFloor === currentFloor) {
            let distToPlayer = Math.hypot(player.x - stalkerEnemy.x, player.y - stalkerEnemy.y);
            const inGrace = (Date.now() - stageStartTime) < (player.graceMs || 0);
            if (currentGameState === GAME_STATE.PLAYING && !inGrace && distToPlayer < 0.5) {
                currentGameState = GAME_STATE.GAMEOVER; 
                totalElapsedMs += Date.now() - stageStartTime;
                saveRun(false);
                showRunSummary(false);
                if (hiddenIndicator) hiddenIndicator.style.display = 'none';
            }
        }
    }
    
    // Enhanced Enemy AI for all enemies
    for (let enemy of enemies) {
        // Only process enemies on the same floor as player
        if (enemy.currentFloor === currentFloor) {
            let distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
            // Grace period after spawn
            const inGrace = (Date.now() - stageStartTime) < (player.graceMs || 0);
            if (currentGameState === GAME_STATE.PLAYING && !inGrace && distToPlayer < 0.5) { 
                currentGameState = GAME_STATE.GAMEOVER; 
                totalElapsedMs += Date.now() - stageStartTime;
                saveRun(false);
                showRunSummary(false);
                if (hiddenIndicator) hiddenIndicator.style.display = 'none';
            }
            
            // Check if enemy can hear player footsteps
            if (currentGameState === GAME_STATE.PLAYING && !enemy.blinded) {
                const footstepRange = enemy.hearingRange * (playerAbilities.stealthMode ? 0.5 : 1.0);
                const canHear = distToPlayer <= footstepRange;
                
                if (canHear && !enemy.attractedTo) {
                    // Enemy heard player - update last seen position
                    enemy.lastSeenPlayer = { x: player.x, y: player.y, time: Date.now() };
                    enemy.state = 'CHASING';
                    playSound('enemyHear', 0.6);
                    
                    // Update path to player
                    if (Date.now() - lastEnemyPathUpdateTime > 500) {
                        lastEnemyPathUpdateTime = Date.now();
                        enemy.path = findPath(Math.floor(enemy.x), Math.floor(enemy.y), pTileX, pTileY);
                    }
                }
            }
            
            // Handle different enemy states
            if (enemy.state === 'BLINDED' && Date.now() > enemy.blindUntil) {
                enemy.blinded = false;
                enemy.state = 'PATROL';
                enemy.path = [];
            }
            
            if (enemy.state === 'ATTRACTED' && Date.now() > enemy.attractedUntil) {
                enemy.attractedTo = null;
                enemy.state = 'PATROL';
                enemy.path = [];
            }
            
            // Rush event affects regular enemies
            if (rushEvent.active && currentGameState === GAME_STATE.PLAYING && !enemy.blinded) {
                // Enemies become more aggressive during rush
                if (Date.now() - lastEnemyPathUpdateTime > 300) { // Faster updates
                    lastEnemyPathUpdateTime = Date.now();
                    enemy.path = findPath(Math.floor(enemy.x), Math.floor(enemy.y), pTileX, pTileY);
                }
            } else if (currentGameState === GAME_STATE.PLAYING && Date.now() - lastEnemyPathUpdateTime > currentPathUpdateInterval && !enemy.blinded) {
                lastEnemyPathUpdateTime = Date.now();
                enemy.path = findPath(Math.floor(enemy.x), Math.floor(enemy.y), pTileX, pTileY);
            } else if (currentGameState === GAME_STATE.HIDDEN && enemy.path.length > 0) {
                enemy.path = [];
            }
            // Enemy movement (only for enemies on same floor)
            if (enemy.path && enemy.path.length > 0) {
                let target = enemy.path[0];
                let dx = (target.x + 0.5) - enemy.x;
                let dy = (target.y + 0.5) - enemy.y;
                let mag = Math.hypot(dx, dy);
                if (mag > 0.1) {
                    let speed = rushEvent.active ? currentEnemySpeed * 1.4 : currentEnemySpeed;
                    let moveX = (dx / mag) * speed;
                    let moveY = (dy / mag) * speed;

                    let nextEnemyX = enemy.x + moveX;
                    let nextEnemyY = enemy.y + moveY;
                    let xPadding = moveX > 0 ? COLLISION_PADDING : -COLLISION_PADDING;
                    let yPadding = moveY > 0 ? COLLISION_PADDING : -COLLISION_PADDING;

                    const eProbeX = Math.floor(nextEnemyX + xPadding);
                    const ey = Math.floor(enemy.y);
                    if (eProbeX >= 0 && eProbeX < MAP_SIZE && ey >= 0 && ey < MAP_SIZE && map[ey][eProbeX] === 0) {
                        enemy.x = nextEnemyX;
                    }
                    const ex = Math.floor(enemy.x);
                    const eProbeY = Math.floor(nextEnemyY + yPadding);
                    if (ex >= 0 && ex < MAP_SIZE && eProbeY >= 0 && eProbeY < MAP_SIZE && map[eProbeY][ex] === 0) {
                        enemy.y = nextEnemyY;
                    }
                } else {
                    enemy.path.shift();
                }
            }
        }
    }
    
    // Closet failsafe: Auto-exit if player stays too long
    if (currentGameState === GAME_STATE.HIDDEN && player.closetEntryTime) {
        const timeInCloset = Date.now() - player.closetEntryTime;
        const CLOSET_TIMEOUT = 15000; // 15 seconds timeout
        
        if (timeInCloset > CLOSET_TIMEOUT) {
            console.log("Closet timeout reached, forcing exit");
            message.text = "You crawled out of that cramped space."; message.life = 150;
            
            // Force exit using the same logic as manual exit
            let placed = false;
            let exitPositions = [];
            
            // Find all closet openings
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (map[y][x] === 4) {
                        const directions = [[1,0], [-1,0], [0,1], [0,-1]];
                        for (let [dx, dy] of directions) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
                                if (isPositionAccessible(nx, ny) && !isWallCollision(nx, ny)) {
                                    exitPositions.push({
                                        x: nx, y: ny,
                                        closetX: x, closetY: y,
                                        dx: dx, dy: dy,
                                        accessibility: countAccessibleNeighbors(nx, ny)
                                    });
                                }
                            }
                        }
                    }
                }
            }
            
            // Sort by accessibility
            exitPositions.sort((a, b) => b.accessibility - a.accessibility);
            
            // Try to place player
            for (let pos of exitPositions) {
                if (isPositionAccessible(pos.x, pos.y) && !isWallCollision(pos.x, pos.y)) {
                    player.x = pos.x + 0.5;
                    player.y = pos.y + 0.5;
                    player.angle = Math.atan2(pos.dy, pos.dx);
                    placed = true;
                    console.log("Auto-exit placed player at:", pos.x, pos.y);
                    break;
                }
            }
            
            // Fallback strategies
            if (!placed) {
                let bestPosition = findBestSafePosition();
                if (bestPosition && !isWallCollision(bestPosition.x, bestPosition.y)) {
                    player.x = bestPosition.x + 0.5;
                    player.y = bestPosition.y + 0.5;
                    placed = true;
                    console.log("Auto-exit fallback position:", bestPosition.x, bestPosition.y);
                }
            }
            
            if (!placed) {
                player.x = 1.5;
                player.y = 1.5;
                console.log("Auto-exit emergency spawn");
            }
            
            // Reset state
            currentGameState = GAME_STATE.PLAYING;
            player.closetEntryTime = null;
            if (hiddenIndicator) hiddenIndicator.style.display = 'none';
            
            // Play closet closing sound
            playSound('closetClose', 0.6);
        }
    }
    
    if (message.life > 0) message.life--;
    if (popupLife > 0) popupLife--;
    
    // Play proximity audio cues
    if (audioCues.enabled) {
        playProximityAudio();
    }
    
    // Check achievements
    achievementSystem.checkAchievements();

    // HUD updates - keep visible during pause
    if (currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.HIDDEN || currentGameState === GAME_STATE.PAUSED) {
        const elapsed = totalElapsedMs + (Date.now() - stageStartTime);
        hudStageEl.textContent = `${Math.min(stageIndex + 1, STAGES.length + 1)}`;
        if (hudFloorEl) hudFloorEl.textContent = `${currentFloor + 1}`;
        hudTimeEl.textContent = msToClock(elapsed);
        if (hudBronzeEl) hudBronzeEl.textContent = player.hasBronzeKey ? '1' : '0';
        if (hudGoldEl) hudGoldEl.textContent = player.hasGoldKey ? 'Yes' : 'No';
        // Exit compass when gold key is acquired
        if (exitCompass) {
            let exitPos = null;
            for (let y=0;y<MAP_SIZE;y++) for (let x=0;x<MAP_SIZE;x++) if (map[y][x]===3) { exitPos={x:x+0.5,y:y+0.5}; break; }
            if (player.hasGoldKey && exitPos) {
                const ang = Math.atan2(exitPos.y - player.y, exitPos.x - player.x) - player.angle;
                const dir = ang > 0 ? (ang > Math.PI/8 ? '‚Üí' : '‚Ä¢') : (ang < -Math.PI/8 ? '‚Üê' : '‚Ä¢');
                exitCompass.textContent = `Exit: ${dir}`;
            } else {
                exitCompass.textContent = 'Exit: ?';
            }
        }
        if (hudFlash) hudFlash.textContent = inventory.flashlight ? 'On' : 'Off';
        if (hudVits) hudVits.textContent = String(inventory.vitamins);
        if (hudPicks) hudPicks.textContent = String(inventory.lockpick);
        if (hudSmoke) hudSmoke.textContent = String(inventory.smokeBomb);
        if (hudNoise) hudNoise.textContent = String(inventory.noiseMaker);
        if (rushWarning) rushWarning.style.display = rushEvent.active ? 'block' : 'none';
        
        // Show stairs indicator
        const playerTileX = Math.floor(player.x);
        const playerTileY = Math.floor(player.y);
        if (map[playerTileY] && map[playerTileY][playerTileX] === 5) {
            message.text = `You are on stairs up. Press SPACE to climb to floor ${currentFloor + 2}.`;
            message.life = 60;
        } else if (map[playerTileY] && map[playerTileY][playerTileX] === 6) {
            message.text = `You are on stairs down. Press SPACE to descend to floor ${currentFloor}.`;
            message.life = 60;
        }
        
        // Show stage and floor info in debug area
        if (stageIndex >= 1) {
            ctx.font = '14px Courier New';
            ctx.textAlign = 'left';
            ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
            ctx.fillText(`Stage ${stageIndex + 1}: ${STAGES[stageIndex - 1]}`, 220, 200);
            ctx.fillText(`Floors: ${currentFloor + 1}/${maxFloors}`, 220, 220);
            ctx.fillText(`Stairs: ${floorConnections.length} connections`, 220, 240);
        }
        
        // Show hidden state reminder
        if (currentGameState === GAME_STATE.HIDDEN && hiddenIndicator) {
            hiddenIndicator.style.display = 'block';
        }
        
        // Show crouch state indicator
        if (crouchIndicator) {
            if (playerAbilities.crouching) {
                crouchIndicator.style.display = 'block';
            } else {
                crouchIndicator.style.display = 'none';
            }
        }
        
        // Show pause state indicator
        if (pauseIndicator) {
            if (currentGameState === GAME_STATE.PAUSED) {
                pauseIndicator.style.display = 'block';
            } else {
                pauseIndicator.style.display = 'none';
            }
        }
        

    }
}

function renderHiddenSlitView(slitY, slitHeight) {
    // Render a very limited view through the closet slit
    // Only show walls and enemies that are directly in front of the player
    
    const centerX = canvas.width / 2;
    const centerY = slitY + slitHeight / 2;
    
    // Render walls through the slit (very limited raycasting)
    for (let i = 0; i < canvas.width; i += 4) { // Skip pixels for performance
        const rayAngle = (player.angle - FOV / 4) + (i / canvas.width) * (FOV / 2);
        const rayDirX = Math.cos(rayAngle), rayDirY = Math.sin(rayAngle);
        let mapX = Math.floor(player.x), mapY = Math.floor(player.y);
        let deltaDistX = Math.abs(1 / (rayDirX === 0 ? 1e-6 : rayDirX)), deltaDistY = Math.abs(1 / (rayDirY === 0 ? 1e-6 : rayDirY));
        let sideDistX, sideDistY;
        let stepX, stepY, side;
        
        if (rayDirX < 0) { stepX = -1; sideDistX = (player.x - mapX) * deltaDistX; } 
        else { stepX = 1; sideDistX = (mapX + 1.0 - player.x) * deltaDistX; }
        if (rayDirY < 0) { stepY = -1; sideDistY = (mapY + 1.0 - player.y) * deltaDistY; } 
        else { stepY = 1; sideDistY = (mapY + 1.0 - player.y) * deltaDistY; }
        
        let hit = 0;
        let steps = 0;
        while (hit === 0 && steps++ < 8) { // Limited range for slit view
            if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; } 
            else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
            if (mapY < 0 || mapY >= MAP_SIZE || mapX < 0 || mapX >= MAP_SIZE) { hit = 1; break; }
            if (map[mapY][mapX] > 0) hit = map[mapY][mapX];
        }
        
        if (hit > 0) {
            let perpWallDist = (side === 0) ? (mapX - player.x + (1 - stepX) / 2) / rayDirX : (mapY - player.y + (1 - stepY) / 2) / rayDirY;
            const lineHeight = (slitHeight / Math.max(perpWallDist, 0.0001)) * 0.5;
            const drawStart = centerY - lineHeight / 2;
            const drawEnd = centerY + lineHeight / 2;
            
            if (drawStart < drawEnd) {
                ctx.fillStyle = hit === 1 ? '#333' : hit === 2 ? '#654321' : hit === 3 ? '#8B4513' : '#555';
                ctx.fillRect(i, drawStart, 4, drawEnd - drawStart);
            }
        }
    }
    
    // Render enemies through the slit (only if very close)
    for (let enemy of enemies) {
        const enemyX = enemy.x - player.x;
        const enemyY = enemy.y - player.y;
        const enemyDist = Math.hypot(enemyX, enemyY);
        if (enemyDist < 3) { // Only show very close enemies
            const enemyAngle = Math.atan2(enemyY, enemyX) - player.angle;
            if (Math.abs(enemyAngle) <= FOV / 4) {
                const enemyScreenX = Math.tan(enemyAngle) * canvas.width / 2;
                const enemyHeight = (slitHeight / enemyDist) * 0.6;
                const enemyWidth = enemyHeight * 0.8;
                
                const enemyDrawX = centerX + enemyScreenX - enemyWidth / 2;
                const enemyDrawY = centerY - enemyHeight / 2;
                
                if (enemyDrawX >= 0 && enemyDrawX < canvas.width) {
                    ctx.globalAlpha = 0.8;
                    ctx.drawImage(assets.enemySprite, enemyDrawX, enemyDrawY, enemyWidth, enemyHeight);
                    ctx.globalAlpha = 1.0;
                }
            }
        }
    }
    
    // Render stalker if present
    if (stalkerEnemy) {
        const stalkerX = stalkerEnemy.x - player.x;
        const stalkerY = stalkerEnemy.y - player.y;
        const stalkerDist = Math.hypot(stalkerX, stalkerY);
        if (stalkerDist < 3) {
            const stalkerAngle = Math.atan2(stalkerY, stalkerX) - player.angle;
            if (Math.abs(stalkerAngle) <= FOV / 4) {
                const stalkerScreenX = Math.tan(stalkerAngle) * canvas.width / 2;
                const stalkerHeight = (slitHeight / stalkerDist) * 0.6;
                const stalkerWidth = stalkerHeight * 0.8;
                
                const stalkerDrawX = centerX + stalkerScreenX - stalkerWidth / 2;
                const stalkerDrawY = centerY - stalkerHeight / 2;
                
                if (stalkerDrawX >= 0 && stalkerDrawX < canvas.width) {
                    ctx.globalAlpha = 0.6;
                    ctx.drawImage(assets.enemySprite, stalkerDrawX, stalkerDrawY, stalkerWidth, stalkerHeight);
                    ctx.globalAlpha = 1.0;
                }
            }
        }
    }
}

// =============================================================================
// --- RENDERING ---
// =============================================================================
function render() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (currentGameState === GAME_STATE.WON || currentGameState === GAME_STATE.GAMEOVER) {
        mainMenu.style.opacity = '1';
        mainMenu.style.pointerEvents = 'auto';
        mainMenu.querySelector('h1').textContent = (currentGameState === GAME_STATE.WON) ? "YOU ESCAPED" : "YOU WERE CAUGHT";
        mainMenu.querySelector('p').textContent = (currentGameState === GAME_STATE.WON) ? "But the memory of the house will never leave you." : "Your sanity is forfeit.";
        // Hide HUD when showing end game screen
        if (hud) hud.style.display = 'none';
        return;
    }
    
    if (currentGameState === GAME_STATE.MENU) return;
    
    // Keep rendering during pause to maintain HUD visibility
    // Note: Game state is PAUSED during pause, but rendering continues
    
    if (currentGameState === GAME_STATE.HIDDEN) {
        // Horizontal slit view through closet door
        ctx.fillStyle = "rgba(0,0,0,0.95)";
        ctx.fillRect(0,0, canvas.width, canvas.height);
        
        // Create a horizontal slit in the center of the screen
        const slitHeight = Math.max(20, canvas.height * 0.08); // Wider slit for better visibility
        const slitY = canvas.height/2 - slitHeight/2;
        
        // Clear the slit area to show the world
        ctx.clearRect(0, slitY, canvas.width, slitHeight);
        
        // Add subtle dark edges to the slit for realism
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fillRect(0, slitY - 2, canvas.width, 2);
        ctx.fillRect(0, slitY + slitHeight, canvas.width, 2);
        
        // Render a very limited view of the world through the slit
        renderHiddenSlitView(slitY, slitHeight);
        return;
    }
    
    let zBuffer = [];
    for (let i = 0; i < canvas.width; i++) {
        const rayAngle = (player.angle - FOV / 2) + (i / canvas.width) * FOV;
        const rayDirX = Math.cos(rayAngle), rayDirY = Math.sin(rayAngle);
        let mapX = Math.floor(player.x), mapY = Math.floor(player.y);
        let deltaDistX = Math.abs(1 / (rayDirX === 0 ? 1e-6 : rayDirX)), deltaDistY = Math.abs(1 / (rayDirY === 0 ? 1e-6 : rayDirY));
        let sideDistX, sideDistY;
        let stepX, stepY, side;

        if (rayDirX < 0) { stepX = -1; sideDistX = (player.x - mapX) * deltaDistX; } 
        else { stepX = 1; sideDistX = (mapX + 1.0 - player.x) * deltaDistX; }
        if (rayDirY < 0) { stepY = -1; sideDistY = (player.y - mapY) * deltaDistY; } 
        else { stepY = 1; sideDistY = (mapY + 1.0 - player.y) * deltaDistY; }
        
        let hit = 0;
        let steps = 0;
        while (hit === 0 && steps++ < MAX_RAY_STEPS) {
            if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; } 
            else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
            if (mapY < 0 || mapY >= MAP_SIZE || mapX < 0 || mapX >= MAP_SIZE) { hit = 1; break; }
            if (map[mapY][mapX] > 0) hit = map[mapY][mapX];
        }
        
        let perpWallDist = (side === 0) ? (mapX - player.x + (1 - stepX) / 2) / rayDirX : (mapY - player.y + (1 - stepY) / 2) / rayDirY;
        zBuffer[i] = perpWallDist;

        const lineHeight = (canvas.height / Math.max(perpWallDist, 0.0001));
        const drawStart = -lineHeight / 2 + canvas.height / 2;
        
        let wallX = (side === 0) ? player.y + perpWallDist * rayDirY : player.x + perpWallDist * rayDirX;
        wallX -= Math.floor(wallX);
        let texX = Math.floor(wallX * 64);
        
        let texture;
        switch(hit) {
            case 2: texture = assets.bronzeDoorTexture; break;
            case 3: texture = assets.doorTexture; break;
            case 4: texture = assets.closetTexture; break;
            case 5: texture = assets.stairsUpTexture; break;
            case 6: texture = assets.stairsDownTexture; break;
            case 7: texture = assets.torchTexture; break;
            case 8: texture = assets.bonesTexture; break;
            case 9: texture = assets.bloodStainTexture; break;
            case 10: texture = assets.cobwebTexture; break;
            case 11: texture = assets.altarTexture; break;
            case 12: texture = assets.cageTexture; break;
            default: texture = assets.wallTexture;
        }

        ctx.drawImage(texture, texX, 0, 1, 64, i, drawStart, 1, lineHeight);
        
        const darkness = Math.min(Math.max(perpWallDist / 10, 0), 1);
        ctx.fillStyle = `rgba(0,0,0,${darkness})`;
        ctx.fillRect(i, drawStart, 1, lineHeight);
    }
    
    const enemySprites = enemies.map(e => ({x: e.x, y: e.y, type: 'enemy', texture: assets.enemySprite}));
    const allSprites = [...sprites, ...enemySprites];
    allSprites.forEach(s => s.dist = Math.hypot(s.x-player.x, s.y-player.y));
    allSprites.sort((a,b) => b.dist - a.dist);
    
    // Only log sprite count occasionally to avoid spam
    if (Math.random() < 0.01) { // Log 1% of the time
        console.log("Rendering", allSprites.length, "sprites (", sprites.length, "items +", enemySprites.length, "enemies)");
    }
    for(let sprite of allSprites) {
        // Only log container sprites occasionally to avoid spam
        if (sprite.type === 'container' && Math.random() < 0.1) { // Log 10% of the time
            console.log("Container sprite at", sprite.x, sprite.y, "distance", sprite.dist);
        }
        let relX = sprite.x - player.x;
        let relY = sprite.y - player.y;
        
        let angleToSprite = Math.atan2(relY, relX);
        let angleDiff = player.angle - angleToSprite;

        // Normalize angle difference
        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        if (Math.abs(angleDiff) < FOV / 2 + 0.2) { // 0.2 is a small grace margin
            const spriteDist = sprite.dist * Math.cos(angleDiff);
            const spriteHeight = canvas.height / spriteDist;
            const spriteScreenX = canvas.width / 2 + Math.tan(-angleDiff) * (canvas.width / 2) / Math.tan(FOV / 2);
            
            const drawStartY = canvas.height/2 - spriteHeight/2;
            // Scale sprite types
            let scale = 1;
            if (sprite.type === 'container') scale = 0.35; // Made containers even smaller
            if (sprite.type === 'bronzeKey' || sprite.type === 'goldKey') scale = 0.45; // Keys at requested scale
            if (sprite.type === 'flashlight' || sprite.type === 'vitamins' || sprite.type === 'lockpick') scale = 0.3; // Make items smaller
            const spriteWidth = spriteHeight * scale;
            const drawStartX = spriteScreenX - spriteWidth / 2;

            for (let stripe = Math.floor(drawStartX); stripe < Math.floor(drawStartX + spriteWidth); stripe++) {
                // --- RENDERING FIX: Only draw sprite pixel if it's closer than the wall ---
                if (stripe >= 0 && stripe < canvas.width && spriteDist < zBuffer[stripe]) {
                    let texX = Math.floor(64 * (stripe - drawStartX) / spriteWidth);
                    ctx.globalAlpha = 1;
                    ctx.drawImage(sprite.texture, texX, 0, 1, 64, stripe, drawStartY, 1, spriteHeight);
                }
            }
        }
    }
    
    // Render stalker enemy
    if (stalkerEnemy) {
        const stalkerX = stalkerEnemy.x - player.x;
        const stalkerY = stalkerEnemy.y - player.y;
        const stalkerDist = Math.hypot(stalkerX, stalkerY);
        if (stalkerDist > 0.1) {
            const stalkerAngle = Math.atan2(stalkerY, stalkerX) - player.angle;
            if (Math.abs(stalkerAngle) <= FOV / 2) {
                const stalkerScreenX = Math.tan(stalkerAngle) * canvas.width / 2;
                const stalkerHeight = (canvas.height / stalkerDist) * 0.9;
                const stalkerWidth = stalkerHeight * 0.8;
                
                const stalkerDrawX = canvas.width / 2 + stalkerScreenX - stalkerWidth / 2;
                const stalkerDrawY = canvas.height / 2 - stalkerHeight / 2;
                
                if (stalkerDist < zBuffer[Math.floor(stalkerDrawX)]) {
                    // Stalker has a darker, more menacing appearance
                    ctx.globalAlpha = 0.8;
                    ctx.drawImage(assets.enemySprite, stalkerDrawX, stalkerDrawY, stalkerWidth, stalkerHeight);
                    ctx.globalAlpha = 1.0;
                }
            }
        }
    }
    
    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width * (inventory.flashlight ? 0.85 : 0.6));
    gradient.addColorStop(0, 'rgba(0,0,0,0)');
    gradient.addColorStop(0.8, `rgba(0,0,0,${0.8 - (settings.bright||0)})`);
    gradient.addColorStop(1, 'rgba(0,0,0,1)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    if(message.life > 0) {
        ctx.font = '24px Courier New';
        ctx.textAlign = 'center';
        ctx.fillStyle = `rgba(255, 255, 0, ${message.life/100})`;
        ctx.fillText(message.text, canvas.width / 2, canvas.height - 50);
    }

    // Debug info for stairs - moved to avoid HUD overlap
    if (currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.HIDDEN || currentGameState === GAME_STATE.PAUSED) {
        ctx.font = '16px Courier New';
        ctx.textAlign = 'left';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        
        // Position debug info to the right of the HUD to avoid overlap
        const debugX = 220; // Right of HUD
        const debugY = 30;
        let debugLine = 0;
        
        ctx.fillText(`Floor: ${currentFloor + 1}`, debugX, debugY + (debugLine++ * 20));
        ctx.fillText(`Floor Connections: ${floorConnections.length}`, debugX, debugY + (debugLine++ * 20));
        
        // Show exit status
        let exitOnCurrentFloor = false;
        for (let y = 0; y < MAP_SIZE; y++) {
            for (let x = 0; x < MAP_SIZE; x++) {
                if (map[y][x] === 3) {
                    exitOnCurrentFloor = true;
                    break;
                }
            }
            if (exitOnCurrentFloor) break;
        }
        
        if (exitOnCurrentFloor) {
            ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
            ctx.fillText(`Exit: On Current Floor`, debugX, debugY + (debugLine++ * 20));
        } else if (floorConnections.length > 0) {
            ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
            ctx.fillText(`Exit: On Floor ${maxFloors} (Use Stairs)`, debugX, debugY + (debugLine++ * 20));
        } else {
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.fillText(`Exit: ERROR - Not Found!`, debugX, debugY + (debugLine++ * 20));
        }
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; // Reset color
        
        // Show stair positions on current floor
        let stairsUp = 0, stairsDown = 0;
        for (let y = 0; y < MAP_SIZE; y++) {
            for (let x = 0; x < MAP_SIZE; x++) {
                if (map[y][x] === 5) stairsUp++;
                if (map[y][x] === 6) stairsDown++;
            }
        }
        ctx.fillText(`Stairs Up: ${stairsUp}`, debugX, debugY + (debugLine++ * 20));
        ctx.fillText(`Stairs Down: ${stairsDown}`, debugX, debugY + (debugLine++ * 20));
        
        // Show player position
        ctx.fillText(`Player: ${Math.floor(player.x)}, ${Math.floor(player.y)}`, debugX, debugY + (debugLine++ * 20));
        
        // Show current tile type
        const playerTileX = Math.floor(player.x);
        const playerTileY = Math.floor(player.y);
        const tileType = map[playerTileY] ? map[playerTileY][playerTileX] : 'undefined';
        ctx.fillText(`Tile: ${tileType}`, debugX, debugY + (debugLine++ * 20));
        
        // Show closet safety indicator
        if (currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.PAUSED) {
            const nearCloset = checkClosetSafety();
            if (nearCloset) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.fillText(`üï≥Ô∏è Safe closet nearby - Press H to hide`, debugX, debugY + (debugLine++ * 20));
            }
            
            // Show nearby items indicator
            const nearbyItems = sprites.filter(s => {
                const dist = Math.hypot(s.x - player.x, s.y - player.y);
                return dist < 1.5 && s.type !== 'container';
            });
            if (nearbyItems.length > 0) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                ctx.fillText(`üíé Items nearby - Walk over to pick up`, debugX, debugY + (debugLine++ * 20));
            }
        }
    }

    // Popup fade handled in DOM for smoothness; keep life for timing if needed

    // Minimap (bottom-right)
    const mmSize = Math.min(180, Math.min(canvas.width, canvas.height) * 0.24);
    const cellSize = mmSize / MAP_SIZE;
    const mmX = canvas.width - mmSize - 16;
    const mmY = canvas.height - mmSize - 16;
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(mmX - 6, mmY - 6, mmSize + 12, mmSize + 12);
    for (let y = 0; y < MAP_SIZE; y++) {
        for (let x = 0; x < MAP_SIZE; x++) {
            const val = map[y][x];
            if (val === 0) ctx.fillStyle = '#222';
            else if (val === 3) ctx.fillStyle = '#4a1'; // Exit
            else if (val === 4) ctx.fillStyle = '#173'; // Closet
            else if (val === 5) ctx.fillStyle = '#FFD700'; // Stairs up - Bright gold
            else if (val === 6) ctx.fillStyle = '#FF8C00'; // Stairs down - Dark orange
            else if (val === 7) ctx.fillStyle = '#FF4500'; // Torch
            else if (val === 8) ctx.fillStyle = '#F5F5DC'; // Bones
            else if (val === 9) ctx.fillStyle = '#8B0000'; // Blood
            else if (val === 10) ctx.fillStyle = '#F5F5DC'; // Cobweb
            else if (val === 11) ctx.fillStyle = '#2F4F4F'; // Altar
            else if (val === 12) ctx.fillStyle = '#696969'; // Cage
            else ctx.fillStyle = '#555';
            ctx.fillRect(mmX + x * cellSize, mmY + y * cellSize, cellSize, cellSize);
            
            // Add distinctive symbols for special tiles
            if (val === 5) { // Stairs up
                ctx.fillStyle = '#000';
                ctx.font = `${Math.max(8, cellSize * 0.6)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚Üë', mmX + x * cellSize + cellSize/2, mmY + y * cellSize + cellSize/2);
            } else if (val === 6) { // Stairs down
                ctx.fillStyle = '#000';
                ctx.font = `${Math.max(8, cellSize * 0.6)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚Üì', mmX + x * cellSize + cellSize/2, mmY + y * cellSize + cellSize/2);
            } else if (val === 3) { // Exit
                ctx.fillStyle = '#000';
                ctx.font = `${Math.max(8, cellSize * 0.6)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('E', mmX + x * cellSize + cellSize/2, mmY + y * cellSize + cellSize/2);
            } else if (val === 4) { // Closet
                ctx.fillStyle = '#000';
                ctx.font = `${Math.max(8, cellSize * 0.6)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('C', mmX + x * cellSize + cellSize/2, mmY + y * cellSize + cellSize/2);
            }
        }
    // Draw sprites: different colors for different types
    for (let s of sprites) {
        if (s.type === 'bronzeKey' || s.type === 'goldKey') {
            ctx.fillStyle = '#FFD700'; // Gold for keys
        } else if (s.type === 'flashlight') {
            ctx.fillStyle = '#FF6347'; // Orange for flashlight
        } else if (s.type === 'vitamins') {
            ctx.fillStyle = '#32CD32'; // Green for vitamins
        } else if (s.type === 'lockpick') {
            ctx.fillStyle = '#FF69B4'; // Pink for lockpicks
        } else if (s.type === 'smokeBomb') {
            ctx.fillStyle = '#808080'; // Gray for smoke bombs
        } else if (s.type === 'noiseMaker') {
            ctx.fillStyle = '#FF4500'; // Orange for noise makers
        } else if (s.type === 'container') {
            ctx.fillStyle = '#8B4513'; // Brown for containers
        } else {
            ctx.fillStyle = '#FFD700'; // Default gold
        }
        ctx.fillRect(mmX + (s.x) * cellSize - 2, mmY + (s.y) * cellSize - 2, 4, 4);
    }
    // Draw enemies in red
    ctx.fillStyle = '#a22';
    for (let e of enemies) {
        ctx.fillRect(mmX + (e.x) * cellSize - 2, mmY + (e.y) * cellSize - 2, 4, 4);
    }
    // Draw stalker in dark red
    if (stalkerEnemy) {
        ctx.fillStyle = '#600';
        ctx.fillRect(mmX + (stalkerEnemy.x) * cellSize - 2, mmY + (stalkerEnemy.y) * cellSize - 2, 4, 4);
    }
    // Draw player in cyan
    ctx.fillStyle = '#0ff';
    ctx.fillRect(mmX + (player.x) * cellSize - 2, mmY + (player.y) * cellSize - 2, 4, 4);
    // Keen Eye: draw line to key direction
    if (player.keenEye) {
        const key = sprites.find(s => s.type === 'key');
        if (key) {
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
            ctx.beginPath();
            ctx.moveTo(mmX + player.x * cellSize, mmY + player.y * cellSize);
            ctx.lineTo(mmX + key.x * cellSize, mmY + key.y * cellSize);
            ctx.stroke();
        }
    }
    
    // Add minimap legend
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    
    const legendX = mmX;
    const legendY = mmY + mmSize + 20;
    let legendLine = 0;
    
    // Legend for special tiles
    ctx.fillStyle = '#FFD700';
    ctx.fillRect(legendX, legendY + legendLine * 15, 8, 8);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText('‚Üë Stairs Up', legendX + 12, legendY + legendLine * 15 + 6);
    legendLine++;
    
    ctx.fillStyle = '#FF8C00';
    ctx.fillRect(legendX, legendY + legendLine * 15, 8, 8);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText('‚Üì Stairs Down', legendX + 12, legendY + legendLine * 15 + 6);
    legendLine++;
    
    ctx.fillStyle = '#4a1';
    ctx.fillRect(legendX, legendY + legendLine * 15, 8, 8);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText('E Exit', legendX + 12, legendY + legendLine * 15 + 6);
    legendLine++;
    
    ctx.fillStyle = '#173';
    ctx.fillRect(legendX, legendY + legendLine * 15, 8, 8);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText('C Closet', legendX + 12, legendY + legendLine * 15 + 6);
    legendLine++;
    
    // Legend for items
    ctx.fillStyle = '#FFD700';
    ctx.fillRect(legendX + 120, legendY, 4, 4);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText('Keys', legendX + 120 + 12, legendY + 6);
    legendLine = 1;
    
    ctx.fillStyle = '#a22';
    ctx.fillRect(legendX + 120, legendY + legendLine * 15, 4, 4);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.fillText('Enemies', legendX + 120 + 12, legendY + legendLine * 15 + 6);
    legendLine++;
    
    ctx.fillStyle = '#0ff';
    ctx.fillRect(legendX + 120, legendY + legendLine * 15, 4, 4);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillText('You', legendX + 120 + 12, legendY + legendLine * 15 + 6);
    }
}

// =============================================================================
// --- MAIN GAME LOOP ---
// =============================================================================
function gameLoop() {
    update();
    render();
    requestAnimationFrame(gameLoop);
}

// --- START THE GAME ---
document.addEventListener('DOMContentLoaded', () => {
    try {
        initializePRNG();
        generateAssets();
        setupInputs();
        initGamepad();
        initAudio();
        renderLeaderboard();
        mainMenu.style.opacity = '1';
        mainMenu.style.pointerEvents = 'auto';
        currentGameState = GAME_STATE.MENU;
        gameLoop();
    } catch (error) {
        console.error('Error starting game:', error);
        alert('Game failed to start. Check console for details.');
    }
});

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

function resizeCanvasScale() {
    const scale = Math.max(0.5, Math.min(1, settings.scale||1));
    canvas.width = Math.floor(window.innerWidth * scale);
    canvas.height = Math.floor(window.innerHeight * scale);
}

function initGamepad() {
    // Listen for gamepad connections
    window.addEventListener("gamepadconnected", (e) => {
        console.log("Gamepad connected:", e.gamepad.id);
        gamepad = e.gamepad;
        message.text = "Controller connected!";
        message.life = 150;
    });
    
    window.addEventListener("gamepaddisconnected", (e) => {
        console.log("Gamepad disconnected:", e.gamepad.id);
        if (gamepad && gamepad.index === e.gamepad.index) {
            gamepad = null;
            message.text = "Controller disconnected";
            message.life = 150;
        }
    });
    
    // Poll for gamepads on startup
    if (navigator.getGamepads) {
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                gamepad = gamepads[i];
                console.log("Found existing gamepad:", gamepad.id);
                break;
            }
        }
    }
}

function updateGamepadState() {
    if (!gamepad) return;
    
    // Block gamepad input if game is paused
    if (currentGameState === GAME_STATE.PAUSED) return;
    
    // Update gamepad state
    const gp = navigator.getGamepads()[gamepad.index];
    if (!gp) {
        gamepad = null;
        return;
    }
    
    // Update sticks with deadzone
    const deadzone = 0.1;
    gamepadState.leftStick.x = Math.abs(gp.axes[0]) > deadzone ? gp.axes[0] : 0;
    gamepadState.leftStick.y = Math.abs(gp.axes[1]) > deadzone ? gp.axes[1] : 0;
    gamepadState.rightStick.x = Math.abs(gp.axes[2]) > deadzone ? gp.axes[2] : 0;
    gamepadState.rightStick.y = Math.abs(gp.axes[3]) > deadzone ? gp.axes[3] : 0;
    
    // Update buttons
    gamepadState.lastButtons = [...gamepadState.buttons];
    for (let i = 0; i < gp.buttons.length && i < 16; i++) {
        gamepadState.buttons[i] = gp.buttons[i].pressed;
    }
    
    // Handle button presses
    if (gamepadState.buttons[0] && !gamepadState.lastButtons[0]) { // A button
        tryInteract();
    }
    if (gamepadState.buttons[1] && !gamepadState.lastButtons[1]) { // B button
        tryToggleHide();
    }
    if (gamepadState.buttons[2] && !gamepadState.lastButtons[2]) { // X button
        tryOpenDoor();
    }
    if (gamepadState.buttons[3] && !gamepadState.lastButtons[3]) { // Y button
        if (inventory.flashlight) {
            inventory.flashlight = !inventory.flashlight;
            if (hudFlash) hudFlash.textContent = inventory.flashlight ? 'On' : 'Off';
        }
    }
    if (gamepadState.buttons[4] && !gamepadState.lastButtons[4]) { // LB
        if (inventory.vitamins > 0) {
            inventory.vitamins -= 1;
            inventory.vitActiveUntil = Date.now() + 6000;
            message.text = 'Speed surge!';
            message.life = 120;
            if (hudVits) hudVits.textContent = String(inventory.vitamins);
        }
    }
}

// Helper functions for closet exit validation
function isPositionAccessible(x, y) {
    // Check if position is within bounds and open
    if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE || map[y][x] !== 0) {
        return false;
    }
    
    // Check if position has at least 2 open neighbors (not a dead end)
    let openNeighbors = 0;
    const directions = [[1,0], [-1,0], [0,1], [0,-1]];
    
    for (let [dx, dy] of directions) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            openNeighbors++;
        }
    }
    
    return openNeighbors >= 2;
}

function countAccessibleNeighbors(x, y) {
    let count = 0;
    const directions = [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]];
    
    for (let [dx, dy] of directions) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            count++;
        }
    }
    
    return count;
}

function findSafePositionNearStairs(stairsX, stairsY) {
    // Look for open positions adjacent to the stairs
    const directions = [[1,0], [-1,0], [0,1], [0,-1]];
    
    for (let [dx, dy] of directions) {
        const nx = stairsX + dx;
        const ny = stairsY + dy;
        
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            // Check if this position is accessible and safe
            if (isPositionAccessible(nx, ny) && !isWallCollision(nx, ny)) {
                return { x: nx + 0.5, y: ny + 0.5 };
            }
        }
    }
    
    // If no adjacent position works, try diagonal positions
    const diagonalDirections = [[1,1], [1,-1], [-1,1], [-1,-1]];
    for (let [dx, dy] of diagonalDirections) {
        const nx = stairsX + dx;
        const ny = stairsY + dy;
        
        if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
            if (isPositionAccessible(nx, ny) && !isWallCollision(nx, ny)) {
                return { x: nx + 0.5, y: ny + 0.5 };
            }
        }
    }
    
    // Final fallback: find any safe position within 2 tiles
    for (let radius = 2; radius <= 3; radius++) {
        for (let dx = -radius; dx <= radius; dx++) {
            for (let dy = -radius; dy <= radius; dy++) {
                if (Math.abs(dx) + Math.abs(dy) === radius) { // Diamond pattern
                    const nx = stairsX + dx;
                    const ny = stairsY + dy;
                    if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === 0) {
                        if (isPositionAccessible(nx, ny) && !isWallCollision(nx, ny)) {
                            return { x: nx + 0.5, y: ny + 0.5 };
                        }
                    }
                }
            }
        }
    }
    
    return null;
}

function findBestSafePosition() {
    let bestPosition = null;
    let bestScore = -1;
    
    for (let y = 1; y < MAP_SIZE - 1; y++) {
        for (let x = 1; x < MAP_SIZE - 1; x++) {
            if (map[y][x] === 0 && isPositionAccessible(x, y)) {
                const accessibility = countAccessibleNeighbors(x, y);
                if (accessibility > bestScore) {
                    bestScore = accessibility;
                    bestPosition = {x, y};
                }
            }
        }
    }
    
    return bestPosition;
}

function isWallCollision(x, y) {
    // Check if the position would cause the player to be inside a wall
    // This includes checking the player's collision bounds
    const playerRadius = COLLISION_PADDING;
    
    // Check all corners of the player's collision box
    const corners = [
        [x - playerRadius, y - playerRadius],
        [x + playerRadius, y - playerRadius],
        [x - playerRadius, y + playerRadius],
        [x + playerRadius, y + playerRadius]
    ];
    
    for (let [cx, cy] of corners) {
        const mapX = Math.floor(cx);
        const mapY = Math.floor(cy);
        
        if (mapY < 0 || mapY >= MAP_SIZE || mapX < 0 || mapX >= MAP_SIZE) {
            return true; // Out of bounds
        }
        
        if (map[mapY][mapX] === 1) { // Wall
            return true;
        }
    }
    
    return false;
}

// =============================================================================
console.log('Script loaded successfully!');
</script>
</body>
</html>