<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Crawler 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 200;
        }
        
        #mainMenu h1 {
            font-size: 4rem;
            color: #e94560;
            text-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
            margin-bottom: 2rem;
            font-weight: bold;
        }
        
        #mainMenu p {
            font-size: 1.2rem;
            color: #a8a8a8;
            margin-bottom: 3rem;
            text-align: center;
            max-width: 600px;
        }
        
        .menuButton {
            background: linear-gradient(45deg, #e94560, #c44569);
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 1.1rem;
            border-radius: 25px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            pointer-events: auto;
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.3);
        }
        
        .menuButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(233, 69, 96, 0.4);
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #e94560;
            display: none;
            pointer-events: auto;
        }
        
        .hudSection {
            margin-bottom: 10px;
        }
        
        .hudSection h3 {
            color: #e94560;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }
        
        .statBar {
            width: 200px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        
        .statFill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .healthFill { background: linear-gradient(90deg, #e74c3c, #c0392b); }
        .manaFill { background: linear-gradient(90deg, #3498db, #2980b9); }
        .staminaFill { background: linear-gradient(90deg, #f39c12, #e67e22); }
        
        #skillTree {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e94560;
            display: none;
            pointer-events: auto;
            max-width: 800px;
            max-height: 600px;
            overflow-y: auto;
        }
        
        .skillNode {
            display: inline-block;
            width: 60px;
            height: 60px;
            background: #333;
            border: 2px solid #666;
            border-radius: 50%;
            margin: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .skillNode:hover {
            border-color: #e94560;
            transform: scale(1.1);
        }
        
        .skillNode.unlocked {
            background: #e94560;
            border-color: #fff;
        }
        
        .skillNode.available {
            background: #f39c12;
            border-color: #e67e22;
        }
        
        #inventory {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #e94560;
            display: none;
            pointer-events: auto;
            max-width: 300px;
        }
        
        .inventoryItem {
            display: flex;
            align-items: center;
            padding: 5px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
        }
        
        .inventoryItem:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        #campUI {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #e94560;
            display: none;
            pointer-events: auto;
        }
        
        .campButton {
            background: #e94560;
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .campButton:hover {
            background: #c44569;
            transform: translateY(-1px);
        }
        
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #333;
            border-top: 3px solid #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #classSelection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #e94560;
            display: none;
            pointer-events: auto;
            text-align: center;
        }
        
        .classOption {
            display: inline-block;
            margin: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        .classOption:hover {
            border-color: #e94560;
            transform: translateY(-5px);
        }
        
        .classOption.selected {
            border-color: #e94560;
            background: rgba(233, 69, 96, 0.2);
        }
        
        .classIcon {
            font-size: 3rem;
            margin-bottom: 10px;
        }
        
        .classStats {
            font-size: 0.9rem;
            color: #a8a8a8;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <div id="popup" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 500;"></div>
            
            <div id="crosshair" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; pointer-events: none; z-index: 150; display: none;">
                <div style="position: absolute; top: 50%; left: 0; width: 8px; height: 2px; background: #e94560; transform: translateY(-50%);"></div>
                <div style="position: absolute; top: 0; left: 50%; width: 2px; height: 8px; background: #e94560; transform: translateX(-50%);"></div>
            </div>
            
            <div id="mainMenu">
                <h1>Dungeon Crawler 3D</h1>
                <p>Embark on an epic journey through mysterious dungeons. Choose your class, develop your skills, and conquer the depths!</p>
                <button class="menuButton" onclick="startNewGame()">New Game</button>
                <button class="menuButton" onclick="loadGame()">Load Game</button>
                <button class="menuButton" onclick="showSettings()">Settings</button>
            </div>
            
            <div id="loadingScreen">
                <div class="spinner"></div>
                <p>Loading Game...</p>
            </div>
            
            <div id="classSelection">
                <h2>Choose Your Class</h2>
                <div class="classOption" onclick="selectClass('warrior')">
                    <div class="classIcon">⚔️</div>
                    <h3>Warrior</h3>
                    <p>Master of melee combat and heavy armor</p>
                    <div class="classStats">
                        HP: 120 | Mana: 50 | Stamina: 100<br>
                        Strength: 18 | Agility: 12 | Intelligence: 8
                    </div>
                </div>
                <div class="classOption" onclick="selectClass('mage')">
                    <div class="classIcon">🔮</div>
                    <h3>Mage</h3>
                    <p>Powerful spellcaster with devastating magic</p>
                    <div class="classStats">
                        HP: 80 | Mana: 120 | Stamina: 60<br>
                        Strength: 8 | Agility: 10 | Intelligence: 18
                    </div>
                </div>
                <div class="classOption" onclick="selectClass('rogue')">
                    <div class="classIcon">🗡️</div>
                    <h3>Rogue</h3>
                    <p>Stealthy assassin with deadly precision</p>
                    <div class="classStats">
                        HP: 90 | Mana: 60 | Stamina: 110<br>
                        Strength: 12 | Agility: 18 | Intelligence: 10
                    </div>
                </div>
                <button class="menuButton" onclick="confirmClass()" style="margin-top: 20px;">Confirm Selection</button>
            </div>
            
            <div id="hud">
                <div class="hudSection">
                    <h3>Health</h3>
                    <div class="statBar">
                        <div class="statFill healthFill" id="healthBar"></div>
                    </div>
                </div>
                <div class="hudSection">
                    <h3>Mana</h3>
                    <div class="statBar">
                        <div class="statFill manaFill" id="manaBar"></div>
                    </div>
                </div>
                <div class="hudSection">
                    <h3>Stamina</h3>
                    <div class="statBar">
                        <div class="statFill staminaFill" id="staminaBar"></div>
                    </div>
                </div>
                <div class="hudSection">
                    <h3>Level: <span id="playerLevel">1</span></h3>
                    <h3>XP: <span id="playerXP">0</span> / <span id="nextLevelXP">100</span></h3>
                </div>
                <div class="hudSection">
                    <h3>Dungeon Depth: <span id="dungeonDepth">1</span></h3>
                </div>
                <button class="menuButton" onclick="toggleSkillTree()" style="margin-top: 10px;">Skill Tree</button>
                <button class="menuButton" onclick="toggleInventory()" style="margin-top: 10px;">Inventory</button>
                <button class="menuButton" onclick="saveGame()" style="margin-top: 10px;">Save Game</button>
                                 <div style="margin-top: 15px; font-size: 0.8rem; color: #a8a8a8;">
                     <div>WASD: Move | Mouse: Look | Click: Attack</div>
                     <div>E: Interact | Q: Special Ability | Shift: Run | M: Toggle Map | D: Go Deeper</div>
                 </div>
            </div>
            
            <div id="skillTree">
                <h2>Skill Tree</h2>
                <div id="skillNodes"></div>
                <button class="menuButton" onclick="toggleSkillTree()" style="margin-top: 20px;">Close</button>
            </div>
            
            <div id="inventory">
                <h3>Inventory</h3>
                <div id="inventoryItems"></div>
                <button class="menuButton" onclick="toggleInventory()" style="margin-top: 20px;">Close</button>
            </div>
            
            <div id="campUI">
                <h3>Camp Actions</h3>
                <button class="campButton" onclick="enterDungeon()">Enter Dungeon</button>
                <button class="campButton" onclick="upgradeCamp()">Upgrade Camp</button>
                <button class="campButton" onclick="visitMerchant()">Visit Merchant</button>
                <button class="campButton" onclick="rest()">Rest</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // DUNGEON CRAWLER 3D - DPI Standardized Controls
        // This game uses standardized mouse sensitivity and DPI normalization to ensure
        // consistent camera movement across different mouse DPI settings (400, 800, 1600, etc.)
        // The gameState.mouseSensitivity and gameState.dpiMultiplier can be adjusted
        // for user preference while maintaining consistent feel.
        
        // Game state
        let gameState = {
            currentScene: 'menu', // menu, classSelect, camp, dungeon
            player: null,
            currentLevel: 1,
            currentXP: 0,
            skillPoints: 0,
            inventory: [],
            campLevel: 1,
            merchantAvailable: false,
            lastMerchantVisit: 0,
            runCount: 0,
            totalXP: 0,
            gold: 100,
            unlockedSkills: [],
            currentWeapon: null,
            currentArmor: null,
            campUpgradeLevel: 0,
            mouseSensitivity: 0.001, // Standardized mouse sensitivity (DPI normalized)
            dpiMultiplier: 1.0, // DPI multiplier for different mouse DPI settings
            wallCollisionEnabled: true // Toggle for wall collision debugging
        };

        // Three.js variables
        let scene, camera, renderer;
        let player, dungeon, camp;
        let monsters = [];
        let items = [];
        let lights = [];

        // Game objects
        let playerStats = {
            health: 100,
            maxHealth: 100,
            mana: 100,
            maxMana: 100,
            stamina: 100,
            maxStamina: 100,
            level: 1,
            xp: 0,
            nextLevelXP: 100,
            strength: 10,
            agility: 10,
            intelligence: 10,
            skills: [],
            attackPower: 18,
            defense: 5,
            criticalChance: 0.05,
            dodgeChance: 0.1
        };

        // Skill tree data
        const skillTree = {
            warrior: {
                'weapon_mastery': { name: 'Weapon Mastery', cost: 1, prereq: [], effect: 'strength', value: 2 },
                'armor_training': { name: 'Armor Training', cost: 1, prereq: [], effect: 'defense', value: 3 },
                'battle_rage': { name: 'Battle Rage', cost: 2, prereq: ['weapon_mastery'], effect: 'attackPower', value: 5 },
                'iron_will': { name: 'Iron Will', cost: 2, prereq: ['armor_training'], effect: 'maxHealth', value: 20 },
                'berserker': { name: 'Berserker', cost: 3, prereq: ['battle_rage', 'iron_will'], effect: 'criticalChance', value: 0.1 }
            },
            mage: {
                'mana_flow': { name: 'Mana Flow', cost: 1, prereq: [], effect: 'maxMana', value: 0 },
                'spell_power': { name: 'Spell Power', cost: 1, prereq: [], effect: 'intelligence', value: 2 },
                'arcane_mastery': { name: 'Arcane Mastery', cost: 2, prereq: ['mana_flow'], effect: 'attackPower', value: 8 },
                'mental_fortress': { name: 'Mental Fortress', cost: 2, prereq: ['spell_power'], effect: 'defense', value: 4 },
                'archmage': { name: 'Archmage', cost: 3, prereq: ['arcane_mastery', 'mental_fortress'], effect: 'criticalChance', value: 0.15 }
            },
            rogue: {
                'stealth': { name: 'Stealth', cost: 1, prereq: [], effect: 'agility', value: 2 },
                'critical_strike': { name: 'Critical Strike', cost: 1, prereq: [], effect: 'criticalChance', value: 0.08 },
                'shadow_step': { name: 'Shadow Step', cost: 2, prereq: ['stealth'], effect: 'dodgeChance', value: 0.1 },
                'deadly_precision': { name: 'Deadly Precision', cost: 2, prereq: ['critical_strike'], effect: 'attackPower', value: 6 },
                'assassin': { name: 'Assassin', cost: 3, prereq: ['shadow_step', 'deadly_precision'], effect: 'criticalChance', value: 0.2 }
            }
        };

        // Combat system
        let combatState = {
            inCombat: false,
            currentTarget: null,
            attackCooldown: 0,
            lastAttack: 0
        };

        // Movement controls
        let moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            running: false,
            jumping: false
        };

        let keys = {};

        let selectedClass = null;

        // Initialize the game
        function init() {
            hideLoadingScreen();
            showMainMenu();
        }

        function hideLoadingScreen() {
            document.getElementById('loadingScreen').style.display = 'none';
        }

        function showMainMenu() {
            document.getElementById('mainMenu').style.display = 'flex';
            gameState.currentScene = 'menu';
        }

        function startNewGame() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('classSelection').style.display = 'block';
            gameState.currentScene = 'classSelect';
        }

        function selectClass(className) {
            selectedClass = className;
            document.querySelectorAll('.classOption').forEach(opt => opt.classList.remove('selected'));
            // Find the clicked element and add selected class
            const clickedElement = document.querySelector(`[onclick*="${className}"]`);
            if (clickedElement) {
                clickedElement.classList.add('selected');
            }
        }

        function confirmClass() {
            console.log('confirmClass called, selectedClass:', selectedClass);
            
            if (!selectedClass) {
                alert('Please select a class first!');
                return;
            }
            
            console.log('Setting player stats for class:', selectedClass);
            
            // Set player stats based on class
            switch(selectedClass) {
                case 'warrior':
                    playerStats.maxHealth = 120;
                    playerStats.maxMana = 50;
                    playerStats.maxStamina = 100;
                    playerStats.strength = 18;
                    playerStats.agility = 12;
                    playerStats.intelligence = 8;
                    break;
                case 'mage':
                    playerStats.maxHealth = 80;
                    playerStats.maxMana = 120;
                    playerStats.maxStamina = 60;
                    playerStats.strength = 8;
                    playerStats.agility = 10;
                    playerStats.intelligence = 18;
                    break;
                case 'rogue':
                    playerStats.maxHealth = 90;
                    playerStats.maxMana = 60;
                    playerStats.maxStamina = 110;
                    playerStats.strength = 12;
                    playerStats.agility = 18;
                    playerStats.intelligence = 10;
                    break;
                default:
                    console.error('Unknown class:', selectedClass);
                    return;
            }
            
            playerStats.health = playerStats.maxHealth;
            playerStats.mana = playerStats.maxMana;
            playerStats.stamina = playerStats.maxStamina;
            
            console.log('Player stats set:', playerStats);
            console.log('Hiding class selection, calling initGame');
            
            document.getElementById('classSelection').style.display = 'none';
            initGame();
        }

        function initGame() {
            console.log('initGame called');
            try {
                console.log('Initializing Three.js...');
                initThreeJS();
                console.log('Creating camp...');
                createCamp();
                console.log('Showing camp...');
                showCamp();
                console.log('Updating HUD...');
                updateHUD();
                console.log('Game initialization complete');
            } catch (error) {
                console.error('Error in initGame:', error);
                alert('Error initializing game: ' + error.message);
            }
        }

        function initThreeJS() {
            console.log('initThreeJS called');
            try {
                // Create scene
                console.log('Creating scene...');
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a1a); // Dark for dungeon feel

                // Create camera with Doom-style FOV
                console.log('Creating camera...');
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 1.7, 0); // Spawn in center of center room, not walled off

                // Create renderer
                console.log('Creating renderer...');
                renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Add lights
                console.log('Adding lights...');
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);

                // Add point lights for atmosphere
                const pointLight1 = new THREE.PointLight(0xff6600, 0.8, 20);
                pointLight1.position.set(-10, 5, -10);
                scene.add(pointLight1);

                const pointLight2 = new THREE.PointLight(0x0066ff, 0.6, 15);
                pointLight2.position.set(10, 3, 10);
                scene.add(pointLight2);

                // Setup input handlers
                console.log('Setting up input handlers...');
                setupInputHandlers();

                // Start render loop
                console.log('Starting render loop...');
                animate();
                
                console.log('Three.js initialization complete');
            } catch (error) {
                console.error('Error in initThreeJS:', error);
                throw error;
            }
        }

        function setupInputHandlers() {
            // Keyboard events
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
                handleKeyDown(event);
            });

            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
                handleKeyUp(event);
            });

            // Mouse events for combat
            document.addEventListener('click', handleMouseClick);
            document.addEventListener('mousemove', handleMouseMove);
            
            // Setup pointer lock for first-person controls
            document.addEventListener('click', () => {
                if (gameState.currentScene === 'dungeon') {
                    document.body.requestPointerLock();
                }
            });
        }

        function handleKeyDown(event) {
            switch(event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    moveState.forward = true;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveState.backward = true;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    moveState.left = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveState.right = true;
                    break;
                case 'ShiftLeft':
                    moveState.running = true;
                    break;
                case 'Space':
                    moveState.jumping = true;
                    break;
                case 'KeyE':
                    if (gameState.currentScene === 'dungeon') {
                        // Check if player is facing the exit portal
                        const exitPortal = dungeon.children.find(child => child.userData.type === 'exit');
                        if (exitPortal) {
                            const directionToPortal = new THREE.Vector3();
                            directionToPortal.subVectors(exitPortal.position, camera.position).normalize();
                            const playerForward = new THREE.Vector3(0, 0, -1);
                            playerForward.applyQuaternion(camera.quaternion);
                            
                            const angleToPortal = playerForward.angleTo(directionToPortal);
                            
                            // If player is facing the portal (within 45 degrees) and close enough
                            if (angleToPortal < Math.PI / 4 && camera.position.distanceTo(exitPortal.position) < 5) {
                                goDeeper();
                            } else {
                                // Check for nearby doors to interact with
                                const nearestDoor = getNearestDoor(camera.position);
                                if (nearestDoor) {
                                    toggleDoor(nearestDoor);
                                }
                            }
                        } else {
                            // Check for nearby doors to interact with
                            const nearestDoor = getNearestDoor(camera.position);
                            if (nearestDoor) {
                                toggleDoor(nearestDoor);
                            }
                        }
                    } else {
                        interactWithNearby();
                    }
                    break;
                case 'KeyQ':
                    useSpecialAbility();
                    break;
                case 'KeyM':
                    if (gameState.currentScene === 'dungeon') {
                        toggleMinimap();
                    }
                    break;
                case 'KeyI':
                    if (gameState.currentScene === 'dungeon') {
                        toggleInventory();
                    }
                    break;
                case 'BracketLeft': // [ key - decrease mouse sensitivity
                    adjustMouseSensitivity('down');
                    break;
                case 'BracketRight': // ] key - increase mouse sensitivity
                    adjustMouseSensitivity('up');
                    break;
                case 'Semicolon': // ; key - decrease DPI multiplier
                    adjustDPIMultiplier('down');
                    break;
                case 'Quote': // ' key - increase DPI multiplier
                    adjustDPIMultiplier('up');
                    break;
                case 'KeyR':
                    if (event.shiftKey) { // Shift+R to reset mouse settings
                        resetMouseSettings();
                    }
                    break;
                case 'F1':
                    // Toggle wall collision for debugging
                    if (gameState.currentScene === 'dungeon') {
                        toggleWallCollision();
                    }
                    break;
                case 'Escape':
                    if (gameState.currentScene === 'dungeon') {
                        returnToCamp();
                    }
                    break;
            }
        }

        function handleKeyUp(event) {
            switch(event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    moveState.forward = false;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveState.backward = false;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    moveState.left = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveState.right = false;
                    break;
                case 'ShiftLeft':
                    moveState.running = false;
                    break;
                case 'Space':
                    moveState.jumping = false;
                    break;
            }
        }

        function handleMouseClick(event) {
            if (gameState.currentScene === 'dungeon') {
                // Raycast to find target
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                
                // Check for monster intersections
                const monsterIntersects = raycaster.intersectObjects(monsters);
                if (monsterIntersects.length > 0) {
                    const target = monsterIntersects[0].object;
                    if (target.userData.health > 0) {
                        attackTarget(target);
                        return;
                    }
                }
                
                // Check for item intersections
                const itemIntersects = raycaster.intersectObjects(items);
                if (itemIntersects.length > 0) {
                    const item = itemIntersects[0].object;
                    if (camera.position.distanceTo(item.position) < 5) {
                        collectItem(item);
                        return;
                    }
                }
                
                // Check for door intersections
                if (window.dungeonDoors) {
                    const doorIntersects = raycaster.intersectObjects(window.dungeonDoors);
                    if (doorIntersects.length > 0) {
                        const door = doorIntersects[0].object;
                        if (camera.position.distanceTo(door.position) < 4) {
                            toggleDoor(door);
                            return;
                        }
                    }
                }
                
                // If no target found, try to attack nearest monster in range
                const nearestMonster = findNearestMonster();
                if (nearestMonster && camera.position.distanceTo(nearestMonster.position) < 4) {
                    attackTarget(nearestMonster);
                }
            } else if (gameState.currentScene === 'camp') {
                // Handle camp button interactions
                handleCampButtonClick();
            }
        }
        
        function findNearestMonster() {
            let nearest = null;
            let minDistance = Infinity;
            
            monsters.forEach(monster => {
                if (monster.userData.health > 0) {
                    const distance = camera.position.distanceTo(monster.position);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = monster;
                    }
                }
            });
            
            return nearest;
        }

        function handleMouseMove(event) {
            if (gameState.currentScene === 'dungeon') {
                // Update camera rotation based on mouse movement with DPI normalization
                // Uses standardized sensitivity from gameState for consistent feel across different mice
                
                // Normalize mouse movement to standard DPI (800 DPI is common)
                const normalizedMovementX = event.movementX * gameState.dpiMultiplier;
                const normalizedMovementY = event.movementY * gameState.dpiMultiplier;
                
                // Apply smooth rotation with sensitivity from gameState
                camera.rotation.y -= normalizedMovementX * gameState.mouseSensitivity;
                camera.rotation.x -= normalizedMovementY * gameState.mouseSensitivity;
                
                // Clamp vertical rotation to prevent over-rotation (Doom-style limits)
                camera.rotation.x = Math.max(-Math.PI/4, Math.min(Math.PI/4, camera.rotation.x));
                
                // Keep crosshair centered
                const crosshair = document.getElementById('crosshair');
                if (crosshair) {
                    crosshair.style.left = '50%';
                    crosshair.style.top = '50%';
                }
            }
        }

        function createCamp() {
            camp = new THREE.Group();

            // Create detailed ground with grass texture
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x228B22,
                emissive: 0x0A3A0A
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            camp.add(ground);

            // Create detailed campfire with logs and flames
            const campfireGroup = new THREE.Group();
            
            // Fire pit
            const firePitGeometry = new THREE.CylinderGeometry(1.2, 1.5, 0.3, 8);
            const firePitMaterial = new THREE.MeshLambertMaterial({ color: 0x2F2F2F });
            const firePit = new THREE.Mesh(firePitGeometry, firePitMaterial);
            firePit.position.y = 0.15;
            campfireGroup.add(firePit);
            
            // Logs
            for (let i = 0; i < 6; i++) {
                const logGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 6);
                const logMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const log = new THREE.Mesh(logGeometry, logMaterial);
                log.position.y = 0.75;
                log.rotation.z = (i / 6) * Math.PI * 2;
                log.rotation.x = Math.PI / 2;
                campfireGroup.add(log);
            }
            
            // Flames
            const flameGeometry = new THREE.ConeGeometry(0.8, 1.5, 8);
            const flameMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFF4500,
                emissive: 0xFF6600,
                transparent: true,
                opacity: 0.8
            });
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.position.y = 1.2;
            campfireGroup.add(flame);
            
            // Add fire light
            const fireLight = new THREE.PointLight(0xFF6600, 1.5, 15);
            fireLight.position.y = 1.5;
            campfireGroup.add(fireLight);
            
            camp.add(campfireGroup);

            // Create detailed medieval tent
            const tentGroup = new THREE.Group();
            
            // Tent poles
            for (let i = 0; i < 4; i++) {
                const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 4, 6);
                const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                const angle = (i / 4) * Math.PI * 2;
                const radius = 1.5;
                pole.position.set(
                    Math.cos(angle) * radius,
                    2,
                    Math.sin(angle) * radius
                );
                tentGroup.add(pole);
            }
            
            // Tent fabric (cone)
            const tentGeometry = new THREE.ConeGeometry(2.5, 3.5, 8);
            const tentMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513,
                transparent: true,
                opacity: 0.9
            });
            const tent = new THREE.Mesh(tentGeometry, tentMaterial);
            tent.position.y = 1.75;
            tentGroup.add(tent);
            
            // Tent entrance
            const entranceGeometry = new THREE.BoxGeometry(1.5, 2, 0.1);
            const entranceMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const entrance = new THREE.Mesh(entranceGeometry, entranceMaterial);
            entrance.position.set(0, 1, 2.5);
            tentGroup.add(entrance);
            
            tentGroup.position.set(8, 0, 8);
            camp.add(tentGroup);

            // Create supply crates
            for (let i = 0; i < 3; i++) {
                const crateGeometry = new THREE.BoxGeometry(1, 1, 1);
                const crateMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const crate = new THREE.Mesh(crateGeometry, crateMaterial);
                crate.position.set(-5 + i * 2, 0.5, -8);
                crate.castShadow = true;
                camp.add(crate);
            }

            // Create water barrel
            const barrelGeometry = new THREE.CylinderGeometry(0.8, 0.8, 1.2, 8);
            const barrelMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.position.set(-8, 0.6, 5);
            barrel.castShadow = true;
            camp.add(barrel);

            // Create merchant stall (if available)
            if (gameState.merchantAvailable) {
                createMerchantStall();
            }
            
            // Create interactive camp buttons
            createCampButtons();
            
            // Apply camp upgrades
            applyCampUpgrades();

            scene.add(camp);
        }

        function createMerchantStall() {
            const stallGroup = new THREE.Group();
            
            // Main stall structure
            const stallGeometry = new THREE.BoxGeometry(4, 2.5, 3);
            const stallMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513,
                emissive: 0x1A1A1A
            });
            const stall = new THREE.Mesh(stallGeometry, stallMaterial);
            stall.position.y = 1.25;
            stall.castShadow = true;
            stallGroup.add(stall);
            
            // Stall roof
            const roofGeometry = new THREE.BoxGeometry(4.5, 0.2, 3.5);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 2.6;
            stallGroup.add(roof);
            
            // Stall counter
            const counterGeometry = new THREE.BoxGeometry(3.5, 0.8, 0.5);
            const counterMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const counter = new THREE.Mesh(counterGeometry, counterMaterial);
            counter.position.set(0, 0.4, 1.5);
            stallGroup.add(counter);
            
            // Merchant figure (simplified)
            const merchantBodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
            const merchantBodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
            const merchantBody = new THREE.Mesh(merchantBodyGeometry, merchantBodyMaterial);
            merchantBody.position.set(0, 1.1, 0.5);
            stallGroup.add(merchantBody);
            
            // Merchant head
            const merchantHeadGeometry = new THREE.SphereGeometry(0.25, 8, 6);
            const merchantHeadMaterial = new THREE.MeshLambertMaterial({ color: 0xFFE4B5 });
            const merchantHead = new THREE.Mesh(merchantHeadGeometry, merchantHeadMaterial);
            merchantHead.position.set(0, 1.8, 0.5);
            stallGroup.add(merchantHead);
            
            // Merchant hat
            const hatGeometry = new THREE.ConeGeometry(0.3, 0.4, 8);
            const hatMaterial = new THREE.MeshLambertMaterial({ color: 0x8B0000 });
            const hat = new THREE.Mesh(hatGeometry, hatMaterial);
            hat.position.set(0, 2.1, 0.5);
            stallGroup.add(hat);
            
            // Display items on counter
            for (let i = 0; i < 3; i++) {
                const itemGeometry = new THREE.SphereGeometry(0.2, 6, 6);
                const itemMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                const item = new THREE.Mesh(itemGeometry, itemMaterial);
                item.position.set(-1 + i, 0.8, 1.5);
                stallGroup.add(item);
            }
            
            // Stall sign
            const signGeometry = new THREE.BoxGeometry(2, 0.8, 0.1);
            const signMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.set(0, 2.8, 1.5);
            stallGroup.add(sign);
            
            stallGroup.position.set(-8, 0, -8);
            camp.add(stallGroup);
        }
        
        function createCampButtons() {
            // Create upgrade button near tent
            const upgradeButton = createInteractiveButton('UPGRADE CAMP', 0x228B22);
            upgradeButton.position.set(8, 0.5, 10);
            upgradeButton.userData = { type: 'upgrade', action: 'upgradeCamp' };
            camp.add(upgradeButton);
            
            // Create merchant button near merchant stall
            const merchantButton = createInteractiveButton('MERCHANT', 0xFFD700);
            merchantButton.position.set(-8, 0.5, -10);
            merchantButton.userData = { type: 'merchant', action: 'openMerchant' };
            camp.add(merchantButton);
            
            // Create skill tree button near campfire
            const skillButton = createInteractiveButton('SKILLS', 0x4169E1);
            skillButton.position.set(0, 0.5, 5);
            skillButton.userData = { type: 'skills', action: 'openSkills' };
            camp.add(skillButton);
        }
        
        function createInteractiveButton(text, color) {
            const buttonGroup = new THREE.Group();
            
            // Button base
            const buttonGeometry = new THREE.BoxGeometry(2, 0.3, 1);
            const buttonMaterial = new THREE.MeshLambertMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.3
            });
            const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
            buttonGroup.add(button);
            
            // Button text (simplified as 3D text)
            const textGeometry = new THREE.BoxGeometry(1.8, 0.1, 0.8);
            const textMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.5
            });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.y = 0.2;
            buttonGroup.add(textMesh);
            
            // Add glow effect
            const glowGeometry = new THREE.BoxGeometry(2.2, 0.4, 1.2);
            const glowMaterial = new THREE.MeshLambertMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 0.1;
            buttonGroup.add(glow);
            
            buttonGroup.castShadow = true;
            return buttonGroup;
        }
        
        function applyCampUpgrades() {
            const upgradeLevel = gameState.campUpgradeLevel || 0;
            
            // Apply visual upgrades based on level
            if (upgradeLevel >= 1) {
                // Level 1: Better lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
                camp.add(ambientLight);
            }
            
            if (upgradeLevel >= 2) {
                // Level 2: Decorative banners
                createBanners();
            }
            
            if (upgradeLevel >= 3) {
                // Level 3: Stone pathways
                createStonePathways();
            }
            
            if (upgradeLevel >= 4) {
                // Level 4: Guard towers
                createGuardTowers();
            }
            
            if (upgradeLevel >= 5) {
                // Level 5: Castle walls
                createCastleWalls();
            }
        }
        
        function createBanners() {
            const bannerPositions = [
                {x: 5, z: 5}, {x: -5, z: 5}, {x: 5, z: -5}, {x: -5, z: -5}
            ];
            
            bannerPositions.forEach(pos => {
                const banner = new THREE.Mesh(
                    new THREE.PlaneGeometry(1, 2),
                    new THREE.MeshLambertMaterial({ 
                        color: 0x8B0000,
                        emissive: 0x330000
                    })
                );
                banner.position.set(pos.x, 3, pos.z);
                banner.rotation.y = Math.PI / 4;
                camp.add(banner);
            });
        }
        
        function createStonePathways() {
            const pathGeometry = new THREE.PlaneGeometry(20, 2);
            const pathMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
            const path = new THREE.Mesh(pathGeometry, pathMaterial);
            path.rotation.x = -Math.PI / 2;
            path.position.y = 0.01;
            camp.add(path);
        }
        
        function createGuardTowers() {
            const towerPositions = [
                {x: 20, z: 20}, {x: -20, z: 20}, {x: 20, z: -20}, {x: -20, z: -20}
            ];
            
            towerPositions.forEach(pos => {
                const tower = new THREE.Mesh(
                    new THREE.CylinderGeometry(2, 2, 8, 8),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                tower.position.set(pos.x, 4, pos.z);
                tower.castShadow = true;
                camp.add(tower);
            });
        }
        
        function createCastleWalls() {
            const wallPositions = [
                {x: 25, z: 0}, {x: -25, z: 0}, {x: 0, z: 25}, {x: 0, z: -25}
            ];
            
            wallPositions.forEach(pos => {
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(50, 6, 2),
                    new THREE.MeshLambertMaterial({ color: 0x696969 })
                );
                wall.position.set(pos.x, 3, pos.z);
                wall.castShadow = true;
                camp.add(wall);
            });
        }
        
        function handleCampButtonClick() {
            // Raycast to find clicked button
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check for button intersections
            const buttonIntersects = raycaster.intersectObjects(camp.children.filter(child => child.userData && child.userData.type));
            if (buttonIntersects.length > 0) {
                const button = buttonIntersects[0].object;
                const action = button.userData.action;
                
                switch(action) {
                    case 'upgradeCamp':
                        upgradeCamp();
                        break;
                    case 'openMerchant':
                        openMerchant();
                        break;
                    case 'openSkills':
                        openSkillTree();
                        break;
                }
            }
        }
        
        function upgradeCamp() {
            const cost = (gameState.campUpgradeLevel + 1) * 50;
            
            if (gameState.gold >= cost) {
                gameState.gold -= cost;
                gameState.campUpgradeLevel++;
                
                // Recreate camp with new upgrades
                if (camp) {
                    scene.remove(camp);
                }
                createCamp();
                
                showMessage(`Camp upgraded to level ${gameState.campUpgradeLevel}! Cost: ${cost} gold`);
                updateHUD();
            } else {
                showMessage(`Not enough gold! Need ${cost} gold for upgrade.`);
            }
        }
        
        function openMerchant() {
            // Toggle merchant UI
            const merchantUI = document.getElementById('merchantUI');
            if (merchantUI) {
                merchantUI.style.display = merchantUI.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        function openSkillTree() {
            // Toggle skill tree UI
            const skillTreeUI = document.getElementById('skillTreeUI');
            if (skillTreeUI) {
                skillTreeUI.style.display = skillTreeUI.style.display === 'none' ? 'block' : 'none';
            }
        }

        function showCamp() {
            gameState.currentScene = 'camp';
            document.getElementById('campUI').style.display = 'block';
            document.getElementById('hud').style.display = 'block';
            
            // Clear dungeon HUD elements
            const dungeonElements = ['#skyrimHUD', '#topRightPanel', '#miniMap', '#monsterCounter', '#exitIndicator', '#depthIndicator', '#weaponStatus'];
            dungeonElements.forEach(selector => {
                const element = document.querySelector(selector);
                if (element) element.remove();
            });
            
            // Show original HUD elements for camp
            const hud = document.getElementById('hud');
            const originalHUD = hud.querySelector('.hudSection');
            if (originalHUD) {
                originalHUD.style.display = 'block';
            }
            
            // Style HUD for camp mode (peaceful, different from dungeon)
            hud.style.background = 'rgba(0, 0, 0, 0.7)';
            hud.style.border = '2px solid #228B22';
            hud.style.borderRadius = '15px';
            hud.style.boxShadow = '0 0 20px rgba(34, 139, 34, 0.5)';

            // Reset camera position for camp (better view)
            camera.position.set(0, 25, 30);
            camera.rotation.set(-Math.PI / 6, 0, 0);
            
            // Hide warrior sword in camp
            if (gameState.playerWeapon) {
                gameState.playerWeapon.visible = false;
            }
        }

        function enterDungeon() {
            gameState.currentScene = 'dungeon';
            document.getElementById('campUI').style.display = 'none';
            document.getElementById('crosshair').style.display = 'block';
            
            // Hide interaction prompts
            const doorPrompt = document.getElementById('doorPrompt');
            if (doorPrompt) doorPrompt.style.display = 'none';
            const portalPrompt = document.getElementById('portalPrompt');
            if (portalPrompt) portalPrompt.style.display = 'none';
            const collisionIndicator = document.getElementById('collisionIndicator');
            if (collisionIndicator) collisionIndicator.style.display = 'none';
            
            // Generate new dungeon level
            generateDungeon();
            
            // Position player at dungeon entrance (ON THE GROUND) - in center room
            camera.position.set(0, 1.7, 0);
            
            // Create player weapon if warrior and show it
            if (selectedClass === 'warrior') {
                createPlayerWeapon();
                if (gameState.playerWeapon) {
                    gameState.playerWeapon.visible = true;
                }
            }
            
            // Show dungeon-specific HUD
            showDungeonHUD();
        }
        
        function showDungeonHUD() {
            // Create Skyrim-style HUD elements
            const hud = document.getElementById('hud');
            
            // COMPLETELY CLEAR the HUD first
            hud.innerHTML = '';
            
            // Create Skyrim-style HUD container
            const skyrimHUD = document.createElement('div');
            skyrimHUD.id = 'skyrimHUD';
            skyrimHUD.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                gap: 20px;
                z-index: 200;
                pointer-events: none;
            `;
            
            // Health bar (left side)
            const healthBar = document.createElement('div');
            healthBar.style.cssText = `
                background: rgba(0, 0, 0, 0.7);
                border: 2px solid #8B0000;
                border-radius: 10px;
                padding: 10px;
                min-width: 200px;
                text-align: center;
            `;
            healthBar.innerHTML = `
                <div style="color: #FF4500; font-weight: bold; margin-bottom: 5px;">HEALTH</div>
                <div style="background: rgba(255, 255, 255, 0.2); border-radius: 5px; height: 20px; overflow: hidden;">
                    <div id="skyrimHealthFill" style="background: linear-gradient(90deg, #FF0000, #8B0000); height: 100%; width: ${(playerStats.health / playerStats.maxHealth * 100)}%; transition: width 0.3s ease;"></div>
                </div>
                <div style="color: #FFD700; font-size: 0.9rem; margin-top: 5px;">${Math.round(playerStats.health)}/${playerStats.maxHealth}</div>
            `;
            skyrimHUD.appendChild(healthBar);
            
            // Stamina bar (center)
            const staminaBar = document.createElement('div');
            staminaBar.style.cssText = `
                background: rgba(0, 0, 0, 0.7);
                border: 2px solid #FFD700;
                border-radius: 10px;
                padding: 10px;
                min-width: 150px;
                text-align: center;
            `;
            staminaBar.innerHTML = `
                <div style="color: #FFD700; font-weight: bold; margin-bottom: 5px;">STAMINA</div>
                <div style="background: rgba(255, 255, 255, 0.2); border-radius: 5px; height: 20px; overflow: hidden;">
                    <div id="skyrimStaminaFill" style="background: linear-gradient(90deg, #FFD700, #FFA500); height: 100%; width: ${(playerStats.stamina / playerStats.maxStamina * 100)}%; transition: width 0.3s ease;"></div>
                </div>
                <div style="color: #FFD700; font-size: 0.9rem; margin-top: 5px;">${Math.round(playerStats.stamina)}/${playerStats.maxStamina}</div>
            `;
            skyrimHUD.appendChild(staminaBar);
            
            // Mana bar (right side)
            const manaBar = document.createElement('div');
            manaBar.style.cssText = `
                background: rgba(0, 0, 0, 0.7);
                border: 2px solid #4169E1;
                border-radius: 10px;
                padding: 10px;
                min-width: 200px;
                text-align: center;
            `;
            manaBar.innerHTML = `
                <div style="color: #4169E1; font-weight: bold; margin-bottom: 5px;">MANA</div>
                <div style="background: rgba(255, 255, 255, 0.2); border-radius: 5px; height: 20px; overflow: hidden;">
                    <div id="skyrimManaFill" style="background: linear-gradient(90deg, #4169E1, #0000CD); height: 100%; width: ${(playerStats.mana / playerStats.maxMana * 100)}%; transition: width 0.3s ease;"></div>
                </div>
                <div style="color: #4169E1; font-size: 0.9rem; margin-top: 5px;">${Math.round(playerStats.mana)}/${playerStats.maxMana}</div>
            `;
            skyrimHUD.appendChild(manaBar);
            
            hud.appendChild(skyrimHUD);
            
            // Create top-right info panel (Skyrim style)
            const topRightPanel = document.createElement('div');
            topRightPanel.id = 'topRightPanel';
            topRightPanel.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.8);
                border: 2px solid #8B0000;
                border-radius: 10px;
                padding: 15px;
                min-width: 250px;
                z-index: 200;
                pointer-events: none;
            `;
            
            // Level and XP
            const levelInfo = document.createElement('div');
            levelInfo.style.cssText = `
                color: #FFD700;
                font-weight: bold;
                font-size: 1.1rem;
                margin-bottom: 10px;
                text-align: center;
            `;
            levelInfo.innerHTML = `LEVEL ${playerStats.level}`;
            topRightPanel.appendChild(levelInfo);
            
            // XP Bar
            const xpBar = document.createElement('div');
            xpBar.style.cssText = `
                background: rgba(255, 255, 255, 0.2);
                border-radius: 5px;
                height: 15px;
                overflow: hidden;
                margin-bottom: 10px;
            `;
            const xpFill = document.createElement('div');
            xpFill.id = 'skyrimXPFill';
            xpFill.style.cssText = `
                background: linear-gradient(90deg, #FFD700, #FFA500);
                height: 100%;
                width: ${(playerStats.xp / playerStats.nextLevelXP * 100)}%;
                transition: width 0.3s ease;
            `;
            xpBar.appendChild(xpFill);
            topRightPanel.appendChild(xpBar);
            
            // XP Text
            const xpText = document.createElement('div');
            xpText.style.cssText = `
                color: #FFD700;
                font-size: 0.9rem;
                text-align: center;
                margin-bottom: 15px;
            `;
            xpText.innerHTML = `XP: ${playerStats.xp}/${playerStats.nextLevelXP}`;
            topRightPanel.appendChild(xpText);
            
            // Monster counter
            const monsterCounter = document.createElement('div');
            monsterCounter.id = 'monsterCounter';
            monsterCounter.style.cssText = `
                color: #FF4500;
                font-weight: bold;
                text-align: center;
                margin-bottom: 10px;
            `;
            monsterCounter.innerHTML = `Monsters: ${monsters.length}`;
            topRightPanel.appendChild(monsterCounter);
            
            // Depth indicator
            const depthIndicator = document.createElement('div');
            depthIndicator.id = 'depthIndicator';
            depthIndicator.style.cssText = `
                color: #00ffff;
                font-weight: bold;
                text-align: center;
                margin-bottom: 10px;
            `;
            depthIndicator.innerHTML = `Depth: Level ${gameState.currentLevel}`;
            topRightPanel.appendChild(depthIndicator);
            
            // Weapon status for warriors
            if (selectedClass === 'warrior' && gameState.playerWeapon) {
                const weaponStatus = document.createElement('div');
                weaponStatus.id = 'weaponStatus';
                weaponStatus.style.cssText = `
                    color: #FFD700;
                    font-weight: bold;
                    text-align: center;
                    border: 1px solid #FFD700;
                    border-radius: 5px;
                    padding: 5px;
                    background: rgba(255, 215, 0, 0.1);
                    pointer-events: none;
                `;
                weaponStatus.innerHTML = `-`;
                topRightPanel.appendChild(weaponStatus);
            }
            
            hud.appendChild(topRightPanel);
            
            // Create mini-map (toggleable with M key)
            let miniMap = hud.querySelector('#miniMap');
            if (!miniMap) {
                miniMap = document.createElement('div');
                miniMap.id = 'miniMap';
                miniMap.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 20px;
                    width: 200px;
                    height: 200px;
                    background: rgba(0,0,0,0.9);
                    border: 2px solid #8B0000;
                    border-radius: 10px;
                    display: none;
                    z-index: 300;
                    box-shadow: 0 0 15px rgba(139, 0, 0, 0.6);
                    pointer-events: none;
                `;
                miniMap.innerHTML = '<h4 style="text-align: center; margin-bottom: 10px; color: #FF4500;">Dungeon Map (M to toggle)</h4>';
                hud.appendChild(miniMap);
                
                // Add mouse sensitivity help text
                const sensitivityHelp = document.createElement('div');
                sensitivityHelp.style.cssText = `
                    position: absolute;
                    bottom: 20px;
                    left: 20px;
                    background: rgba(0, 0, 0, 0.8);
                    color: #ccc;
                    padding: 10px;
                    border-radius: 5px;
                    font-size: 12px;
                    border: 1px solid #666;
                    pointer-events: none;
                    max-width: 300px;
                `;
                sensitivityHelp.innerHTML = `
                    <strong>Controls:</strong><br>
                    <strong>Mouse:</strong> [ ] - Adjust sensitivity<br>
                    ; ' - Adjust DPI multiplier<br>
                    Shift+R - Reset to default<br>
                    <strong>Doors:</strong> Click or E key to open/close<br>
                    <strong>Portal:</strong> Face exit portal and press E to go deeper<br>
                    <strong>Debug:</strong> F1 - Toggle wall collision<br>
                    <em>Settings are saved automatically</em>
                `;
                hud.appendChild(sensitivityHelp);
            }
        }

        function generateDungeon() {
            // Remove camp from scene
            scene.remove(camp);
            
            // Create AAA-quality dungeon
            dungeon = new THREE.Group();
            
            // Generate dungeon layout
            const dungeonSize = 20 + (gameState.currentLevel * 5);
            const roomCount = 5 + Math.floor(gameState.currentLevel / 2);
            
            // Create atmospheric dungeon floor with enhanced materials
            const floorGeometry = new THREE.PlaneGeometry(dungeonSize * 2, dungeonSize * 2, 64, 64);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1A1A1A,
                roughness: 0.9,
                metalness: 0.05
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.1;
            floor.receiveShadow = true;
            dungeon.add(floor);
            
            // Removed fog to reduce texture unit usage
            // scene.fog = new THREE.Fog(0x000000, 15, 50);
            
            // Create enhanced dungeon walls
            createDungeonWalls(dungeonSize);
            
            // Create AAA-quality walkable corridors and rooms
            createDungeonLayout(dungeonSize, roomCount);
            
            // Add atmospheric decorative elements
            addDungeonDecorations(dungeonSize);
            
            // Add atmospheric particles (dust, floating debris)
            addAtmosphericParticles();
            
            // Add monsters in accessible areas
            spawnMonsters(dungeonSize);
            
            // Add items and treasures
            spawnItems(dungeonSize);
            
            // Add enhanced exit portal
            createExitPortal(dungeonSize);
            
            console.log('dungeon generated with atmospheric effects');
            
            scene.add(dungeon);
        }
        
        function createDungeonLayout(dungeonSize, roomCount) {
            // Create a proper, non-overlapping dungeon layout
            console.log('Creating dungeon layout...');
            
            // Create main entrance room (center)
            createDungeonRoom(0, dungeonSize, roomCount, 0, 0);
            
            // Create side rooms (no overlap!)
            if (roomCount > 1) {
                createDungeonRoom(1, dungeonSize, roomCount, -16, 0);
            }
            if (roomCount > 2) {
                createDungeonRoom(2, dungeonSize, roomCount, 16, 0);
            }
            if (roomCount > 3) {
                createDungeonRoom(3, dungeonSize, roomCount, 0, -16);
            }
            if (roomCount > 4) {
                createDungeonRoom(4, dungeonSize, roomCount, 0, 16);
            }
            
            // Create corridors connecting rooms (adjusted positions)
            createCorridor(0, -8, 'horizontal', dungeonSize);
            createCorridor(0, 8, 'horizontal', dungeonSize);
            createCorridor(-8, 0, 'vertical', dungeonSize);
            createCorridor(8, 0, 'vertical', dungeonSize);
            
            // Create doors at room entrances (adjusted positions)
            // Add doors to connect rooms and corridors (properly positioned)
            createDoor(0, -8, 'horizontal', dungeonSize);  // North corridor entrance
            createDoor(0, 8, 'horizontal', dungeonSize);   // South corridor entrance
            createDoor(-8, 0, 'vertical', dungeonSize);    // West corridor entrance
            createDoor(8, 0, 'vertical', dungeonSize);     // East corridor entrance
            
            // Add doors at room entrances for better connectivity
            createDoor(-16, -8, 'horizontal', dungeonSize);  // Left room north entrance
            createDoor(-16, 8, 'horizontal', dungeonSize);   // Left room south entrance
            createDoor(16, -8, 'horizontal', dungeonSize);   // Right room north entrance
            createDoor(16, 8, 'horizontal', dungeonSize);    // Right room south entrance
            createDoor(-8, -16, 'vertical', dungeonSize);    // Back room west entrance
            createDoor(8, -16, 'vertical', dungeonSize);     // Back room east entrance
            createDoor(-8, 16, 'vertical', dungeonSize);     // Front room west entrance
            createDoor(8, 16, 'vertical', dungeonSize);      // Front room east entrance
            
            // Add door from center room to north corridor (CRITICAL - player escape route)
            createDoor(0, -4, 'horizontal', dungeonSize);  // Center room north exit
            
            console.log('Dungeon layout created with', roomCount, 'rooms (no overlap)');
        }
        
        function createCorridor(x, z, direction, dungeonSize) {
            const corridorWidth = 4;
            const corridorLength = 10;
            
            // Create detailed corridor floor
            let floorGeometry;
            if (direction === 'horizontal') {
                floorGeometry = new THREE.PlaneGeometry(corridorLength, corridorWidth, 6, 4);
            } else {
                floorGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength, 4, 6);
            }
            
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2F2F2F
            });
            
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(x, 0.01, z);
            floor.receiveShadow = true;
            dungeon.add(floor);
            
            // Create corridor walls
            const wallHeight = 5;
            const wallThickness = 0.6;
            
            if (direction === 'horizontal') {
                // North wall
                const northWall = createDetailedWall(corridorLength, wallHeight, wallThickness, 0x4A4A4A);
                northWall.position.set(x, wallHeight/2, z - corridorWidth/2);
                dungeon.add(northWall);
                
                // South wall
                const southWall = createDetailedWall(corridorLength, wallHeight, wallThickness, 0x4A4A4A);
                southWall.position.set(x, wallHeight/2, z + corridorWidth/2);
                southWall.rotation.y = Math.PI;
                dungeon.add(southWall);
            } else {
                // East wall
                const eastWall = createDetailedWall(corridorWidth, wallHeight, wallThickness, 0x4A4A4A);
                eastWall.position.set(x + corridorWidth/2, wallHeight/2, z);
                eastWall.rotation.y = Math.PI / 2;
                dungeon.add(eastWall);
                
                // West wall
                const westWall = createDetailedWall(corridorWidth, wallHeight, wallThickness, 0x4A4A4A);
                westWall.position.set(x - corridorWidth/2, wallHeight/2, z);
                westWall.rotation.y = -Math.PI / 2;
                dungeon.add(westWall);
            }
            
            // Add corridor lighting (simplified for WebGL compatibility)
            const corridorLight = new THREE.PointLight(0xFFAA44, 0.4, 12, 2);
            corridorLight.position.set(x, 3, z);
            corridorLight.castShadow = false; // Disable shadows to reduce texture units
            dungeon.add(corridorLight);
            
            // Add wall-mounted torches in corridors
            if (direction === 'horizontal') {
                const torch1 = createAtmosphericTorch();
                torch1.position.set(x - corridorLength/3, 3, z - corridorWidth/2 + 0.3);
                torch1.rotation.y = 0;
                dungeon.add(torch1);
                
                const torch2 = createAtmosphericTorch();
                torch2.position.set(x + corridorLength/3, 3, z + corridorWidth/2 - 0.3);
                torch2.rotation.y = Math.PI;
                dungeon.add(torch2);
            } else {
                const torch1 = createAtmosphericTorch();
                torch1.position.set(x - corridorWidth/2 + 0.3, 3, z - corridorLength/3);
                torch1.rotation.y = Math.PI / 2;
                dungeon.add(torch1);
                
                const torch2 = createAtmosphericTorch();
                torch2.position.set(x + corridorWidth/2 - 0.3, 3, z - corridorLength/3);
                torch2.rotation.y = -Math.PI / 2;
                dungeon.add(torch2);
            }
        }
        
        function createDoor(x, z, direction, dungeonSize) {
            const doorWidth = 2;
            const doorHeight = 4;
            const doorDepth = 0.3;
            
            // Create door group for easier manipulation
            const doorGroup = new THREE.Group();
            doorGroup.userData = { type: 'door', isOpen: false, direction: direction, x: x, z: z };
            
            if (direction === 'horizontal') {
                // Create detailed wooden door for horizontal corridors
                const doorGeometry = new THREE.BoxGeometry(doorDepth, doorHeight, doorWidth);
                            const doorMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513
                });
                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.set(0, 0, 0);
                door.castShadow = true;
                door.userData = { type: 'door', isOpen: false };
                doorGroup.add(door);
                
                // Add ornate door frame
                const frameGeometry = new THREE.BoxGeometry(0.4, doorHeight + 0.8, doorWidth + 0.4);
                const frameMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x654321
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.set(0.15, 0, 0);
                frame.castShadow = true;
                doorGroup.add(frame);
                
                // Add door handle
                const handleGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const handleMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xFFD700
                });
                const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                handle.position.set(0.2, 0, doorWidth/2 - 0.3);
                doorGroup.add(handle);
                
                // Position door group on the wall (north side of corridor)
                doorGroup.position.set(x, doorHeight/2, z - 2);
                
            } else {
                // Create detailed wooden door for vertical corridors
                const doorGeometry = new THREE.BoxGeometry(doorWidth, doorHeight, doorDepth);
                const doorMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513
                });
                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.set(0, 0, 0);
                door.castShadow = true;
                door.userData = { type: 'door', isOpen: false };
                doorGroup.add(door);
                
                // Add ornate door frame
                const frameGeometry = new THREE.BoxGeometry(doorWidth + 0.4, doorHeight + 0.8, 0.4);
                const frameMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x654321
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.set(0, 0, 0.15);
                frame.castShadow = true;
                doorGroup.add(frame);
                
                // Add door handle
                const handleGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const handleMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xFFD700
                });
                const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                handle.position.set(doorWidth/2 - 0.3, 0, 0.2);
                doorGroup.add(handle);
                
                // Position door group on the wall (west side of corridor)
                doorGroup.position.set(x - 2, doorHeight/2, z);
            }
            
            // Add door to dungeon and store reference for interaction
            dungeon.add(doorGroup);
            if (!window.dungeonDoors) window.dungeonDoors = [];
            window.dungeonDoors.push(doorGroup);
            
            console.log(`Created interactive door at (${x}, ${z}) for ${direction} direction`);
        }
        
        function toggleDoor(door) {
            // Toggle door open/closed state
            if (door.userData.isOpen) {
                closeDoor(door);
            } else {
                openDoor(door);
            }
        }
        
        function openDoor(door) {
            // Open the door by rotating it
            const direction = door.userData.direction;
            const openAngle = Math.PI / 2; // 90 degrees
            
            if (direction === 'horizontal') {
                // Rotate around Y axis for horizontal doors
                door.rotation.y = -openAngle;
            } else {
                // Rotate around Y axis for vertical doors
                door.rotation.y = openAngle;
            }
            
            door.userData.isOpen = true;
            showMessage('Door opened');
            
            // Play door sound effect (if available)
            // playSound('door_open');
        }
        
        function closeDoor(door) {
            // Close the door by resetting rotation
            door.rotation.y = 0;
            door.userData.isOpen = false;
            showMessage('Door closed');
            
            // Play door sound effect (if available)
            // playSound('door_close');
        }
        
        function getNearestDoor(playerPosition, maxDistance = 3) {
            // Find the nearest door within interaction range
            if (!window.dungeonDoors) return null;
            
            let nearestDoor = null;
            let nearestDistance = maxDistance;
            
            for (let door of window.dungeonDoors) {
                const distance = playerPosition.distanceTo(door.position);
                if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestDoor = door;
                }
            }
            
            return nearestDoor;
        }
        
        function showDoorInteractionPrompt() {
            // Show door interaction prompt when near a door
            const nearestDoor = getNearestDoor(camera.position);
            if (nearestDoor) {
                const prompt = document.getElementById('doorPrompt') || createDoorPrompt();
                prompt.style.display = 'block';
                prompt.textContent = `Click to ${nearestDoor.userData.isOpen ? 'Close' : 'Open'} Door`;
            } else {
                const prompt = document.getElementById('doorPrompt');
                if (prompt) prompt.style.display = 'none';
            }
        }
        
        function showPortalInteractionPrompt() {
            // Show portal interaction prompt when near and facing the exit portal
            const exitPortal = dungeon.children.find(child => child.userData.type === 'exit');
            if (exitPortal) {
                const directionToPortal = new THREE.Vector3();
                directionToPortal.subVectors(exitPortal.position, camera.position).normalize();
                const playerForward = new THREE.Vector3(0, 0, -1);
                playerForward.applyQuaternion(camera.quaternion);
                
                const angleToPortal = playerForward.angleTo(directionToPortal);
                const distanceToPortal = camera.position.distanceTo(exitPortal.position);
                
                // If player is facing the portal (within 45 degrees) and close enough
                if (angleToPortal < Math.PI / 4 && distanceToPortal < 5) {
                    const prompt = document.getElementById('portalPrompt') || createPortalPrompt();
                    prompt.style.display = 'block';
                    prompt.textContent = 'Press E to go deeper into the dungeon';
                } else {
                    const prompt = document.getElementById('portalPrompt');
                    if (prompt) prompt.style.display = 'none';
                }
            }
        }
        
        function createPortalPrompt() {
            // Create portal interaction prompt element
            const prompt = document.createElement('div');
            prompt.id = 'portalPrompt';
            prompt.style.cssText = `
                position: absolute;
                bottom: 150px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.8);
                color: #00ffff;
                padding: 10px 20px;
                border-radius: 5px;
                border: 1px solid #00ffff;
                font-size: 14px;
                font-weight: bold;
                text-align: center;
                pointer-events: none;
                z-index: 1000;
                display: none;
            `;
            document.body.appendChild(prompt);
            return prompt;
        }
        
        function createDoorPrompt() {
            // Create door interaction prompt element
            const prompt = document.createElement('div');
            prompt.id = 'doorPrompt';
            prompt.style.cssText = `
                position: absolute;
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.8);
                color: #00ff00;
                padding: 10px 20px;
                border-radius: 5px;
                border: 1px solid #00ff00;
                font-size: 14px;
                font-weight: bold;
                text-align: center;
                pointer-events: none;
                z-index: 1000;
                display: none;
            `;
            document.body.appendChild(prompt);
            return prompt;
        }

        function createDungeonWalls(dungeonSize) {
            const wallHeight = 6;
            const wallThickness = 0.5;
            
            // Create stone wall material with better texture
            const wallMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x3A3A3A,
                emissive: 0x0A0A0A
            });
            
            // North wall
            const northWall = new THREE.Mesh(
                new THREE.BoxGeometry(dungeonSize * 2, wallHeight, wallThickness),
                wallMaterial
            );
            northWall.position.set(0, wallHeight / 2, -dungeonSize);
            northWall.castShadow = true;
            northWall.receiveShadow = true;
            
            // Add wall details (bricks/stone pattern)
            addWallDetails(northWall, 'horizontal');
            dungeon.add(northWall);
            
            // South wall
            const southWall = new THREE.Mesh(
                new THREE.BoxGeometry(dungeonSize * 2, wallHeight, wallThickness),
                wallMaterial
            );
            southWall.position.set(0, wallHeight / 2, dungeonSize);
            southWall.castShadow = true;
            southWall.receiveShadow = true;
            addWallDetails(southWall, 'horizontal');
            dungeon.add(southWall);
            
            // East wall
            const eastWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, dungeonSize * 2),
                wallMaterial
            );
            eastWall.position.set(dungeonSize, wallHeight / 2, 0);
            eastWall.castShadow = true;
            eastWall.receiveShadow = true;
            addWallDetails(eastWall, 'vertical');
            dungeon.add(eastWall);
            
            // West wall
            const westWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, dungeonSize * 2),
                wallMaterial
            );
            westWall.position.set(-dungeonSize, wallHeight / 2, 0);
            westWall.castShadow = true;
            westWall.receiveShadow = true;
            addWallDetails(westWall, 'vertical');
            dungeon.add(westWall);
        }
        
        function addWallDetails(wall, orientation) {
            // Simplified wall details for WebGL compatibility
            const brickSize = 1.6; // Larger bricks, fewer instances
            const brickHeight = 0.8;
            const brickMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2A2A2A
            });
            
            const wallWidth = wall.geometry.parameters.width;
            const wallHeight = wall.geometry.parameters.height;
            const wallDepth = wall.geometry.parameters.depth;
            
            // Reduced brick count for better performance
            for (let x = -wallWidth/2 + brickSize/2; x < wallWidth/2; x += brickSize * 1.5) {
                for (let y = 0; y < wallHeight; y += brickHeight * 1.5) {
                    const brick = new THREE.Mesh(
                        new THREE.BoxGeometry(brickSize * 0.9, brickHeight * 0.9, wallDepth * 1.1),
                        brickMaterial
                    );
                    
                    if (orientation === 'horizontal') {
                        brick.position.set(x, y, 0);
                    } else {
                        brick.position.set(0, y, x);
                    }
                    
                    wall.add(brick);
                }
            }
        }

        function createDungeonRoom(roomIndex, dungeonSize, roomCount, posX, posZ) {
            const roomSize = 12;
            
            // Create detailed stone floor with simplified materials
            const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize, 8, 8);
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2F2F2F
            });
            
            // Add stone texture pattern to floor
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(posX, 0.01, posZ);
            floor.receiveShadow = true;
            dungeon.add(floor);
            
            // Create detailed stone walls with proper materials
            const wallHeight = 6;
            const wallThickness = 0.8;
            const doorWidth = 2;
            const doorHeight = 4;
            
            // Determine which walls need doors based on room position
            let northWall, southWall, eastWall, westWall;
            
            if (posX === 0 && posZ === 0) {
                // Center room - needs north door
                northWall = createWallWithDoor(roomSize, wallHeight, wallThickness, 0x4A4A4A, 0, doorWidth, doorHeight, 'horizontal');
                southWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
                eastWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
                westWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
            } else if (posX === -16 && posZ === 0) {
                // Left room - needs north and south doors
                northWall = createWallWithDoor(roomSize, wallHeight, wallThickness, 0x4A4A4A, 0, doorWidth, doorHeight, 'horizontal');
                southWall = createWallWithDoor(roomSize, wallHeight, wallThickness, 0x4A4A4A, 0, doorWidth, doorHeight, 'horizontal');
                eastWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
                westWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
            } else if (posX === 16 && posZ === 0) {
                // Right room - needs north and south doors
                northWall = createWallWithDoor(roomSize, wallHeight, wallThickness, 0x4A4A4A, 0, doorWidth, doorHeight, 'horizontal');
                southWall = createWallWithDoor(roomSize, wallHeight, wallThickness, 0x4A4A4A, 0, doorWidth, doorHeight, 'horizontal');
                eastWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
                westWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
            } else if (posX === 0 && posZ === -16) {
                // Back room - needs east and west doors
                northWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
                southWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
                eastWall = createWallWithDoor(roomSize, wallHeight, wallThickness, 0x4A4A4A, 0, doorWidth, doorHeight, 'vertical');
                westWall = createWallWithDoor(roomSize, wallHeight, wallThickness, 0x4A4A4A, 0, doorWidth, doorHeight, 'vertical');
            } else if (posX === 0 && posZ === 16) {
                // Front room - needs east and west doors
                northWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
                southWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
                eastWall = createWallWithDoor(roomSize, wallHeight, wallThickness, 0x4A4A4A, 0, doorWidth, doorHeight, 'vertical');
                westWall = createWallWithDoor(roomSize, wallHeight, wallThickness, 0x4A4A4A, 0, doorWidth, doorHeight, 'vertical');
            } else {
                // Default walls for other rooms
                northWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
                southWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
                eastWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
                westWall = createDetailedWall(roomSize, wallHeight, wallThickness, 0x4A4A4A);
            }
            
            // Position walls
            northWall.position.set(posX, wallHeight/2, posZ - roomSize/2);
            southWall.position.set(posX, wallHeight/2, posZ + roomSize/2);
            southWall.rotation.y = Math.PI;
            eastWall.position.set(posX + roomSize/2, wallHeight/2, posZ);
            eastWall.rotation.y = Math.PI / 2;
            westWall.position.set(posX - roomSize/2, wallHeight/2, posZ);
            westWall.rotation.y = -Math.PI / 2;
            
            // Add walls to dungeon
            dungeon.add(northWall);
            dungeon.add(southWall);
            dungeon.add(eastWall);
            dungeon.add(westWall);
            
            // Add detailed stone pillars with carvings
            for (let i = 0; i < 4; i++) {
                const pillar = createDetailedPillar();
                const cornerX = posX + (i < 2 ? -roomSize/2 + 1.5 : roomSize/2 - 1.5);
                const cornerZ = posZ + (i % 2 === 0 ? -roomSize/2 + 1.5 : roomSize/2 - 1.5);
                pillar.position.set(cornerX, 3, cornerZ);
                dungeon.add(pillar);
            }
            
            // Add atmospheric lighting to each room (simplified for WebGL compatibility)
            const roomLight = new THREE.PointLight(0xFFAA44, 0.6, 15, 2);
            roomLight.position.set(posX, 4, posZ);
            roomLight.castShadow = false; // Disable shadows to reduce texture units
            dungeon.add(roomLight);
            
            // Add wall-mounted torches
            addWallTorches(posX, posZ, roomSize);
            
            // Add decorative elements
            addRoomDecorations(posX, posZ, roomSize, roomIndex);
            
            console.log(`Created room ${roomIndex} at position (${posX}, ${posZ})`);
        }
        
        function createDetailedWall(width, height, thickness, color) {
            const wallGroup = new THREE.Group();
            
            // Main wall structure
            const wallGeometry = new THREE.BoxGeometry(width, height, thickness, 4, 4, 1);
            const wallMaterial = new THREE.MeshLambertMaterial({ 
                color: color
            });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.castShadow = true;
            wall.receiveShadow = true;
            wallGroup.add(wall);
            
            // Add stone brick pattern (simplified)
            const brickGeometry = new THREE.PlaneGeometry(width - 0.2, height - 0.2, 8, 8);
            const brickMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x3A3A3A,
                transparent: true,
                opacity: 0.3
            });
            const brickPattern = new THREE.Mesh(brickGeometry, brickMaterial);
            brickPattern.position.z = thickness/2 + 0.01;
            wallGroup.add(brickPattern);
            
            return wallGroup;
        }
        
        function createWallWithDoor(width, height, thickness, color, doorPosition, doorWidth, doorHeight, direction) {
            const wallGroup = new THREE.Group();
            
            // Create wall with door opening using CSG-like approach
            // Left section of wall
            if (doorPosition > -width/2 + doorWidth/2) {
                const leftWidth = doorPosition - (-width/2 + doorWidth/2);
                if (leftWidth > 0) {
                    const leftGeometry = new THREE.BoxGeometry(leftWidth, height, thickness);
                    const leftMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const leftWall = new THREE.Mesh(leftGeometry, leftMaterial);
                    leftWall.position.set(-width/2 + leftWidth/2, 0, 0);
                    leftWall.castShadow = true;
                    leftWall.receiveShadow = true;
                    wallGroup.add(leftWall);
                }
            }
            
            // Right section of wall
            if (doorPosition < width/2 - doorWidth/2) {
                const rightWidth = (width/2 - doorWidth/2) - doorPosition;
                if (rightWidth > 0) {
                    const rightGeometry = new THREE.BoxGeometry(rightWidth, height, thickness);
                    const rightMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const rightWall = new THREE.Mesh(rightGeometry, rightMaterial);
                    rightWall.position.set(doorPosition + doorWidth/2 + rightWidth/2, 0, 0);
                    rightWall.castShadow = true;
                    rightWall.receiveShadow = true;
                    wallGroup.add(rightWall);
                }
            }
            
            // Top section of wall (above door)
            if (doorHeight < height) {
                const topHeight = height - doorHeight;
                const topGeometry = new THREE.BoxGeometry(width, topHeight, thickness);
                const topMaterial = new THREE.MeshLambertMaterial({ color: color });
                const topWall = new THREE.Mesh(topGeometry, topMaterial);
                topWall.position.set(0, doorHeight + topHeight/2, 0);
                topWall.castShadow = true;
                topWall.receiveShadow = true;
                wallGroup.add(topWall);
            }
            
            // Add stone brick pattern to all wall sections
            wallGroup.children.forEach(wallSection => {
                const sectionWidth = wallSection.geometry.parameters.width;
                const sectionHeight = wallSection.geometry.parameters.height;
                
                const brickGeometry = new THREE.PlaneGeometry(sectionWidth - 0.2, sectionHeight - 0.2, 4, 4);
                const brickMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x3A3A3A,
                    transparent: true,
                    opacity: 0.3
                });
                const brickPattern = new THREE.Mesh(brickGeometry, brickMaterial);
                brickPattern.position.z = thickness/2 + 0.01;
                wallSection.add(brickPattern);
            });
            
            return wallGroup;
        }
        
        function createDetailedPillar() {
            const pillarGroup = new THREE.Group();
            
            // Main pillar
            const pillarGeometry = new THREE.CylinderGeometry(0.6, 0.6, 6, 12);
            const pillarMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x5D4E37
            });
            const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar.castShadow = true;
            pillar.receiveShadow = true;
            pillarGroup.add(pillar);
            
            // Pillar base
            const baseGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 12);
            const baseMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4A3E2E
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = -3.25;
            base.castShadow = true;
            pillarGroup.add(base);
            
            // Pillar top
            const topGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.4, 12);
            const topMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x6B5B47
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 3.2;
            top.castShadow = true;
            pillarGroup.add(top);
            
            return pillarGroup;
        }
        
        function addWallTorches(roomX, roomZ, roomSize) {
            const torchPositions = [
                { x: roomX - roomSize/2 + 0.5, z: roomZ - roomSize/2 + 2, rotation: 0 },
                { x: roomX + roomSize/2 - 0.5, z: roomZ - roomSize/2 + 2, rotation: Math.PI },
                { x: roomX - roomSize/2 + 2, z: roomZ + roomSize/2 - 0.5, rotation: Math.PI / 2 },
                { x: roomX + roomSize/2 - 2, z: roomZ + roomSize/2 - 0.5, rotation: -Math.PI / 2 }
            ];
            
            torchPositions.forEach((pos, index) => {
                const torch = createAtmosphericTorch();
                torch.position.set(pos.x, 3.5, pos.z);
                torch.rotation.y = pos.rotation;
                dungeon.add(torch);
            });
        }
        
        function createAtmosphericTorch() {
            const torchGroup = new THREE.Group();
            
            // Torch handle with wood grain
            const handleGeometry = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 8);
            const handleMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.y = 0.6;
            torchGroup.add(handle);
            
            // Torch flame with particle effect
            const flameGeometry = new THREE.SphereGeometry(0.25, 8, 8);
            const flameMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFF6600,
                emissive: 0xFF3300
            });
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.position.y = 1.3;
            torchGroup.add(flame);
            
            // Add atmospheric point light (simplified for WebGL compatibility)
            const torchLight = new THREE.PointLight(0xFFAA44, 1.2, 12, 2);
            torchLight.position.y = 1.3;
            torchLight.castShadow = false; // Disable shadows to reduce texture units
            torchGroup.add(torchLight);
            
            return torchGroup;
        }
        
        function addRoomDecorations(roomX, roomZ, roomSize, roomIndex) {
            // Add different decorations based on room type
            if (roomIndex === 0) {
                // Entrance room - add welcome banner
                addBanner(roomX, roomZ, roomSize);
            } else if (roomIndex === 1) {
                // Center hub - add throne or altar
                addThrone(roomX, roomZ);
            } else {
                // Side rooms - add various decorations
                addRandomDecorations(roomX, roomZ, roomSize);
            }
        }
        
        function addBanner(roomX, roomZ, roomSize) {
            const bannerGeometry = new THREE.PlaneGeometry(3, 2);
            const bannerMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000,
                roughness: 0.8,
                metalness: 0.1
            });
            const banner = new THREE.Mesh(bannerGeometry, bannerMaterial);
            banner.position.set(roomX, 4, roomZ - roomSize/2 + 0.5);
            banner.castShadow = true;
            dungeon.add(banner);
        }
        
        function addThrone(roomX, roomZ) {
            const throneGroup = new THREE.Group();
            
            // Throne base
            const baseGeometry = new THREE.BoxGeometry(2, 1, 2);
            const baseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7,
                metalness: 0.2
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.5;
            base.castShadow = true;
            throneGroup.add(base);
            
            // Throne back
            const backGeometry = new THREE.BoxGeometry(2, 3, 0.3);
            const backMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.8,
                metalness: 0.1
            });
            const back = new THREE.Mesh(backGeometry, backMaterial);
            back.position.set(0, 2, -0.85);
            back.castShadow = true;
            throneGroup.add(back);
            
            throneGroup.position.set(roomX, 0, roomZ);
            dungeon.add(throneGroup);
        }
        
        function addRandomDecorations(roomX, roomZ, roomSize) {
            // Add random decorative elements
            const decorations = [
                { type: 'chest', pos: { x: roomX - 2, z: roomZ - 2 } },
                { type: 'barrel', pos: { x: roomX + 2, z: roomZ + 2 } },
                { type: 'crate', pos: { x: roomX - 2, z: roomZ + 2 } }
            ];
            
            decorations.forEach((dec, index) => {
                if (Math.random() > 0.5) {
                    switch(dec.type) {
                        case 'chest':
                            addTreasureChest(dec.pos.x, dec.pos.z);
                            break;
                        case 'barrel':
                            addBarrel(dec.pos.x, dec.pos.z);
                            break;
                        case 'crate':
                            addCrate(dec.pos.x, dec.pos.z);
                            break;
                    }
                }
            });
        }
        
        function addTreasureChest(x, z) {
            const chestGroup = new THREE.Group();
            
            // Chest body
            const bodyGeometry = new THREE.BoxGeometry(1, 0.8, 0.6);
            const bodyMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.4;
            body.castShadow = true;
            chestGroup.add(body);
            
            // Chest lid
            const lidGeometry = new THREE.BoxGeometry(1.1, 0.2, 0.6);
            const lidMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xA0522D
            });
            const lid = new THREE.Mesh(lidGeometry, lidMaterial);
            lid.position.set(0, 0.9, 0);
            lid.castShadow = true;
            chestGroup.add(lid);
            
            // Chest lock
            const lockGeometry = new THREE.BoxGeometry(0.2, 0.3, 0.1);
            const lockMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFD700
            });
            const lock = new THREE.Mesh(lockGeometry, lockMaterial);
            lock.position.set(0, 0.7, 0.35);
            chestGroup.add(lock);
            
            chestGroup.position.set(x, 0, z);
            dungeon.add(chestGroup);
        }
        
        function addBarrel(x, z) {
            const barrelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 8);
            const barrelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.0
            });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.position.set(x, 0.6, z);
            barrel.castShadow = true;
            dungeon.add(barrel);
        }
        
        function addCrate(x, z) {
            const crateGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const crateMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.0
            });
            const crate = new THREE.Mesh(crateGeometry, crateMaterial);
            crate.position.set(x, 0.4, z);
            crate.castShadow = true;
            dungeon.add(crate);
        }
        
        function addAtmosphericParticles() {
            // Disabled particles to prevent texture unit overflow
            console.log('Particles disabled for WebGL compatibility');
        }

        function addDungeonDecorations(dungeonSize) {
            // Add torches on walls (properly attached)
            const wallPositions = [
                { x: 0, z: -dungeonSize + 0.5, rotation: 0 },           // North wall
                { x: 0, z: dungeonSize - 0.5, rotation: Math.PI },       // South wall
                { x: dungeonSize - 0.5, z: 0, rotation: Math.PI / 2 },  // East wall
                { x: -dungeonSize + 0.5, z: 0, rotation: -Math.PI / 2 } // West wall
            ];
            
            wallPositions.forEach((wall, index) => {
                const torch = createTorch();
                torch.position.set(wall.x, 3, wall.z);
                torch.rotation.y = wall.rotation;
                dungeon.add(torch);
            });
            
            // Add some random debris ON THE GROUND
            for (let i = 0; i < 15; i++) {
                const debris = createDebris();
                const debrisX = (Math.random() - 0.5) * dungeonSize * 1.2;
                const debrisZ = (Math.random() - 0.5) * dungeonSize * 1.2;
                
                // Ensure debris is properly on the ground
                debris.position.set(debrisX, 0.02, debrisZ);
                
                // Ensure debris stays on ground
                debris.position.y = 0.02;
                
                dungeon.add(debris);
            }
        }

        function createTorch() {
            const torchGroup = new THREE.Group();
            
            // Torch handle
            const handle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.8, 6),
                new THREE.MeshLambertMaterial({ color: 0x8B4513 })
            );
            handle.position.y = 0.4;
            torchGroup.add(handle);
            
            // Torch flame
            const flame = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 6, 6),
                new THREE.MeshLambertMaterial({ color: 0xFF6600, emissive: 0xFF3300 })
            );
            flame.position.y = 0.9;
            torchGroup.add(flame);
            
            // Add point light
            const torchLight = new THREE.PointLight(0xFF6600, 0.8, 8);
            torchLight.position.y = 0.9;
            torchGroup.add(torchLight);
            
            return torchGroup;
        }

        function createDebris() {
            const debrisTypes = ['rock', 'bone', 'wood'];
            const debrisType = debrisTypes[Math.floor(Math.random() * debrisTypes.length)];
            
            let geometry, material;
            
            switch(debrisType) {
                case 'rock':
                    geometry = new THREE.DodecahedronGeometry(0.3 + Math.random() * 0.4);
                    material = new THREE.MeshLambertMaterial({ color: 0x696969 });
                    break;
                case 'bone':
                    geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 4);
                    material = new THREE.MeshLambertMaterial({ color: 0xF5F5DC });
                    break;
                case 'wood':
                    geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 4);
                    material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    break;
            }
            
            const debris = new THREE.Mesh(geometry, material);
            debris.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            debris.castShadow = true;
            
            return debris;
        }

        function spawnMonsters(dungeonSize) {
            const monsterCount = 3 + Math.floor(gameState.currentLevel / 2);
            
            for (let i = 0; i < monsterCount; i++) {
                const monster = createMonster();
                
                // Spawn monsters in accessible areas (avoid center room initially)
                let spawnX, spawnZ;
                let attempts = 0;
                do {
                    // Avoid center room (0,0) for initial spawns
                    if (i === 0) {
                        // First monster spawns in a side room or corridor
                        const spawnAreas = [
                            { x: -16, z: 0, radius: 4 },    // Left room
                            { x: 16, z: 0, radius: 4 },     // Right room
                            { x: 0, z: -16, radius: 4 },    // Back room
                            { x: 0, z: 16, radius: 4 },     // Front room
                            { x: -8, z: 0, radius: 2 },     // West corridor
                            { x: 8, z: 0, radius: 2 },      // East corridor
                            { x: 0, z: -8, radius: 2 },     // North corridor
                            { x: 0, z: 8, radius: 2 }       // South corridor
                        ];
                        
                        const spawnArea = spawnAreas[Math.floor(Math.random() * spawnAreas.length)];
                        spawnX = spawnArea.x + (Math.random() - 0.5) * spawnArea.radius;
                        spawnZ = spawnArea.z + (Math.random() - 0.5) * spawnArea.radius;
                    } else {
                        // Other monsters can spawn anywhere
                        spawnX = (Math.random() - 0.5) * (dungeonSize * 1.2);
                        spawnZ = (Math.random() - 0.5) * (dungeonSize * 1.2);
                    }
                    
                    attempts++;
                } while (checkCollision({x: spawnX, y: 1, z: spawnZ}) && attempts < 50);
                
                // Ensure monsters spawn ON THE GROUND, not floating
                monster.position.set(spawnX, 0.5, spawnZ);
                monster.userData.originalPosition.set(spawnX, 0.5, spawnZ);
                
                // Ensure monster stays on ground
                monster.position.y = 0.5;
                
                monsters.push(monster);
                dungeon.add(monster);
            }
        }
        
        function createExitPortal(dungeonSize) {
            // Create a wall-mounted glowing portal to exit the dungeon
            const portalGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 8);
            const portalMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x00ffff, 
                emissive: 0x008080,
                transparent: true,
                opacity: 0.8
            });
            
            const portal = new THREE.Mesh(portalGeometry, portalMaterial);
            // Mount on north wall at eye level
            portal.position.set(0, 1.7, -dungeonSize + 1);
            portal.rotation.x = Math.PI / 2; // Rotate to face player
            portal.userData = { type: 'exit' };
            portal.castShadow = true;
            
            // Add portal light
            const portalLight = new THREE.PointLight(0x00ffff, 1, 10);
            portalLight.position.copy(portal.position);
            portalLight.position.y = 2;
            portal.add(portalLight);
            
            dungeon.add(portal);
            
            // Add deeper dungeon portal if not at max level
            if (gameState.currentLevel < 10) {
                createDeeperPortal(dungeonSize);
            }
        }
        
        function createDeeperPortal(dungeonSize) {
            // Create a wall-mounted portal to go deeper into the dungeon
            const deeperPortalGeometry = new THREE.CylinderGeometry(1.2, 1.2, 0.2, 8);
            const deeperPortalMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFF4500, 
                emissive: 0x8B0000,
                transparent: true,
                opacity: 0.9
            });
            
            const deeperPortal = new THREE.Mesh(deeperPortalGeometry, deeperPortalMaterial);
            // Mount on south wall at eye level
            deeperPortal.position.set(0, 1.7, dungeonSize - 1);
            deeperPortal.rotation.x = -Math.PI / 2; // Rotate to face player
            deeperPortal.userData = { type: 'deeper' };
            deeperPortal.castShadow = true;
            
            // Add portal light
            const deeperPortalLight = new THREE.PointLight(0xFF4500, 1.2, 12);
            deeperPortalLight.position.copy(deeperPortal.position);
            deeperPortalLight.position.y = 2;
            deeperPortal.add(deeperPortalLight);
            
            dungeon.add(deeperPortal);
        }
        
        function createPlayerWeapon() {
            // Create weapons based on player class
            switch(selectedClass) {
                case 'warrior':
                    return createWarriorSword();
                case 'mage':
                    return createMageStaff();
                case 'rogue':
                    return createRogueDaggers();
                default:
                    return createWarriorSword();
            }
        }
        
        function createWarriorSword() {
            // Create a fantasy sword for the warrior
            const swordGroup = new THREE.Group();
            
            // Sword blade (silver with blue tint) - Much larger and visible
            const bladeGeometry = new THREE.BoxGeometry(0.25, 2.0, 0.1);
            const bladeMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xC0C0C0,
                emissive: 0x001122
            });
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.position.y = 1.0;
            swordGroup.add(blade);
            
            // Sword guard (golden) - Much more prominent
            const guardGeometry = new THREE.BoxGeometry(0.6, 0.2, 0.15);
            const guardMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFD700,
                emissive: 0x332200
            });
            const guard = new THREE.Mesh(guardGeometry, guardMaterial);
            guard.position.y = 0.15;
            swordGroup.add(guard);
            
            // Sword handle (leather wrapped) - Longer and thicker
            const handleGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.7, 8);
            const handleMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.y = -0.15;
            swordGroup.add(handle);
            
            // Sword pommel (gem-like) - Much larger
            const pommelGeometry = new THREE.OctahedronGeometry(0.1);
            const pommelMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4169E1,
                emissive: 0x001122
            });
            const pommel = new THREE.Mesh(pommelGeometry, pommelMaterial);
            pommel.position.y = -0.45;
            swordGroup.add(pommel);
            
            // Position sword in player's right hand (camera view) - Much more visible
            swordGroup.position.set(0.5, -0.1, -0.5);
            swordGroup.rotation.set(0, 0, Math.PI / 6);
            
            // Add to camera so it moves with player
            camera.add(swordGroup);
            
            // Store reference for potential animations
            gameState.playerWeapon = swordGroup;
            
            // Initialize sword animation state
            swordGroup.userData = {
                isSlashing: false,
                slashDirection: 1, // 1 for right, -1 for left
                slashProgress: 0,
                originalPosition: swordGroup.position.clone(),
                originalRotation: swordGroup.rotation.clone()
            };
            
            console.log('Enhanced sword created and added to camera at position:', swordGroup.position);
        }
        
        function createMageStaff() {
            // Create a magical staff for the mage
            const staffGroup = new THREE.Group();
            
            // Staff shaft (wooden with magical runes)
            const shaftGeometry = new THREE.CylinderGeometry(0.04, 0.04, 1.8, 8);
            const shaftMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513,
                emissive: 0x1A1A1A
            });
            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
            shaft.position.y = 0.9;
            staffGroup.add(shaft);
            
            // Staff orb (glowing magical crystal)
            const orbGeometry = new THREE.SphereGeometry(0.15, 8, 6);
            const orbMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4169E1,
                emissive: 0x001122
            });
            const orb = new THREE.Mesh(orbGeometry, orbMaterial);
            orb.position.y = 1.8;
            staffGroup.add(orb);
            
            // Staff base (ornate metal cap)
            const baseGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.2, 8);
            const baseMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFD700
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = -0.1;
            staffGroup.add(base);
            
            // Position staff in player's right hand
            staffGroup.position.set(0.5, -0.1, -0.5);
            staffGroup.rotation.set(0, 0, Math.PI / 6);
            
            // Add to camera
            camera.add(staffGroup);
            
            // Store reference and initialize animation state
            gameState.playerWeapon = staffGroup;
            staffGroup.userData = {
                isCasting: false,
                castProgress: 0,
                originalPosition: staffGroup.position.clone(),
                originalRotation: staffGroup.rotation.clone()
            };
            
            console.log('Mage staff created and added to camera');
            return staffGroup;
        }
        
        function createRogueDaggers() {
            // Create dual daggers for the rogue
            const daggerGroup = new THREE.Group();
            
            // Right dagger
            const rightDagger = new THREE.Group();
            const bladeGeometry = new THREE.BoxGeometry(0.08, 0.6, 0.02);
            const bladeMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xC0C0C0,
                emissive: 0x001122
            });
            const rightBlade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            rightBlade.position.y = 0.3;
            rightDagger.add(rightBlade);
            
            const handleGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 6);
            const handleMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513
            });
            const rightHandle = new THREE.Mesh(handleGeometry, handleMaterial);
            rightHandle.position.y = -0.1;
            rightDagger.add(rightHandle);
            
            rightDagger.position.set(0.4, 0, -0.3);
            rightDagger.rotation.set(0, 0, Math.PI / 6);
            daggerGroup.add(rightDagger);
            
            // Left dagger
            const leftDagger = new THREE.Group();
            const leftBlade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            leftBlade.position.y = 0.3;
            leftDagger.add(leftBlade);
            
            const leftHandle = new THREE.Mesh(handleGeometry, handleMaterial);
            leftHandle.position.y = -0.1;
            leftDagger.add(leftHandle);
            
            leftDagger.position.set(0.6, 0, -0.3);
            leftDagger.rotation.set(0, 0, -Math.PI / 6);
            daggerGroup.add(leftDagger);
            
            // Position dagger group in player's hands
            daggerGroup.position.set(0.5, -0.1, -0.5);
            
            // Add to camera
            camera.add(daggerGroup);
            
            // Store reference and initialize animation state
            gameState.playerWeapon = daggerGroup;
            daggerGroup.userData = {
                isThrowing: false,
                throwProgress: 0,
                originalPosition: daggerGroup.position.clone(),
                originalRotation: daggerGroup.rotation.clone()
            };
            
            console.log('Rogue daggers created and added to camera');
            return daggerGroup;
        }
        
        function triggerSwordSlash() {
            if (!gameState.playerWeapon || !gameState.playerWeapon.userData) return;
            
            const sword = gameState.playerWeapon;
            const swordData = sword.userData;
            
            // Start slashing animation
            swordData.isSlashing = true;
            swordData.slashProgress = 0;
            swordData.slashDirection *= -1; // Alternate direction
            
            // Store original position and rotation
            if (!swordData.originalPosition) {
                swordData.originalPosition = sword.position.clone();
                swordData.originalRotation = sword.rotation.clone();
            }
            
            console.log('Sword slash triggered!');
        }
        
        function updateSwordAnimation() {
            if (!gameState.playerWeapon || !gameState.playerWeapon.userData) return;
            
            const sword = gameState.playerWeapon;
            const swordData = sword.userData;
            
            if (swordData.isSlashing) {
                swordData.slashProgress += 0.15; // Animation speed
                
                if (swordData.slashProgress >= 1) {
                    // Animation complete, reset to original position
                    swordData.isSlashing = false;
                    swordData.slashProgress = 0;
                    sword.position.copy(swordData.originalPosition);
                    sword.rotation.copy(swordData.originalRotation);
                } else {
                    // Animate the slash
                    const progress = swordData.slashProgress;
                    const easeProgress = Math.sin(progress * Math.PI); // Smooth easing
                    
                    // Horizontal slash movement
                    const slashDistance = 0.4;
                    const slashAngle = Math.PI / 3;
                    
                    if (swordData.slashDirection === 1) {
                        // Slash right
                        sword.position.x = swordData.originalPosition.x + (slashDistance * easeProgress);
                        sword.rotation.z = swordData.originalRotation.z + (slashAngle * easeProgress);
                    } else {
                        // Slash left
                        sword.position.x = swordData.originalPosition.x - (slashDistance * easeProgress);
                        sword.rotation.z = swordData.originalRotation.z - (slashAngle * easeProgress);
                    }
                    
                    // Add some vertical movement for dramatic effect
                    sword.position.y = swordData.originalPosition.y + (Math.sin(progress * Math.PI) * 0.1);
                }
            }
        }

        function createMonster() {
            const monsterTypes = ['goblin', 'orc', 'troll', 'dragon', 'skeleton', 'zombie', 'rat'];
            const monsterType = monsterTypes[Math.floor(Math.random() * monsterTypes.length)];
            
            let monsterGeometry, monsterMaterial, monsterData;
            
            switch(monsterType) {
                case 'goblin':
                    // Create goblin with multiple parts and textures
                    const goblinGroup = new THREE.Group();
                    
                    // Body (wider, more detailed with texture)
                    const goblinBody = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.35, 0.9, 8),
                        new THREE.MeshLambertMaterial({ 
                            color: 0x228B22,
                            emissive: 0x0A3A0A
                        })
                    );
                    goblinBody.position.y = 0.45;
                    goblinGroup.add(goblinBody);
                    
                    // Head (larger, more detailed with texture)
                    const goblinHead = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3, 8, 6),
                        new THREE.MeshLambertMaterial({ 
                            color: 0xFFE4B5,
                            emissive: 0x1A1A1A
                        })
                    );
                    goblinHead.position.y = 1.15;
                    goblinGroup.add(goblinHead);
                    
                    // Eyes (larger, more menacing with glow)
                    const goblinEye1 = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 6, 6),
                        new THREE.MeshLambertMaterial({ 
                            color: 0xFF0000,
                            emissive: 0x660000
                        })
                    );
                    goblinEye1.position.set(-0.12, 1.2, 0.25);
                    goblinGroup.add(goblinEye1);
                    
                    const goblinEye2 = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 6, 6),
                        new THREE.MeshLambertMaterial({ 
                            color: 0xFF0000,
                            emissive: 0x660000
                        })
                    );
                    goblinEye2.position.set(0.12, 1.2, 0.25);
                    goblinGroup.add(goblinEye2);
                    
                    // Arms (more detailed with joints)
                    const goblinArm1 = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.12, 0.1, 0.6, 6),
                        new THREE.MeshLambertMaterial({ 
                            color: 0xFFE4B5
                        })
                    );
                    goblinArm1.position.set(-0.5, 0.4, 0);
                    goblinArm1.rotation.z = Math.PI / 6;
                    goblinGroup.add(goblinArm1);
                    
                    const goblinArm2 = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.12, 0.1, 0.6, 6),
                        new THREE.MeshLambertMaterial({ 
                            color: 0xFFE4B5
                        })
                    );
                    goblinArm2.position.set(0.5, 0.4, 0);
                    goblinArm2.rotation.z = -Math.PI / 6;
                    goblinGroup.add(goblinArm2);
                    
                    // Legs (new addition)
                    const goblinLeg1 = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.12, 0.7, 6),
                        new THREE.MeshLambertMaterial({ 
                            color: 0x228B22
                        })
                    );
                    goblinLeg1.position.set(-0.2, -0.2, 0);
                    goblinGroup.add(goblinLeg1);
                    
                    const goblinLeg2 = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.12, 0.7, 6),
                        new THREE.MeshLambertMaterial({ 
                            color: 0x228B22
                        })
                    );
                    goblinLeg2.position.set(0.2, -0.2, 0);
                    goblinGroup.add(goblinLeg2);
                    
                    // Weapon (more detailed with texture)
                    const goblinWeapon = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 0.9, 6),
                        new THREE.MeshLambertMaterial({ 
                            color: 0x696969,
                            emissive: 0x1A1A1A
                        })
                    );
                    goblinWeapon.position.set(0.6, 0.2, 0);
                    goblinWeapon.rotation.z = Math.PI / 4;
                    goblinGroup.add(goblinWeapon);
                    
                    // Weapon blade
                    const weaponBlade = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.4, 0.02),
                        new THREE.MeshLambertMaterial({ 
                            color: 0xC0C0C0,
                            emissive: 0x1A1A1A
                        })
                    );
                    weaponBlade.position.set(0.6, 0.4, 0);
                    goblinGroup.add(weaponBlade);
                    
                    // Add animation data
                    monsterData = {
                        health: 25 + gameState.currentLevel * 5,
                        damage: 5 + gameState.currentLevel * 2,
                        speed: 0.02,
                        type: 'goblin',
                        lastAttack: 0,
                        aggroRange: 8,
                        isAggro: false,
                        originalPosition: new THREE.Vector3(),
                        patrolRadius: 3,
                        // Animation properties
                        animationTime: 0,
                        walkCycle: 0,
                        attackCycle: 0,
                        idleCycle: 0
                    };
                    
                    goblinGroup.userData = monsterData;
                    goblinGroup.castShadow = true;
                    return goblinGroup;
                    
                case 'orc':
                    const orcGroup = new THREE.Group();
                    
                    // Body
                    const orcBody = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.4, 1.0, 8),
                        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                    );
                    orcBody.position.y = 0.5;
                    orcGroup.add(orcBody);
                    
                    // Head
                    const orcHead = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3, 8, 6),
                        new THREE.MeshLambertMaterial({ color: 0xFFE4B5 })
                    );
                    orcHead.position.y = 1.3;
                    orcGroup.add(orcHead);
                    
                    // Tusks
                    const orcTusk1 = new THREE.Mesh(
                        new THREE.ConeGeometry(0.05, 0.2, 4),
                        new THREE.MeshLambertMaterial({ color: 0xF5F5DC })
                    );
                    orcTusk1.position.set(-0.15, 1.1, 0.25);
                    orcTusk1.rotation.x = Math.PI / 6;
                    orcGroup.add(orcTusk1);
                    
                    const orcTusk2 = new THREE.Mesh(
                        new THREE.ConeGeometry(0.05, 0.2, 4),
                        new THREE.MeshLambertMaterial({ color: 0xF5F5DC })
                    );
                    orcTusk2.position.set(0.15, 1.1, 0.25);
                    orcTusk2.rotation.x = Math.PI / 6;
                    orcGroup.add(orcTusk2);
                    
                    // Axe
                    const orcAxe = new THREE.Mesh(
                        new THREE.BoxGeometry(0.1, 0.8, 0.05),
                        new THREE.MeshLambertMaterial({ color: 0x696969 })
                    );
                    orcAxe.position.set(0.6, 0.2, 0);
                    orcAxe.rotation.z = Math.PI / 6;
                    orcGroup.add(orcAxe);
                    
                    monsterData = {
                        health: 50 + gameState.currentLevel * 8,
                        damage: 8 + gameState.currentLevel * 2,
                        speed: 0.015,
                        type: 'orc',
                        lastAttack: 0,
                        aggroRange: 10,
                        isAggro: false,
                        originalPosition: new THREE.Vector3(),
                        patrolRadius: 4
                    };
                    
                    orcGroup.userData = monsterData;
                    orcGroup.castShadow = true;
                    return orcGroup;
                    
                case 'skeleton':
                    const skeletonGroup = new THREE.Group();
                    
                    // Body
                    const skeletonBody = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.25, 0.25, 0.9, 8),
                        new THREE.MeshLambertMaterial({ color: 0xF5F5DC })
                    );
                    skeletonBody.position.y = 0.45;
                    skeletonGroup.add(skeletonBody);
                    
                    // Head
                    const skeletonHead = new THREE.Mesh(
                        new THREE.SphereGeometry(0.2, 8, 6),
                        new THREE.MeshLambertMaterial({ color: 0xF5F5DC })
                    );
                    skeletonHead.position.y = 1.05;
                    skeletonGroup.add(skeletonHead);
                    
                    // Eye sockets
                    const skeletonEye1 = new THREE.Mesh(
                        new THREE.SphereGeometry(0.04, 4, 4),
                        new THREE.MeshLambertMaterial({ color: 0x000000 })
                    );
                    skeletonEye1.position.set(-0.08, 1.05, 0.15);
                    skeletonGroup.add(skeletonEye1);
                    
                    const skeletonEye2 = new THREE.Mesh(
                        new THREE.SphereGeometry(0.04, 4, 4),
                        new THREE.MeshLambertMaterial({ color: 0x000000 })
                    );
                    skeletonEye2.position.set(0.08, 1.05, 0.15);
                    skeletonGroup.add(skeletonEye2);
                    
                    // Sword
                    const skeletonSword = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05, 0.9, 0.05),
                        new THREE.MeshLambertMaterial({ color: 0xC0C0C0 })
                    );
                    skeletonSword.position.set(0.4, 0.1, 0);
                    skeletonGroup.add(skeletonSword);
                    
                    monsterData = {
                        health: 35 + gameState.currentLevel * 6,
                        damage: 6 + gameState.currentLevel * 2,
                        speed: 0.025,
                        type: 'skeleton',
                        lastAttack: 0,
                        aggroRange: 7,
                        isAggro: false,
                        originalPosition: new THREE.Vector3(),
                        patrolRadius: 2.5
                    };
                    
                    skeletonGroup.userData = monsterData;
                    skeletonGroup.castShadow = true;
                    return skeletonGroup;
                    
                case 'zombie':
                    const zombieGroup = new THREE.Group();
                    
                    // Body
                    const zombieBody = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.35, 0.35, 0.9, 8),
                        new THREE.MeshLambertMaterial({ color: 0x556B2F })
                    );
                    zombieBody.position.y = 0.45;
                    zombieGroup.add(zombieBody);
                    
                    // Head
                    const zombieHead = new THREE.Mesh(
                        new THREE.SphereGeometry(0.25, 8, 6),
                        new THREE.MeshLambertMaterial({ color: 0x8FBC8F })
                    );
                    zombieHead.position.y = 1.05;
                    zombieGroup.add(zombieHead);
                    
                    // Arms
                    const zombieArm1 = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.1, 0.6, 4),
                        new THREE.MeshLambertMaterial({ color: 0x556B2F })
                    );
                    zombieArm1.position.set(-0.4, 0.3, 0);
                    zombieArm1.rotation.z = Math.PI / 6;
                    zombieGroup.add(zombieArm1);
                    
                    const zombieArm2 = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.1, 0.6, 4),
                        new THREE.MeshLambertMaterial({ color: 0x556B2F })
                    );
                    zombieArm2.position.set(0.4, 0.3, 0);
                    zombieArm2.rotation.z = -Math.PI / 6;
                    zombieGroup.add(zombieArm2);
                    
                    monsterData = {
                        health: 45 + gameState.currentLevel * 7,
                        damage: 7 + gameState.currentLevel * 2,
                        speed: 0.018,
                        type: 'zombie',
                        lastAttack: 0,
                        aggroRange: 6,
                        isAggro: false,
                        originalPosition: new THREE.Vector3(),
                        patrolRadius: 2
                    };
                    
                    zombieGroup.userData = monsterData;
                    zombieGroup.castShadow = true;
                    return zombieGroup;
                    
                case 'troll':
                    const trollGroup = new THREE.Group();
                    
                    // Body
                    const trollBody = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.5, 1.2, 8),
                        new THREE.MeshLambertMaterial({ color: 0x228B22 })
                    );
                    trollBody.position.y = 0.6;
                    trollGroup.add(trollBody);
                    
                    // Head
                    const trollHead = new THREE.Mesh(
                        new THREE.SphereGeometry(0.35, 8, 6),
                        new THREE.MeshLambertMaterial({ color: 0x228B22 })
                    );
                    trollHead.position.y = 1.4;
                    trollGroup.add(trollHead);
                    
                    // Club
                    const trollClub = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.08, 0.15, 1.2, 6),
                        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                    );
                    trollClub.position.set(0.8, 0.1, 0);
                    trollClub.rotation.z = Math.PI / 8;
                    trollGroup.add(trollClub);
                    
                    monsterData = {
                        health: 80 + gameState.currentLevel * 12,
                        damage: 12 + gameState.currentLevel * 3,
                        speed: 0.012,
                        type: 'troll',
                        lastAttack: 0,
                        aggroRange: 12,
                        isAggro: false,
                        originalPosition: new THREE.Vector3(),
                        patrolRadius: 5
                    };
                    
                    trollGroup.userData = monsterData;
                    trollGroup.castShadow = true;
                    return trollGroup;
                    
                case 'dragon':
                    const dragonGroup = new THREE.Group();
                    
                    // Body
                    const dragonBody = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.4, 1.5, 8),
                        new THREE.MeshLambertMaterial({ color: 0x8B0000 })
                    );
                    dragonBody.position.y = 0.75;
                    dragonGroup.add(dragonBody);
                    
                    // Head
                    const dragonHead = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3, 8, 6),
                        new THREE.MeshLambertMaterial({ color: 0x8B0000 })
                    );
                    dragonHead.position.y = 1.5;
                    dragonGroup.add(dragonHead);
                    
                    // Wings
                    const dragonWing1 = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.8, 0.6),
                        new THREE.MeshLambertMaterial({ color: 0xDC143C, side: THREE.DoubleSide })
                    );
                    dragonWing1.position.set(-0.6, 0.8, 0);
                    dragonWing1.rotation.y = Math.PI / 4;
                    dragonGroup.add(dragonWing1);
                    
                    const dragonWing2 = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.8, 0.6),
                        new THREE.MeshLambertMaterial({ color: 0xDC143C, side: THREE.DoubleSide })
                    );
                    dragonWing2.position.set(0.6, 0.8, 0);
                    dragonWing2.rotation.y = -Math.PI / 4;
                    dragonGroup.add(dragonWing2);
                    
                    monsterData = {
                        health: 150 + gameState.currentLevel * 20,
                        damage: 20 + gameState.currentLevel * 5,
                        speed: 0.008,
                        type: 'dragon',
                        lastAttack: 0,
                        aggroRange: 15,
                        isAggro: false,
                        originalPosition: new THREE.Vector3(),
                        patrolRadius: 6
                    };
                    
                    dragonGroup.userData = monsterData;
                    dragonGroup.castShadow = true;
                    return dragonGroup;
                    
                case 'rat':
                    const ratGroup = new THREE.Group();
                    
                    // Body (small and agile)
                    const ratBody = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.2, 0.2, 0.6, 8),
                        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                    );
                    ratBody.position.y = 0.3;
                    ratGroup.add(ratBody);
                    
                    // Head (pointed snout)
                    const ratHead = new THREE.Mesh(
                        new THREE.SphereGeometry(0.18, 8, 6),
                        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                    );
                    ratHead.position.y = 0.75;
                    ratGroup.add(ratHead);
                    
                    // Ears (pointed)
                    const ratEar1 = new THREE.Mesh(
                        new THREE.ConeGeometry(0.05, 0.15, 4),
                        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                    );
                    ratEar1.position.set(-0.08, 0.9, 0.1);
                    ratEar1.rotation.x = -Math.PI / 6;
                    ratGroup.add(ratEar1);
                    
                    const ratEar2 = new THREE.Mesh(
                        new THREE.ConeGeometry(0.05, 0.15, 4),
                        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                    );
                    ratEar2.position.set(0.08, 0.9, 0.1);
                    ratEar2.rotation.x = -Math.PI / 6;
                    ratGroup.add(ratEar2);
                    
                    // Tail (long and thin)
                    const ratTail = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 0.8, 6),
                        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                    );
                    ratTail.position.set(0, 0.2, -0.4);
                    ratTail.rotation.x = Math.PI / 2;
                    ratGroup.add(ratTail);
                    
                    // Eyes (red and menacing)
                    const ratEye1 = new THREE.Mesh(
                        new THREE.SphereGeometry(0.03, 6, 6),
                        new THREE.MeshLambertMaterial({ color: 0xFF0000, emissive: 0x330000 })
                    );
                    ratEye1.position.set(-0.08, 0.78, 0.15);
                    ratGroup.add(ratEye1);
                    
                    const ratEye2 = new THREE.Mesh(
                        new THREE.SphereGeometry(0.03, 6, 6),
                        new THREE.MeshLambertMaterial({ color: 0xFF0000, emissive: 0x330000 })
                    );
                    ratEye2.position.set(0.08, 0.78, 0.15);
                    ratGroup.add(ratEye2);
                    
                    monsterData = {
                        health: 15 + gameState.currentLevel * 3,
                        damage: 3 + gameState.currentLevel * 1,
                        speed: 0.025, // Fast and agile
                        type: 'rat',
                        lastAttack: 0,
                        aggroRange: 5,
                        isAggro: false,
                        originalPosition: new THREE.Vector3(),
                        patrolRadius: 4
                    };
                    
                    ratGroup.userData = monsterData;
                    ratGroup.castShadow = true;
                    return ratGroup;
            }
        }

        function spawnItems(dungeonSize) {
            const itemCount = 2 + Math.floor(gameState.currentLevel / 3);
            
            for (let i = 0; i < itemCount; i++) {
                const item = createItem();
                
                // Spawn items in accessible areas
                let spawnX, spawnZ;
                let attempts = 0;
                do {
                    spawnX = (Math.random() - 0.5) * (dungeonSize * 1.2);
                    spawnZ = (Math.random() - 0.5) * (dungeonSize * 1.2);
                    attempts++;
                } while (checkCollision({x: spawnX, y: 0.5, z: spawnZ}) && attempts < 50);
                
                // Spawn items ON THE GROUND, not floating
                item.position.set(spawnX, 0.05, spawnZ);
                
                // Ensure item stays on ground
                item.position.y = 0.05;
                
                items.push(item);
                dungeon.add(item);
            }
        }

        function createItem() {
            const itemTypes = ['healthPotion', 'manaPotion', 'weapon', 'armor', 'treasure'];
            const itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
            
            let itemGeometry, itemMaterial;
            
            switch(itemType) {
                case 'healthPotion':
                    itemGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                    itemMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                    break;
                case 'manaPotion':
                    itemGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                    itemMaterial = new THREE.MeshLambertMaterial({ color: 0x0000FF });
                    break;
                case 'weapon':
                    itemGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.1);
                    itemMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    break;
                case 'armor':
                    itemGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.2);
                    itemMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
                    break;
                case 'treasure':
                    itemGeometry = new THREE.OctahedronGeometry(0.4);
                    itemMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                    break;
            }
            
            const item = new THREE.Mesh(itemGeometry, itemMaterial);
            item.userData = { type: itemType, value: Math.floor(Math.random() * 100) + 50 };
            item.castShadow = true;
            
            return item;
        }

        function upgradeCamp() {
            if (gameState.campLevel < 5) {
                gameState.campLevel++;
                alert(`Camp upgraded to level ${gameState.campLevel}!`);
                
                // Recreate camp with new features
                scene.remove(camp);
                createCamp();
                scene.add(camp);
            } else {
                alert('Camp is already at maximum level!');
            }
        }

        function visitMerchant() {
            if (gameState.merchantAvailable) {
                showMerchantInterface();
            } else {
                alert('Merchant is not available right now. They visit every other run.');
            }
        }

        function showMerchantInterface() {
            const merchantItems = generateMerchantItems();
            let merchantHTML = '<h3>Merchant Shop</h3>';
            merchantHTML += `<p>Your Gold: ${gameState.gold}</p>`;
            
            merchantItems.forEach((item, index) => {
                merchantHTML += `
                    <div class="inventoryItem">
                        <strong>${item.name}</strong> - ${item.description}
                        <br>Cost: ${item.cost} Gold
                        <button onclick="buyItem(${index})" style="margin-left: 10px;">Buy</button>
                    </div>
                `;
            });
            
            merchantHTML += '<button class="menuButton" onclick="closeMerchant()">Close</button>';
            
            const merchantPanel = document.createElement('div');
            merchantPanel.id = 'merchantPanel';
            merchantPanel.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.95);
                padding: 20px;
                border-radius: 15px;
                border: 2px solid #e94560;
                max-width: 500px;
                max-height: 600px;
                overflow-y: auto;
                z-index: 400;
            `;
            merchantPanel.innerHTML = merchantHTML;
            
            document.body.appendChild(merchantPanel);
        }

        function generateMerchantItems() {
            const items = [
                { name: 'Health Potion', description: 'Restores 50 HP', cost: 25, type: 'consumable', effect: 'health', value: 50 },
                { name: 'Mana Potion', description: 'Restores 50 Mana', cost: 30, type: 'consumable', effect: 'mana', value: 50 },
                { name: 'Iron Sword', description: '+10 Attack Power', cost: 100, type: 'weapon', effect: 'attackPower', value: 10 },
                { name: 'Leather Armor', description: '+5 Defense', cost: 80, type: 'armor', effect: 'defense', value: 5 },
                { name: 'Ring of Strength', description: '+3 Strength', cost: 150, type: 'accessory', effect: 'strength', value: 3 },
                { name: 'Scroll of Knowledge', description: '+2 Intelligence', cost: 120, type: 'accessory', effect: 'intelligence', value: 2 }
            ];
            
            return items;
        }

        function buyItem(itemIndex) {
            const merchantItems = generateMerchantItems();
            const item = merchantItems[itemIndex];
            
            if (gameState.gold >= item.cost) {
                gameState.gold -= item.cost;
                gameState.inventory.push(item);
                
                showMessage(`Purchased ${item.name}!`);
                updateInventoryDisplay();
                
                // Close merchant and reopen to refresh gold display
                closeMerchant();
                showMerchantInterface();
            } else {
                alert('Not enough gold!');
            }
        }

        function closeMerchant() {
            const merchantPanel = document.getElementById('merchantPanel');
            if (merchantPanel) {
                merchantPanel.remove();
            }
        }

        function rest() {
            playerStats.health = playerStats.maxHealth;
            playerStats.mana = playerStats.maxMana;
            playerStats.stamina = playerStats.maxStamina;
            updateHUD();
            alert('You feel refreshed after resting!');
        }

        function toggleSkillTree() {
            const skillTree = document.getElementById('skillTree');
            skillTree.style.display = skillTree.style.display === 'none' ? 'block' : 'none';
            if (skillTree.style.display === 'block') {
                updateSkillTreeDisplay();
            }
        }

        function updateSkillTreeDisplay() {
            const skillNodes = document.getElementById('skillNodes');
            skillNodes.innerHTML = '';
            
            const classSkills = skillTree[selectedClass];
            if (!classSkills) return;
            
            Object.entries(classSkills).forEach(([skillId, skill]) => {
                const node = document.createElement('div');
                node.className = 'skillNode';
                node.id = `skill-${skillId}`;
                
                // Check if skill is available
                const canUnlock = canUnlockSkill(skillId);
                const isUnlocked = gameState.unlockedSkills.includes(skillId);
                
                if (isUnlocked) {
                    node.classList.add('unlocked');
                } else if (canUnlock) {
                    node.classList.add('available');
                }
                
                node.innerHTML = `
                    <div style="font-size: 12px; text-align: center; color: white;">
                        ${skill.name}<br>
                        Cost: ${skill.cost}
                    </div>
                `;
                
                if (canUnlock && !isUnlocked) {
                    node.onclick = () => unlockSkill(skillId);
                }
                
                skillNodes.appendChild(node);
            });
        }

        function canUnlockSkill(skillId) {
            const skill = skillTree[selectedClass][skillId];
            if (!skill) return false;
            
            // Check if player has enough skill points
            if (gameState.skillPoints < skill.cost) return false;
            
            // Check prerequisites
            for (const prereq of skill.prereq) {
                if (!gameState.unlockedSkills.includes(prereq)) {
                    return false;
                }
            }
            
            return true;
        }

        function unlockSkill(skillId) {
            const skill = skillTree[selectedClass][skillId];
            if (!skill) return;
            
            if (gameState.skillPoints >= skill.cost) {
                gameState.skillPoints -= skill.cost;
                gameState.unlockedSkills.push(skillId);
                
                // Apply skill effect
                applySkillEffect(skill);
                
                showMessage(`Skill unlocked: ${skill.name}!`);
                updateSkillTreeDisplay();
                updateHUD();
            }
        }

        function applySkillEffect(skill) {
            switch(skill.effect) {
                case 'strength':
                    playerStats.strength += skill.value;
                    playerStats.attackPower += skill.value;
                    break;
                case 'defense':
                    playerStats.defense += skill.value;
                    break;
                case 'attackPower':
                    playerStats.attackPower += skill.value;
                    break;
                case 'maxHealth':
                    playerStats.maxHealth += skill.value;
                    playerStats.health += skill.value;
                    break;
                case 'maxMana':
                    playerStats.maxMana += skill.value;
                    playerStats.mana += skill.value;
                    break;
                case 'intelligence':
                    playerStats.intelligence += skill.value;
                    break;
                case 'agility':
                    playerStats.agility += skill.value;
                    break;
                case 'criticalChance':
                    playerStats.criticalChance += skill.value;
                    break;
                case 'dodgeChance':
                    playerStats.dodgeChance += skill.value;
                    break;
            }
        }

        function toggleInventory() {
            const inventory = document.getElementById('inventory');
            inventory.style.display = inventory.style.display === 'none' ? 'block' : 'none';
            updateInventoryDisplay();
        }

        function updateInventoryDisplay() {
            const inventoryItems = document.getElementById('inventoryItems');
            if (!inventoryItems) return;
            
            inventoryItems.innerHTML = '';
            
            if (gameState.inventory.length === 0) {
                inventoryItems.innerHTML = '<p style="color: #888; text-align: center;">Inventory is empty</p>';
                return;
            }
            
            gameState.inventory.forEach((item, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'inventoryItem';
                itemDiv.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 8px;
                    margin: 4px 0;
                    background: rgba(0, 0, 0, 0.7);
                    border: 1px solid #FFD700;
                    border-radius: 5px;
                    color: white;
                    cursor: pointer;
                `;
                itemDiv.innerHTML = `
                    <span style="font-weight: bold;">${item.name}</span>
                    <span style="color: #FFD700;">${item.value} gold</span>
                    <button onclick="useItem(${index})" style="background: #4169E1; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">Use</button>
                `;
                itemDiv.onclick = () => useItem(index);
                inventoryItems.appendChild(itemDiv);
            });
        }

        function useItem(index) {
            const item = gameState.inventory[index];
            // TODO: Implement item usage logic
            alert(`Used ${item.name}!`);
            gameState.inventory.splice(index, 1);
            updateInventoryDisplay();
        }

        function updateHUD() {
            // Update original HUD elements
            const healthBar = document.getElementById('healthBar');
            const manaBar = document.getElementById('manaBar');
            const staminaBar = document.getElementById('staminaBar');
            
            if (healthBar) healthBar.style.width = (playerStats.health / playerStats.maxHealth * 100) + '%';
            if (manaBar) manaBar.style.width = (playerStats.mana / playerStats.maxMana * 100) + '%';
            if (staminaBar) staminaBar.style.width = (playerStats.stamina / playerStats.maxStamina * 100) + '%';
            
            const playerLevel = document.getElementById('playerLevel');
            if (playerLevel) playerLevel.textContent = playerStats.level;
            
            const playerXP = document.getElementById('playerXP');
            if (playerXP) playerXP.textContent = playerStats.xp;
            
            const nextLevelXP = document.getElementById('nextLevelXP');
            if (nextLevelXP) nextLevelXP.textContent = playerStats.nextLevelXP;
            
            const dungeonDepth = document.getElementById('dungeonDepth');
            if (dungeonDepth) dungeonDepth.textContent = gameState.currentLevel;
            
            // Update Skyrim-style HUD elements
            const skyrimHealthFill = document.getElementById('skyrimHealthFill');
            const skyrimManaFill = document.getElementById('skyrimManaFill');
            const skyrimStaminaFill = document.getElementById('skyrimStaminaFill');
            const skyrimXPFill = document.getElementById('skyrimXPFill');
            
            if (skyrimHealthFill) skyrimHealthFill.style.width = (playerStats.health / playerStats.maxHealth * 100) + '%';
            if (skyrimManaFill) skyrimManaFill.style.width = (playerStats.mana / playerStats.maxMana * 100) + '%';
            if (skyrimStaminaFill) skyrimStaminaFill.style.width = (playerStats.stamina / playerStats.maxStamina * 100) + '%';
            if (skyrimXPFill) skyrimXPFill.style.width = (playerStats.xp / playerStats.nextLevelXP * 100) + '%';
            
            // Update additional HUD elements
            const hud = document.getElementById('hud');
            if (hud) {
                // Add gold display
                let goldDisplay = hud.querySelector('#goldDisplay');
                if (!goldDisplay) {
                    goldDisplay = document.createElement('div');
                    goldDisplay.id = 'goldDisplay';
                    goldDisplay.className = 'hudSection';
                    goldDisplay.innerHTML = '<h3>Gold: <span id="goldAmount">' + gameState.gold + '</span></h3>';
                    hud.appendChild(goldDisplay);
                } else {
                    goldDisplay.querySelector('#goldAmount').textContent = gameState.gold;
                }
                
                // Add skill points display
                let skillPointsDisplay = hud.querySelector('#skillPointsDisplay');
                if (!skillPointsDisplay) {
                    skillPointsDisplay = document.createElement('div');
                    skillPointsDisplay.id = 'skillPointsDisplay';
                    skillPointsDisplay.className = 'hudSection';
                    skillPointsDisplay.innerHTML = '<h3>Skill Points: <span id="skillPointsAmount">' + gameState.gold + '</span></h3>';
                    hud.appendChild(skillPointsDisplay);
                } else {
                    skillPointsDisplay.querySelector('#skillPointsAmount').textContent = gameState.skillPoints;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Handle player movement
            if (gameState.currentScene === 'dungeon') {
                handlePlayerMovement();
            }
            
                         // Animate monsters with proper AI (ONLY IN DUNGEON)
             if (gameState.currentScene === 'dungeon') {
                 monsters.forEach(monster => {
                     if (monster.userData.health > 0) {
                         const distanceToPlayer = camera.position.distanceTo(monster.position);
                         const monsterData = monster.userData;
                         
                         // Check if player is in aggro range
                         if (distanceToPlayer <= monsterData.aggroRange) {
                             monsterData.isAggro = true;
                         } else if (distanceToPlayer > monsterData.aggroRange * 1.5) {
                             monsterData.isAggro = false;
                         }
                         
                                                                                                      if (monsterData.isAggro) {
                             // Player is in aggro range - chase and attack
                             const direction = new THREE.Vector3();
                             direction.subVectors(camera.position, monster.position).normalize();
                             
                             if (distanceToPlayer < 2) {
                                 // Close enough to attack
                                 if (Date.now() - monsterData.lastAttack > 1500) {
                                     attackPlayer(monster);
                                     monsterData.lastAttack = Date.now();
                                 }
                             } else {
                                                                     // Move towards player (KEEP ON GROUND)
                                    const newPosition = monster.position.clone().add(direction.multiplyScalar(monsterData.speed));
                                    newPosition.y = 0.5; // Keep monster on ground
                                    
                                    // Check if new position is valid with better collision detection
                                    if (!checkMonsterCollision(newPosition)) {
                                        // Smooth monster movement
                                        monster.position.lerp(newPosition, 0.1);
                                    } else {
                                        // Try to find alternative path around obstacles (with safety check)
                                        try {
                                            const alternativePosition = findAlternativePath(monster.position, direction, monsterData.speed);
                                            if (alternativePosition && !checkMonsterCollision(alternativePosition)) {
                                                monster.position.lerp(alternativePosition, 0.05);
                                            }
                                        } catch (error) {
                                            console.warn('Monster pathfinding error:', error);
                                            // Fallback: stay in place
                                        }
                                    }
                             }
                             
                             // Rotate monster to face player's actual position
                             monster.lookAt(camera.position);
                             
                             // Attack animation
                             monsterData.attackCycle = (monsterData.attackCycle || 0) + 0.2;
                             if (monsterData.attackCycle > Math.PI * 2) monsterData.attackCycle = 0;
                             
                             // Animate weapon during attack
                             const weapon = monster.children.find(child => child.geometry && child.geometry.type === 'CylinderGeometry' && child.position.x > 0.5);
                             if (weapon) {
                                 weapon.rotation.z = Math.PI / 4 + Math.sin(monsterData.attackCycle) * 0.3;
                             }
                             
                             // Show monster health bar when in combat
                             showMonsterHealthBar(monster);
                         } else {
                             // Not aggro - patrol around original position (KEEP ON GROUND)
                             const patrolDirection = new THREE.Vector3();
                             const currentPos = monster.position.clone();
                             const targetPos = monsterData.originalPosition.clone();
                             
                             // Add some random movement within patrol radius
                             targetPos.x += (Math.random() - 0.5) * monsterData.patrolRadius * 0.5;
                             targetPos.z += (Math.random() - 0.5) * monsterData.patrolRadius * 0.5;
                             
                             patrolDirection.subVectors(targetPos, currentPos).normalize();
                             const newPosition = monster.position.clone().add(patrolDirection.multiplyScalar(monsterData.speed * 0.3));
                             newPosition.y = 0.5; // Keep monster on ground
                             
                                                                 // Check if new position is valid
                                    if (!checkMonsterCollision(newPosition)) {
                                        // Smooth patrol movement
                                        monster.position.lerp(newPosition, 0.05);
                                    } else {
                                        // Try to find alternative path around obstacles (with safety check)
                                        try {
                                            const alternativePosition = findAlternativePath(monster.position, patrolDirection, monsterData.speed * 0.3);
                                            if (alternativePosition && !checkMonsterCollision(alternativePosition)) {
                                                monster.position.lerp(alternativePosition, 0.03);
                                            }
                                        } catch (error) {
                                            console.warn('Monster patrol pathfinding error:', error);
                                            // Fallback: stay in place
                                        }
                                    }
                             
                             // Look in movement direction
                             if (patrolDirection.length() > 0.1) {
                                 monster.lookAt(monster.position.clone().add(patrolDirection));
                             }
                             
                             // Walking animation
                             monsterData.walkCycle = (monsterData.walkCycle || 0) + 0.1;
                             if (monsterData.walkCycle > Math.PI * 2) monsterData.walkCycle = 0;
                             
                             // Animate arms and legs during walk
                             const arms = monster.children.filter(child => child.geometry && child.geometry.type === 'CylinderGeometry' && Math.abs(child.position.x) > 0.4);
                             const legs = monster.children.filter(child => child.geometry && child.geometry.type === 'CylinderGeometry' && child.position.y < 0);
                             
                             arms.forEach((arm, index) => {
                                 arm.rotation.z = (index === 0 ? Math.PI / 6 : -Math.PI / 6) + Math.sin(monsterData.walkCycle) * 0.2;
                             });
                             
                             legs.forEach((leg, index) => {
                                 leg.rotation.z = Math.sin(monsterData.walkCycle + (index * Math.PI)) * 0.1;
                             });
                             
                             // Hide monster health bar when not in combat
                             hideMonsterHealthBar(monster);
                         }
                         
                         // Idle animation
                         monsterData.idleCycle = (monsterData.idleCycle || 0) + 0.05;
                         if (monsterData.idleCycle > Math.PI * 2) monsterData.idleCycle = 0;
                         
                         // Subtle breathing animation
                         monster.position.y = 0.5 + Math.sin(monsterData.idleCycle) * 0.02;
                     }
                 });
             }
            
            // Update combat cooldowns
            if (combatState.attackCooldown > 0) {
                combatState.attackCooldown -= 16; // Assuming 60fps
            }
            
            // Update interaction prompts
            if (gameState.currentScene === 'dungeon') {
                showDoorInteractionPrompt();
                showPortalInteractionPrompt();
                updateCollisionStatus();
            }
            
            // Particle animation disabled for WebGL compatibility
            
            // Update sword animations for warriors
            if (gameState.currentScene === 'dungeon' && selectedClass === 'warrior') {
                updateSwordAnimation();
            }
            
            // Render scene
            renderer.render(scene, camera);
        }

        function handlePlayerMovement() {
            const moveSpeed = moveState.running ? 0.18 : 0.12; // Optimized speeds for smooth movement
            const direction = new THREE.Vector3();
            
            // Calculate movement direction based on camera orientation
            if (moveState.forward) {
                direction.z -= 1;
            }
            if (moveState.backward) {
                direction.z += 1;
            }
            if (moveState.left) {
                direction.x -= 1;
            }
            if (moveState.right) {
                direction.x += 1;
            }
            
            if (direction.length() > 0) {
                direction.normalize();
                
                // Apply camera rotation to movement direction
                direction.applyQuaternion(camera.quaternion);
                direction.y = 0; // Keep movement on horizontal plane
                
                // Check for collision before moving
                const newPosition = camera.position.clone().add(direction.multiplyScalar(moveSpeed));
                if (!checkCollision(newPosition)) {
                    // Smooth movement with small lerp for stability
                    camera.position.lerp(newPosition, 0.85);
                    
                    // Keep player at consistent height with smooth adjustment
                    const targetHeight = 1.7;
                    if (Math.abs(camera.position.y - targetHeight) > 0.01) {
                        camera.position.y += (targetHeight - camera.position.y) * 0.1;
                    }
                    
                    // Consume stamina when moving
                    if (playerStats.stamina > 0) {
                        playerStats.stamina = Math.max(0, Math.round((playerStats.stamina - 0.015) * 100) / 100);
                        updateHUD();
                    }
                    
                    // Update minimap if visible
                    if (gameState.currentScene === 'dungeon') {
                        const miniMap = document.getElementById('miniMap');
                        if (miniMap && miniMap.style.display === 'block') {
                            updateMinimap();
                        }
                    }
                }
            }
            
            // Regenerate stamina when not moving
            if (!moveState.forward && !moveState.backward && !moveState.left && !moveState.right) {
                if (playerStats.stamina < playerStats.maxStamina) {
                    playerStats.stamina = Math.min(playerStats.maxStamina, Math.round((playerStats.stamina + 0.2) * 100) / 100);
                    updateHUD();
                }
            }
        }
        
        function checkCollision(newPosition) {
            // Only check collisions in dungeon
            if (gameState.currentScene !== 'dungeon') {
                return false;
            }
            
            // Skip collision detection if wall collision is disabled for debugging
            if (!gameState.wallCollisionEnabled) {
                return false;
            }
            
            // Enhanced collision detection with dungeon walls and rooms
            const dungeonSize = 20 + (gameState.currentLevel * 5);
            const playerRadius = 0.5;
            
            // Check boundary walls with player radius
            if (Math.abs(newPosition.x) > dungeonSize - 1 - playerRadius || Math.abs(newPosition.z) > dungeonSize - 1 - playerRadius) {
                return true; // Collision with boundary
            }
            
            // Check room wall collisions with door openings
            const roomPositions = [
                { x: 0, z: 0, size: 12, doors: [{ x: 0, z: -4, width: 2 }] },      // Center room with north door
                { x: -16, z: 0, size: 12, doors: [{ x: -16, z: -8, width: 2 }, { x: -16, z: 8, width: 2 }] },    // Left room
                { x: 16, z: 0, size: 12, doors: [{ x: 16, z: -8, width: 2 }, { x: 16, z: 8, width: 2 }] },     // Right room
                { x: 0, z: -16, size: 12, doors: [{ x: -8, z: -16, width: 2 }, { x: 8, z: -16, width: 2 }] },    // Back room
                { x: 0, z: 16, size: 12, doors: [{ x: -8, z: 16, width: 2 }, { x: 8, z: 16, width: 2 }] }      // Front room
            ];
            
            for (let room of roomPositions) {
                const distanceX = Math.abs(newPosition.x - room.x);
                const distanceZ = Math.abs(newPosition.z - room.z);
                
                // Check if player is inside room walls
                if (distanceX < room.size/2 + playerRadius && distanceZ < room.size/2 + playerRadius) {
                    // Check if player is too close to room walls, but allow passage through doors
                    if (distanceX > room.size/2 - playerRadius || distanceZ > room.size/2 - playerRadius) {
                        // Check if player is near a door (allow passage)
                        let nearDoor = false;
                        for (let door of room.doors) {
                            const doorDistanceX = Math.abs(newPosition.x - door.x);
                            const doorDistanceZ = Math.abs(newPosition.z - door.z);
                            if (doorDistanceX < door.width/2 + playerRadius && doorDistanceZ < 1 + playerRadius) {
                                nearDoor = true;
                                break;
                            }
                        }
                        
                        // Also check if any door in the dungeon is open and nearby
                        if (!nearDoor && window.dungeonDoors) {
                            for (let door of window.dungeonDoors) {
                                if (door.userData.isOpen) {
                                    const doorDistance = Math.hypot(
                                        newPosition.x - door.position.x,
                                        newPosition.z - door.position.z
                                    );
                                    if (doorDistance < 2 + playerRadius) {
                                        nearDoor = true;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (!nearDoor) {
                            return true; // Collision with room wall (not near door)
                        }
                    }
                }
            }
            
            // Check corridor wall collisions
            const corridorPositions = [
                { x: 0, z: -8, width: 10, length: 4, horizontal: true },
                { x: 0, z: 8, width: 10, length: 4, horizontal: true },
                { x: -8, z: 0, width: 4, length: 10, horizontal: false },
                { x: 8, z: 0, width: 4, length: 10, horizontal: false }
            ];
            
            for (let corridor of corridorPositions) {
                if (corridor.horizontal) {
                    if (Math.abs(newPosition.x) < corridor.width/2 + playerRadius && 
                        Math.abs(newPosition.z - corridor.z) < corridor.length/2 + playerRadius) {
                        // Check if player is too close to corridor walls
                        if (Math.abs(newPosition.x) > corridor.width/2 - playerRadius || 
                            Math.abs(newPosition.z - corridor.z) > corridor.length/2 - playerRadius) {
                            return true; // Collision with corridor wall
                        }
                    }
                } else {
                    if (Math.abs(newPosition.x - corridor.x) < corridor.width/2 + playerRadius && 
                        Math.abs(newPosition.z) < corridor.length/2 + playerRadius) {
                        // Check if player is too close to corridor walls
                        if (Math.abs(newPosition.x - corridor.x) > corridor.width/2 - playerRadius || 
                            Math.abs(newPosition.z) > corridor.length/2 - playerRadius) {
                            return true; // Collision with corridor wall
                        }
                    }
                }
            }
            
            return false; // No collision
        }
        
        function checkMonsterCollision(newPosition) {
            // Only check collisions in dungeon
            if (gameState.currentScene !== 'dungeon') {
                return false;
            }
            
            const dungeonSize = 20 + (gameState.currentLevel * 5);
            const monsterRadius = 0.4; // Slightly larger radius for better collision detection
            
            // Check boundary walls with safety margin
            if (Math.abs(newPosition.x) > dungeonSize - 2 - monsterRadius || Math.abs(newPosition.z) > dungeonSize - 2 - monsterRadius) {
                return true; // Collision with boundary
            }
            
            // Check room collisions with improved logic
            const roomPositions = [
                { x: 0, z: 0, size: 12 },      // Center room
                { x: -16, z: 0, size: 12 },    // Left room
                { x: 16, z: 0, size: 12 },     // Right room
                { x: 0, z: -16, size: 12 },    // Back room
                { x: 0, z: 16, size: 12 }      // Front room
            ];
            
            for (let room of roomPositions) {
                const distanceX = Math.abs(newPosition.x - room.x);
                const distanceZ = Math.abs(newPosition.z - room.z);
                
                // Check if monster is inside room walls
                if (distanceX < room.size/2 + monsterRadius && distanceZ < room.size/2 + monsterRadius) {
                    // Check if monster is too close to room walls
                    if (distanceX > room.size/2 - monsterRadius || distanceZ > room.size/2 - monsterRadius) {
                        return true; // Collision with room wall
                    }
                }
            }
            
            // Check corridor collisions
            const corridorPositions = [
                { x: 0, z: -8, width: 10, length: 4, horizontal: true },
                { x: 0, z: 8, width: 4, length: 10, horizontal: false },
                { x: -8, z: 0, width: 4, length: 10, horizontal: false },
                { x: 8, z: 0, width: 4, length: 10, horizontal: false }
            ];
            
            for (let corridor of corridorPositions) {
                if (corridor.horizontal) {
                    if (Math.abs(newPosition.x) < corridor.width/2 + monsterRadius && 
                        Math.abs(newPosition.z - corridor.z) < corridor.length/2 + monsterRadius) {
                        // Check if monster is too close to corridor walls
                        if (Math.abs(newPosition.x) > corridor.width/2 - monsterRadius || 
                            Math.abs(newPosition.z - corridor.z) > corridor.length/2 - monsterRadius) {
                            return true; // Collision with corridor wall
                        }
                    }
                } else {
                    if (Math.abs(newPosition.x - corridor.x) < corridor.width/2 + monsterRadius && 
                        Math.abs(newPosition.z) < corridor.length/2 + monsterRadius) {
                        // Check if monster is too close to corridor walls
                        if (Math.abs(newPosition.x - corridor.x) > corridor.width/2 - monsterRadius || 
                            Math.abs(newPosition.z) > corridor.length/2 - monsterRadius) {
                            return true; // Collision with corridor wall
                        }
                    }
                }
            }
            
            // Check collision with other monsters
            for (let monster of monsters) {
                if (monster.position.distanceTo(newPosition) < monsterRadius * 2) {
                    return true; // Collision with other monster
                }
            }
            
            return false; // No collision
        }
        
        function findAlternativePath(currentPosition, direction, speed) {
            // Try different angles to find a clear path
            const angles = [Math.PI/4, -Math.PI/4, Math.PI/2, -Math.PI/2];
            
            for (let angle of angles) {
                const rotatedDirection = direction.clone();
                rotatedDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle); // Use applyAxisAngle instead
                const alternativePosition = currentPosition.clone().add(rotatedDirection.multiplyScalar(speed));
                alternativePosition.y = 0.5; // Keep on ground
                
                if (!checkMonsterCollision(alternativePosition)) {
                    return alternativePosition;
                }
            }
            
            return null; // No alternative path found
        }

        function attackTarget(target) {
            if (combatState.attackCooldown > 0 || target.userData.health <= 0) return;
            
            const distance = camera.position.distanceTo(target.position);
            if (distance > 3) {
                showMessage('Target too far away!');
                return;
            }
            
            // Calculate damage
            let damage = playerStats.attackPower;
            const isCritical = Math.random() < playerStats.criticalChance;
            if (isCritical) {
                damage *= 2;
                showMessage('CRITICAL HIT!');
            }
            
            // Apply damage to target
            target.userData.health -= damage;
            showMessage(`Dealt ${damage} damage!`);
            
            // Check if target is defeated
            if (target.userData.health <= 0) {
                defeatMonster(target);
            }
            
            // Trigger sword slashing animation for warriors
            if (selectedClass === 'warrior' && gameState.playerWeapon) {
                triggerSwordSlash();
            }
            
            // Set attack cooldown
            combatState.attackCooldown = 500; // 500ms cooldown
            combatState.lastAttack = Date.now();
        }

        function attackPlayer(monster) {
            // Only allow attacks in dungeon
            if (gameState.currentScene !== 'dungeon') {
                return;
            }
            
            // Check if player dodges
            if (Math.random() < playerStats.dodgeChance) {
                showMessage('You dodged the attack!');
                return;
            }
            
            // Balanced monster damage
            const baseDamage = monster.userData.damage * 0.5; // Balanced damage
            const damage = Math.max(1, Math.floor(baseDamage - playerStats.defense * 0.3));
            playerStats.health -= damage;
            showMessage(`You took ${damage} damage from ${monster.userData.type}!`);
            
            // Check if player is defeated
            if (playerStats.health <= 0) {
                playerDefeated();
            }
            
            updateHUD();
        }

        function defeatMonster(monster) {
            // Grant XP and gold
            const xpGain = 20 + (gameState.currentLevel * 5);
            const goldGain = 10 + (gameState.currentLevel * 2);
            
            playerStats.xp += xpGain;
            gameState.gold += goldGain;
            
            showMessage(`Monster defeated! +${xpGain} XP, +${goldGain} Gold`);
            
            // Check for level up
            if (playerStats.xp >= playerStats.nextLevelXP) {
                levelUp();
            }
            
            // Clean up monster health bar
            if (monster.userData.healthBar) {
                monster.userData.healthBar.remove();
                delete monster.userData.healthBar;
                delete monster.userData.healthFill;
            }
            
            // Remove monster from scene
            scene.remove(monster);
            const index = monsters.indexOf(monster);
            if (index > -1) {
                monsters.splice(index, 1);
            }
            
            // Update monster counter
            const monsterCounter = document.querySelector('#monsterCount');
            if (monsterCounter) {
                monsterCounter.textContent = monsters.filter(m => m.userData.health > 0).length;
            }
            
            updateHUD();
        }

        function levelUp() {
            playerStats.level++;
            playerStats.xp -= playerStats.nextLevelXP;
            playerStats.nextLevelXP = Math.floor(playerStats.nextLevelXP * 1.5);
            gameState.skillPoints += 2;
            
            // Increase stats
            playerStats.maxHealth += 10;
            playerStats.maxMana += 5;
            playerStats.maxStamina += 5;
            playerStats.health = playerStats.maxHealth;
            playerStats.mana = playerStats.maxMana;
            playerStats.stamina = playerStats.maxStamina;
            
            showMessage(`Level Up! You are now level ${playerStats.level}!`);
            updateHUD();
        }

        function playerDefeated() {
            showMessage('You have been defeated! Returning to camp...');
            setTimeout(() => {
                returnToCamp();
            }, 2000);
        }

        function returnToCamp() {
            gameState.currentScene = 'camp';
            document.getElementById('crosshair').style.display = 'none';
            
            // Hide interaction prompts
            const doorPrompt = document.getElementById('doorPrompt');
            if (doorPrompt) doorPrompt.style.display = 'none';
            const portalPrompt = document.getElementById('portalPrompt');
            if (portalPrompt) portalPrompt.style.display = 'none';
            const collisionIndicator = document.getElementById('collisionIndicator');
            if (collisionIndicator) collisionIndicator.style.display = 'none';
            
            // Remove dungeon from scene
            scene.remove(dungeon);
            
            // Reset player stats
            playerStats.health = playerStats.maxHealth;
            playerStats.mana = playerStats.maxMana;
            playerStats.stamina = playerStats.maxStamina;
            
            // Show camp
            createCamp();
            scene.add(camp);
            showCamp();
            updateHUD();
        }
        
        function goDeeper() {
            // Increase dungeon level
            gameState.currentLevel++;
            
            // Grant bonus XP for going deeper
            const bonusXP = 50 + (gameState.currentLevel * 10);
            playerStats.xp += bonusXP;
            showMessage(`Going deeper! +${bonusXP} XP bonus!`);
            
            // Check for level up
            if (playerStats.xp >= playerStats.nextLevelXP) {
                levelUp();
            }
            
            // Remove current dungeon
            scene.remove(dungeon);
            
            // Hide interaction prompts
            const doorPrompt = document.getElementById('doorPrompt');
            if (doorPrompt) doorPrompt.style.display = 'none';
            const portalPrompt = document.getElementById('portalPrompt');
            if (portalPrompt) portalPrompt.style.display = 'none';
            const collisionIndicator = document.getElementById('collisionIndicator');
            if (collisionIndicator) collisionIndicator.style.display = 'none';
            
            // Generate new, deeper dungeon
            generateDungeon();
            
            // Position player at new dungeon entrance - in center room
            camera.position.set(0, 1.7, 0);
            
            // Update HUD
            updateHUD();
            
            showMessage(`Welcome to dungeon level ${gameState.currentLevel}!`);
        }

        function interactWithNearby() {
            // Check for nearby items
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            // Check for items
            const itemIntersects = raycaster.intersectObjects(items);
            if (itemIntersects.length > 0) {
                const item = itemIntersects[0].object;
                if (camera.position.distanceTo(item.position) < 3) {
                    collectItem(item);
                    return;
                }
            }
            
            // Check for exit portal
            const portalIntersects = raycaster.intersectObjects(dungeon.children.filter(child => child.userData.type === 'exit'));
            if (portalIntersects.length > 0) {
                const portal = portalIntersects[0].object;
                if (camera.position.distanceTo(portal.position) < 3) {
                    showMessage('Press E to exit dungeon');
                    if (keys['KeyE']) {
                        returnToCamp();
                    }
                }
            }
            
            // Check for deeper portal
            const deeperPortalIntersects = raycaster.intersectObjects(dungeon.children.filter(child => child.userData.type === 'deeper'));
            if (deeperPortalIntersects.length > 0) {
                const deeperPortal = deeperPortalIntersects[0].object;
                if (camera.position.distanceTo(deeperPortal.position) < 3) {
                    showMessage('Press E to go deeper into the dungeon');
                    if (keys['KeyE']) {
                        goDeeper();
                    }
                }
            }
            
            // Check for monsters to attack
            const monsterIntersects = raycaster.intersectObjects(monsters);
            if (monsterIntersects.length > 0) {
                const monster = monsterIntersects[0].object;
                if (camera.position.distanceTo(monster.position) < 4) {
                    showMessage(`Press Click to attack ${monster.userData.type}`);
                }
            }
        }

        function collectItem(item) {
            const itemData = {
                name: item.userData.type,
                description: `${item.userData.type} worth ${item.userData.value} gold`,
                value: item.userData.value,
                type: item.userData.type
            };
            
            gameState.inventory.push(itemData);
            showMessage(`Collected ${item.userData.type}!`);
            
            // Remove item from scene
            scene.remove(item);
            const index = items.indexOf(item);
            if (index > -1) {
                items.splice(index, 1);
            }
            
            updateInventoryDisplay();
        }

        function useSpecialAbility() {
            if (playerStats.mana < 20) {
                showMessage('Not enough mana!');
                return;
            }
            
            playerStats.mana -= 20;
            
            switch(selectedClass) {
                case 'warrior':
                    // Warrior ability: Battle Cry
                    showMessage('Battle Cry! All nearby monsters are stunned!');
                    monsters.forEach(monster => {
                        monster.userData.stunned = true;
                        setTimeout(() => monster.userData.stunned = false, 3000);
                    });
                    break;
                case 'mage':
                    // Mage ability: Fireball with visual effects
                    showMessage('Fireball! Massive damage to all monsters!');
                    castFireball();
                    monsters.forEach(monster => {
                        monster.userData.health -= 30;
                        if (monster.userData.health <= 0) {
                            defeatMonster(monster);
                        }
                    });
                    break;
                case 'rogue':
                    // Rogue ability: Stealth
                    showMessage('Stealth! Monsters cannot see you for 5 seconds!');
                    playerStats.stealth = true;
                    setTimeout(() => playerStats.stealth = false, 5000);
                    break;
            }
            
            updateHUD();
        }
        
        function castFireball() {
            if (!gameState.playerWeapon) return;
            
            const staff = gameState.playerWeapon;
            const staffData = staff.userData;
            
            // Start casting animation
            staffData.isCasting = true;
            staffData.castProgress = 0;
            
            // Create fireball projectile
            const fireballGeometry = new THREE.SphereGeometry(0.3, 8, 6);
            const fireballMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFF4500,
                emissive: 0x8B0000
            });
            const fireball = new THREE.Mesh(fireballGeometry, fireballMaterial);
            
            // Position fireball at staff tip
            fireball.position.copy(staff.position);
            fireball.position.y += 1.8;
            fireball.position.z -= 0.5;
            
            // Add fireball to scene
            scene.add(fireball);
            
            // Animate fireball
            const fireballAnimation = () => {
                if (fireball.position.z > -20) {
                    fireball.position.z -= 0.5;
                    fireball.rotation.y += 0.2;
                    requestAnimationFrame(fireballAnimation);
                } else {
                    scene.remove(fireball);
                }
            };
            
            fireballAnimation();
            
            console.log('Fireball cast!');
        }

        function showMessage(message) {
            const popup = document.getElementById('popup');
            popup.textContent = message;
            popup.style.opacity = '1';
            
            setTimeout(() => {
                popup.style.opacity = '0';
            }, 2000);
        }
        
        function adjustMouseSensitivity(direction) {
            // Adjust mouse sensitivity with fine control
            if (direction === 'up') {
                gameState.mouseSensitivity = Math.min(0.005, gameState.mouseSensitivity + 0.0001);
            } else if (direction === 'down') {
                gameState.mouseSensitivity = Math.max(0.0001, gameState.mouseSensitivity - 0.0001);
            }
            
            // Show current sensitivity setting
            showMessage(`Mouse Sensitivity: ${(gameState.mouseSensitivity * 1000).toFixed(1)}`);
        }
        
        function adjustDPIMultiplier(direction) {
            // Adjust DPI multiplier for different mouse DPI settings
            if (direction === 'up') {
                gameState.dpiMultiplier = Math.min(2.0, gameState.dpiMultiplier + 0.1);
            } else if (direction === 'down') {
                gameState.dpiMultiplier = Math.max(0.1, gameState.dpiMultiplier - 0.1);
            }
            
            // Show current DPI multiplier setting
            showMessage(`DPI Multiplier: ${gameState.dpiMultiplier.toFixed(1)}`);
        }
        
        function resetMouseSettings() {
            // Reset mouse sensitivity to default values
            gameState.mouseSensitivity = 0.001;
            gameState.dpiMultiplier = 1.0;
            showMessage('Mouse settings reset to default');
        }
        
        function toggleWallCollision() {
            // Toggle wall collision for debugging
            gameState.wallCollisionEnabled = !gameState.wallCollisionEnabled;
            const status = gameState.wallCollisionEnabled ? 'enabled' : 'disabled';
            showMessage(`Wall collision ${status} (F1 to toggle)`);
            
            // Visual feedback - change crosshair color
            const crosshair = document.getElementById('crosshair');
            if (crosshair) {
                if (gameState.wallCollisionEnabled) {
                    crosshair.style.borderColor = '#ffffff'; // Normal white
                    crosshair.style.backgroundColor = 'transparent';
                } else {
                    crosshair.style.borderColor = '#ff0000'; // Red when collision disabled
                    crosshair.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                }
            }
        }
        
        function updateCollisionStatus() {
            // Update collision status indicator in HUD
            let collisionIndicator = document.getElementById('collisionIndicator');
            if (!collisionIndicator) {
                collisionIndicator = createCollisionIndicator();
            }
            
            if (collisionIndicator) {
                const status = gameState.wallCollisionEnabled ? 'ON' : 'OFF';
                const color = gameState.wallCollisionEnabled ? '#00ff00' : '#ff0000';
                collisionIndicator.innerHTML = `Collision: <span style="color: ${color};">${status}</span>`;
                collisionIndicator.style.display = 'block';
            }
        }
        
        function createCollisionIndicator() {
            // Create collision status indicator
            const indicator = document.createElement('div');
            indicator.id = 'collisionIndicator';
            indicator.style.cssText = `
                position: absolute;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.8);
                color: #ccc;
                padding: 8px 12px;
                border-radius: 5px;
                border: 1px solid #666;
                font-size: 12px;
                font-weight: bold;
                pointer-events: none;
                z-index: 1000;
            `;
            document.body.appendChild(indicator);
            return indicator;
        }
        
        function toggleMinimap() {
            const miniMap = document.getElementById('miniMap');
            if (miniMap) {
                miniMap.style.display = miniMap.style.display === 'none' ? 'block' : 'none';
                if (miniMap.style.display === 'block') {
                    updateMinimap();
                }
            }
        }
        
        function toggleInventory() {
            const inventory = document.getElementById('inventory');
            if (inventory) {
                inventory.style.display = inventory.style.display === 'none' ? 'block' : 'none';
                if (inventory.style.display === 'block') {
                    updateInventoryDisplay();
                }
            }
        }
        
        function updateMinimap() {
            const miniMap = document.getElementById('miniMap');
            if (!miniMap || !dungeon) return;
            
            // Clear existing map content
            const mapContent = miniMap.querySelector('.mapContent') || document.createElement('div');
            mapContent.className = 'mapContent';
            mapContent.style.cssText = `
                width: 100%;
                height: calc(100% - 40px);
                position: relative;
                background: #1a1a1a;
                border-radius: 5px;
            `;
            
            // Add player position (blue dot)
            const playerDot = document.createElement('div');
            playerDot.style.cssText = `
                position: absolute;
                width: 8px;
                height: 8px;
                background: #00ffff;
                border-radius: 50%;
                border: 2px solid white;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                z-index: 10;
            `;
            mapContent.appendChild(playerDot);
            
            // Add exit portal (green dot)
            const exitPortal = dungeon.children.find(child => child.userData.type === 'exit');
            if (exitPortal) {
                const exitDot = document.createElement('div');
                exitDot.style.cssText = `
                    position: absolute;
                    width: 8px;
                    height: 8px;
                    background: #00ff00;
                    border-radius: 50%;
                    border: 2px solid white;
                    left: 50%;
                    top: 10%;
                    transform: translate(-50%, -50%);
                    z-index: 10;
                `;
                mapContent.appendChild(exitDot);
            }
            
            // Add monster positions (red dots)
            monsters.forEach(monster => {
                if (monster.userData.health > 0) {
                    const monsterDot = document.createElement('div');
                    const relativeX = ((monster.position.x + 25) / 50) * 100;
                    const relativeZ = ((monster.position.z + 25) / 50) * 100;
                    
                    monsterDot.style.cssText = `
                        position: absolute;
                        width: 6px;
                        height: 6px;
                        background: #ff0000;
                        border-radius: 50%;
                        left: ${relativeX}%;
                        top: ${relativeZ}%;
                        transform: translate(-50%, -50%);
                        z-index: 5;
                    `;
                    mapContent.appendChild(monsterDot);
                }
            });
            
            if (!miniMap.querySelector('.mapContent')) {
                miniMap.appendChild(mapContent);
            }
        }

        function loadGame() {
            const savedGame = localStorage.getItem('dungeonCrawlerSave');
            if (savedGame) {
                try {
                    const gameData = JSON.parse(savedGame);
                    
                    // Restore game state
                    Object.assign(gameState, gameData.gameState);
                    Object.assign(playerStats, gameData.playerStats);
                    selectedClass = gameData.selectedClass;
                    
                    showMessage('Game loaded successfully!');
                    
                    // Start game directly
                    initGame();
                } catch (error) {
                    alert('Error loading save file. Starting new game.');
                    startNewGame();
                }
            } else {
                alert('No save file found. Starting new game.');
                startNewGame();
            }
        }

        function saveGame() {
            const saveData = {
                gameState: gameState,
                playerStats: playerStats,
                selectedClass: selectedClass,
                timestamp: Date.now()
            };
            
            try {
                localStorage.setItem('dungeonCrawlerSave', JSON.stringify(saveData));
                showMessage('Game saved successfully!');
            } catch (error) {
                alert('Error saving game!');
            }
        }

        function autoSave() {
            // Auto-save every 30 seconds
            setInterval(() => {
                if (gameState.currentScene !== 'menu') {
                    saveGame();
                }
            }, 30000);
        }

        function showSettings() {
            // TODO: Implement settings
            alert('Settings coming soon!');
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function showMonsterHealthBar(monster) {
            // Create or update monster health bar
            let healthBar = monster.userData.healthBar;
            if (!healthBar) {
                healthBar = document.createElement('div');
                healthBar.style.cssText = `
                    position: absolute;
                    background: rgba(0,0,0,0.8);
                    border: 1px solid #e94560;
                    border-radius: 3px;
                    padding: 2px;
                    width: 60px;
                    height: 8px;
                    z-index: 200;
                    pointer-events: none;
                `;
                
                const healthFill = document.createElement('div');
                healthFill.style.cssText = `
                    background: linear-gradient(90deg, #e74c3c, #c0392b);
                    height: 100%;
                    border-radius: 2px;
                    transition: width 0.3s ease;
                `;
                healthBar.appendChild(healthFill);
                monster.userData.healthBar = healthBar;
                monster.userData.healthFill = healthFill;
                document.body.appendChild(healthBar);
            }
            
            // Update health bar position and health
            const monsterScreenPos = getMonsterScreenPosition(monster);
            if (monsterScreenPos) {
                healthBar.style.left = (monsterScreenPos.x - 30) + 'px';
                healthBar.style.top = (monsterScreenPos.y - 30) + 'px';
                healthBar.style.display = 'block';
                
                const healthPercent = (monster.userData.health / (monster.userData.health + gameState.currentLevel * 5)) * 100;
                monster.userData.healthFill.style.width = Math.max(0, healthPercent) + '%';
            }
        }

        function hideMonsterHealthBar(monster) {
            if (monster.userData.healthBar) {
                monster.userData.healthBar.style.display = 'none';
            }
        }

        function getMonsterScreenPosition(monster) {
            // Convert 3D world position to 2D screen position
            const vector = monster.position.clone();
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;
            
            // Check if monster is behind camera
            if (vector.z > 1) {
                return null;
            }
            
            return { x, y };
        }

        // Initialize game when page loads
        window.addEventListener('load', () => {
            init();
            autoSave();
        });
    </script>
</body>
</html>
